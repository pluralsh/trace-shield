// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/pluralsh/trace-shield-controller/api/observability/v1alpha1"
	"github.com/pluralsh/trace-shield/graph/custom"
	"github.com/pluralsh/trace-shield/graph/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
	"k8s.io/apimachinery/pkg/apis/meta/v1"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Group() GroupResolver
	LoginBindings() LoginBindingsResolver
	Mutation() MutationResolver
	OAuth2Client() OAuth2ClientResolver
	ObservabilityTenant() ObservabilityTenantResolver
	ObservabilityTenantPermissionBindings() ObservabilityTenantPermissionBindingsResolver
	Organization() OrganizationResolver
	Query() QueryResolver
	User() UserResolver
}

type DirectiveRoot struct {
	CheckPermissions func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	IsAuthenticated  func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
}

type ComplexityRoot struct {
	ForwardingRule struct {
		Ingest func(childComplexity int) int
	}

	Group struct {
		Members func(childComplexity int) int
		Name    func(childComplexity int) int
	}

	LoginBindings struct {
		Groups func(childComplexity int) int
		Users  func(childComplexity int) int
	}

	LokiLimits struct {
		RequestRate func(childComplexity int) int
	}

	MimirLimits struct {
		AcceptHASamples                               func(childComplexity int) int
		AlertmanagerMaxAlertsCount                    func(childComplexity int) int
		AlertmanagerMaxAlertsSizeBytes                func(childComplexity int) int
		AlertmanagerMaxConfigSizeBytes                func(childComplexity int) int
		AlertmanagerMaxDispatcherAggregationGroups    func(childComplexity int) int
		AlertmanagerMaxTemplateSizeBytes              func(childComplexity int) int
		AlertmanagerMaxTemplatesCount                 func(childComplexity int) int
		AlertmanagerReceiversBlockCIDRNetworks        func(childComplexity int) int
		AlertmanagerReceiversBlockPrivateAddresses    func(childComplexity int) int
		CardinalityAnalysisEnabled                    func(childComplexity int) int
		CompactorBlockUploadEnabled                   func(childComplexity int) int
		CompactorBlockUploadValidationEnabled         func(childComplexity int) int
		CompactorBlockUploadVerifyChunks              func(childComplexity int) int
		CompactorBlocksRetentionPeriod                func(childComplexity int) int
		CompactorPartialBlockDeletionDelay            func(childComplexity int) int
		CompactorSplitAndMergeShards                  func(childComplexity int) int
		CompactorSplitGroups                          func(childComplexity int) int
		CompactorTenantShardSize                      func(childComplexity int) int
		CreationGracePeriod                           func(childComplexity int) int
		DropLabels                                    func(childComplexity int) int
		EnforceMetadataMetricName                     func(childComplexity int) int
		ForwardingDropOlderThan                       func(childComplexity int) int
		ForwardingEndpoint                            func(childComplexity int) int
		ForwardingRules                               func(childComplexity int) int
		HAClusterLabel                                func(childComplexity int) int
		HAMaxClusters                                 func(childComplexity int) int
		HAReplicaLabel                                func(childComplexity int) int
		IngestionBurstSize                            func(childComplexity int) int
		IngestionRate                                 func(childComplexity int) int
		IngestionTenantShardSize                      func(childComplexity int) int
		LabelNamesAndValuesResultsMaxSizeBytes        func(childComplexity int) int
		LabelValuesMaxCardinalityLabelNamesPerRequest func(childComplexity int) int
		MaxCacheFreshness                             func(childComplexity int) int
		MaxChunksPerQuery                             func(childComplexity int) int
		MaxFetchedChunkBytesPerQuery                  func(childComplexity int) int
		MaxFetchedSeriesPerQuery                      func(childComplexity int) int
		MaxGlobalExemplarsPerUser                     func(childComplexity int) int
		MaxGlobalMetadataPerMetric                    func(childComplexity int) int
		MaxGlobalMetricsWithMetadataPerUser           func(childComplexity int) int
		MaxGlobalSeriesPerMetric                      func(childComplexity int) int
		MaxGlobalSeriesPerUser                        func(childComplexity int) int
		MaxLabelNameLength                            func(childComplexity int) int
		MaxLabelNamesPerSeries                        func(childComplexity int) int
		MaxLabelValueLength                           func(childComplexity int) int
		MaxLabelsQueryLength                          func(childComplexity int) int
		MaxMetadataLength                             func(childComplexity int) int
		MaxPartialQueryLength                         func(childComplexity int) int
		MaxQueriersPerTenant                          func(childComplexity int) int
		MaxQueryExpressionSizeBytes                   func(childComplexity int) int
		MaxQueryLookback                              func(childComplexity int) int
		MaxQueryParallelism                           func(childComplexity int) int
		MaxTotalQueryLength                           func(childComplexity int) int
		NativeHistogramsIngestionEnabled              func(childComplexity int) int
		NotificationRateLimit                         func(childComplexity int) int
		NotificationRateLimitPerIntegration           func(childComplexity int) int
		OutOfOrderBlocksExternalLabelEnabled          func(childComplexity int) int
		OutOfOrderTimeWindow                          func(childComplexity int) int
		QueryShardingMaxRegexpSizeBytes               func(childComplexity int) int
		QueryShardingMaxShardedQueries                func(childComplexity int) int
		QueryShardingTotalShards                      func(childComplexity int) int
		RequestBurstSize                              func(childComplexity int) int
		RequestRate                                   func(childComplexity int) int
		ResultsCacheTTL                               func(childComplexity int) int
		ResultsCacheTTLForOutOfOrderTimeWindow        func(childComplexity int) int
		RulerAlertingRulesEvaluationEnabled           func(childComplexity int) int
		RulerEvaluationDelay                          func(childComplexity int) int
		RulerMaxRuleGroupsPerTenant                   func(childComplexity int) int
		RulerMaxRulesPerRuleGroup                     func(childComplexity int) int
		RulerRecordingRulesEvaluationEnabled          func(childComplexity int) int
		RulerTenantShardSize                          func(childComplexity int) int
		S3SSEKMSEncryptionContext                     func(childComplexity int) int
		S3SSEKMSKeyID                                 func(childComplexity int) int
		S3SSEType                                     func(childComplexity int) int
		SeparateMetricsGroupLabel                     func(childComplexity int) int
		SplitInstantQueriesByInterval                 func(childComplexity int) int
		StoreGatewayTenantShardSize                   func(childComplexity int) int
	}

	Mutation struct {
		AcceptOAuth2ConsentRequest func(childComplexity int, challenge string, grantAccessTokenAudience []string, grantScope []string, remember *bool, rememberFor *int64) int
		AcceptOAuth2LoginRequest   func(childComplexity int, challenge string, acr *string, amr []string, context map[string]interface{}, remember *bool, rememberFor *int64, subject string) int
		CreateOAuth2Client         func(childComplexity int, allowedCorsOrigins []string, audience []string, authorizationCodeGrantAccessTokenLifespan *string, authorizationCodeGrantIDTokenLifespan *string, authorizationCodeGrantRefreshTokenLifespan *string, backChannelLogoutSessionRequired *bool, backChannelLogoutURI *string, clientCredentialsGrantAccessTokenLifespan *string, clientName *string, clientSecret *string, clientSecretExpiresAt *int64, clientURI *string, contacts []string, frontchannelLogoutSessionRequired *bool, frontchannelLogoutURI *string, grantTypes []string, implicitGrantAccessTokenLifespan *string, implicitGrantIDTokenLifespan *string, jwks map[string]interface{}, jwksURI *string, jwtBearerGrantAccessTokenLifespan *string, logoURI *string, metadata map[string]interface{}, policyURI *string, postLogoutRedirectUris []string, redirectUris []string, responseTypes []string, scope *string, sectorIdentifierURI *string, subjectType *string, tokenEndpointAuthMethod *string, tokenEndpointAuthSigningAlgorithm *string, tosURI *string, userinfoSignedResponseAlgorithm *string, loginBindings *model.LoginBindingsInput) int
		CreateObservabilityTenant  func(childComplexity int, id string, name *string, admins *model.ObservabilityTenantPermissionBindingsInput, metricsReaders *model.ObservabilityTenantPermissionBindingsInput, metricsWriters *model.ObservabilityTenantPermissionBindingsInput, metricsDeleters *model.ObservabilityTenantPermissionBindingsInput, metricsRulesReaders *model.ObservabilityTenantPermissionBindingsInput, metricsRulesWriters *model.ObservabilityTenantPermissionBindingsInput, metricsRulesDeleters *model.ObservabilityTenantPermissionBindingsInput, metricsAlertsReaders *model.ObservabilityTenantPermissionBindingsInput, metricsAlertsWriters *model.ObservabilityTenantPermissionBindingsInput, logsReaders *model.ObservabilityTenantPermissionBindingsInput, logsWriters *model.ObservabilityTenantPermissionBindingsInput, logsDeleters *model.ObservabilityTenantPermissionBindingsInput, logsRulesReaders *model.ObservabilityTenantPermissionBindingsInput, logsRulesWriters *model.ObservabilityTenantPermissionBindingsInput, logsRulesDeleters *model.ObservabilityTenantPermissionBindingsInput, tracesReaders *model.ObservabilityTenantPermissionBindingsInput, tracesWriters *model.ObservabilityTenantPermissionBindingsInput, limits *model.ObservabilityTenantLimitsInput) int
		CreateUser                 func(childComplexity int, email string, name *model.NameInput) int
		DeleteGroup                func(childComplexity int, name string) int
		DeleteOAuth2Client         func(childComplexity int, clientID string) int
		DeleteObservabilityTenant  func(childComplexity int, id string) int
		DeleteUser                 func(childComplexity int, id string) int
		Group                      func(childComplexity int, name string, members []string) int
		Organization               func(childComplexity int, name string, admins []string) int
		RejectOAuth2ConsentRequest func(childComplexity int, challenge string) int
		RejectOAuth2LoginRequest   func(childComplexity int, challenge string) int
		UpdateOAuth2Client         func(childComplexity int, allowedCorsOrigins []string, audience []string, authorizationCodeGrantAccessTokenLifespan *string, authorizationCodeGrantIDTokenLifespan *string, authorizationCodeGrantRefreshTokenLifespan *string, backChannelLogoutSessionRequired *bool, backChannelLogoutURI *string, clientCredentialsGrantAccessTokenLifespan *string, clientID string, clientName *string, clientSecret *string, clientSecretExpiresAt *int64, clientURI *string, contacts []string, frontchannelLogoutSessionRequired *bool, frontchannelLogoutURI *string, grantTypes []string, implicitGrantAccessTokenLifespan *string, implicitGrantIDTokenLifespan *string, jwks map[string]interface{}, jwksURI *string, jwtBearerGrantAccessTokenLifespan *string, logoURI *string, metadata map[string]interface{}, policyURI *string, postLogoutRedirectUris []string, redirectUris []string, responseTypes []string, scope *string, sectorIdentifierURI *string, subjectType *string, tokenEndpointAuthMethod *string, tokenEndpointAuthSigningAlgorithm *string, tosURI *string, userinfoSignedResponseAlgorithm *string, loginBindings *model.LoginBindingsInput) int
		UpdateObservabilityTenant  func(childComplexity int, id string, name *string, admins *model.ObservabilityTenantPermissionBindingsInput, metricsReaders *model.ObservabilityTenantPermissionBindingsInput, metricsWriters *model.ObservabilityTenantPermissionBindingsInput, metricsDeleters *model.ObservabilityTenantPermissionBindingsInput, metricsRulesReaders *model.ObservabilityTenantPermissionBindingsInput, metricsRulesWriters *model.ObservabilityTenantPermissionBindingsInput, metricsRulesDeleters *model.ObservabilityTenantPermissionBindingsInput, metricsAlertsReaders *model.ObservabilityTenantPermissionBindingsInput, metricsAlertsWriters *model.ObservabilityTenantPermissionBindingsInput, logsReaders *model.ObservabilityTenantPermissionBindingsInput, logsWriters *model.ObservabilityTenantPermissionBindingsInput, logsDeleters *model.ObservabilityTenantPermissionBindingsInput, logsRulesReaders *model.ObservabilityTenantPermissionBindingsInput, logsRulesWriters *model.ObservabilityTenantPermissionBindingsInput, logsRulesDeleters *model.ObservabilityTenantPermissionBindingsInput, tracesReaders *model.ObservabilityTenantPermissionBindingsInput, tracesWriters *model.ObservabilityTenantPermissionBindingsInput, limits *model.ObservabilityTenantLimitsInput) int
	}

	Name struct {
		First func(childComplexity int) int
		Last  func(childComplexity int) int
	}

	OAuth2Client struct {
		AllowedCorsOrigins                         func(childComplexity int) int
		Audience                                   func(childComplexity int) int
		AuthorizationCodeGrantAccessTokenLifespan  func(childComplexity int) int
		AuthorizationCodeGrantIDTokenLifespan      func(childComplexity int) int
		AuthorizationCodeGrantRefreshTokenLifespan func(childComplexity int) int
		BackChannelLogoutSessionRequired           func(childComplexity int) int
		BackChannelLogoutURI                       func(childComplexity int) int
		ClientCredentialsGrantAccessTokenLifespan  func(childComplexity int) int
		ClientID                                   func(childComplexity int) int
		ClientName                                 func(childComplexity int) int
		ClientSecret                               func(childComplexity int) int
		ClientSecretExpiresAt                      func(childComplexity int) int
		ClientURI                                  func(childComplexity int) int
		Contacts                                   func(childComplexity int) int
		CreatedAt                                  func(childComplexity int) int
		FrontchannelLogoutSessionRequired          func(childComplexity int) int
		FrontchannelLogoutURI                      func(childComplexity int) int
		GrantTypes                                 func(childComplexity int) int
		ImplicitGrantAccessTokenLifespan           func(childComplexity int) int
		ImplicitGrantIDTokenLifespan               func(childComplexity int) int
		Jwks                                       func(childComplexity int) int
		JwksURI                                    func(childComplexity int) int
		JwtBearerGrantAccessTokenLifespan          func(childComplexity int) int
		LoginBindings                              func(childComplexity int) int
		LogoURI                                    func(childComplexity int) int
		Metadata                                   func(childComplexity int) int
		Owner                                      func(childComplexity int) int
		PolicyURI                                  func(childComplexity int) int
		PostLogoutRedirectUris                     func(childComplexity int) int
		RedirectUris                               func(childComplexity int) int
		ResponseTypes                              func(childComplexity int) int
		Scope                                      func(childComplexity int) int
		SectorIdentifierURI                        func(childComplexity int) int
		SubjectType                                func(childComplexity int) int
		TokenEndpointAuthMethod                    func(childComplexity int) int
		TokenEndpointAuthSigningAlgorithm          func(childComplexity int) int
		TosURI                                     func(childComplexity int) int
		UpdatedAt                                  func(childComplexity int) int
		UserinfoSignedResponseAlgorithm            func(childComplexity int) int
	}

	OAuth2ConsentRequest struct {
		Acr                          func(childComplexity int) int
		Amr                          func(childComplexity int) int
		Challenge                    func(childComplexity int) int
		Client                       func(childComplexity int) int
		Context                      func(childComplexity int) int
		LoginChallenge               func(childComplexity int) int
		LoginSessionID               func(childComplexity int) int
		OidcContext                  func(childComplexity int) int
		RedirectTo                   func(childComplexity int) int
		RequestURL                   func(childComplexity int) int
		RequestedAccessTokenAudience func(childComplexity int) int
		RequestedScope               func(childComplexity int) int
		Skip                         func(childComplexity int) int
		Subject                      func(childComplexity int) int
	}

	OAuth2LoginRequest struct {
		Challenge                    func(childComplexity int) int
		Client                       func(childComplexity int) int
		OidcContext                  func(childComplexity int) int
		RedirectTo                   func(childComplexity int) int
		RequestURL                   func(childComplexity int) int
		RequestedAccessTokenAudience func(childComplexity int) int
		RequestedScope               func(childComplexity int) int
		SessionID                    func(childComplexity int) int
		Skip                         func(childComplexity int) int
		Subject                      func(childComplexity int) int
	}

	OAuth2RedirectTo struct {
		RedirectTo func(childComplexity int) int
	}

	ObservabilityTenant struct {
		Admins               func(childComplexity int) int
		ID                   func(childComplexity int) int
		Limits               func(childComplexity int) int
		LogsDeleters         func(childComplexity int) int
		LogsReaders          func(childComplexity int) int
		LogsRulesDeleters    func(childComplexity int) int
		LogsRulesReaders     func(childComplexity int) int
		LogsRulesWriters     func(childComplexity int) int
		LogsWriters          func(childComplexity int) int
		MetricsAlertsReaders func(childComplexity int) int
		MetricsAlertsWriters func(childComplexity int) int
		MetricsDeleters      func(childComplexity int) int
		MetricsReaders       func(childComplexity int) int
		MetricsRulesDeleters func(childComplexity int) int
		MetricsRulesReaders  func(childComplexity int) int
		MetricsRulesWriters  func(childComplexity int) int
		MetricsWriters       func(childComplexity int) int
		Name                 func(childComplexity int) int
		TracesReaders        func(childComplexity int) int
		TracesWriters        func(childComplexity int) int
	}

	ObservabilityTenantLimits struct {
		Mimir func(childComplexity int) int
	}

	ObservabilityTenantPermissionBindings struct {
		Groups        func(childComplexity int) int
		Oauth2Clients func(childComplexity int) int
		Users         func(childComplexity int) int
	}

	OidcContext struct {
		AcrValues         func(childComplexity int) int
		Display           func(childComplexity int) int
		IDTokenHintClaims func(childComplexity int) int
		LoginHint         func(childComplexity int) int
		UILocales         func(childComplexity int) int
	}

	Organization struct {
		Admins func(childComplexity int) int
		Name   func(childComplexity int) int
	}

	Query struct {
		GetOAuth2Client          func(childComplexity int, clientID string) int
		GetObservabilityTenant   func(childComplexity int, id string) int
		GetUser                  func(childComplexity int, id string) int
		ListGroups               func(childComplexity int) int
		ListOAuth2Clients        func(childComplexity int) int
		ListObservabilityTenants func(childComplexity int) int
		ListOrganizations        func(childComplexity int) int
		ListUsers                func(childComplexity int) int
		Oauth2ConsentRequest     func(childComplexity int, challenge string) int
		Oauth2LoginRequest       func(childComplexity int, challenge string) int
		Organization             func(childComplexity int, name string) int
	}

	TempoLimits struct {
		RequestRate func(childComplexity int) int
	}

	User struct {
		Email        func(childComplexity int) int
		Groups       func(childComplexity int) int
		ID           func(childComplexity int) int
		Name         func(childComplexity int) int
		RecoveryLink func(childComplexity int) int
	}
}

type GroupResolver interface {
	Members(ctx context.Context, obj *model.Group) ([]*model.User, error)
}
type LoginBindingsResolver interface {
	Users(ctx context.Context, obj *model.LoginBindings) ([]*model.User, error)
	Groups(ctx context.Context, obj *model.LoginBindings) ([]*model.Group, error)
}
type MutationResolver interface {
	CreateUser(ctx context.Context, email string, name *model.NameInput) (*model.User, error)
	DeleteUser(ctx context.Context, id string) (*model.User, error)
	Group(ctx context.Context, name string, members []string) (*model.Group, error)
	DeleteGroup(ctx context.Context, name string) (*model.Group, error)
	CreateOAuth2Client(ctx context.Context, allowedCorsOrigins []string, audience []string, authorizationCodeGrantAccessTokenLifespan *string, authorizationCodeGrantIDTokenLifespan *string, authorizationCodeGrantRefreshTokenLifespan *string, backChannelLogoutSessionRequired *bool, backChannelLogoutURI *string, clientCredentialsGrantAccessTokenLifespan *string, clientName *string, clientSecret *string, clientSecretExpiresAt *int64, clientURI *string, contacts []string, frontchannelLogoutSessionRequired *bool, frontchannelLogoutURI *string, grantTypes []string, implicitGrantAccessTokenLifespan *string, implicitGrantIDTokenLifespan *string, jwks map[string]interface{}, jwksURI *string, jwtBearerGrantAccessTokenLifespan *string, logoURI *string, metadata map[string]interface{}, policyURI *string, postLogoutRedirectUris []string, redirectUris []string, responseTypes []string, scope *string, sectorIdentifierURI *string, subjectType *string, tokenEndpointAuthMethod *string, tokenEndpointAuthSigningAlgorithm *string, tosURI *string, userinfoSignedResponseAlgorithm *string, loginBindings *model.LoginBindingsInput) (*model.OAuth2Client, error)
	UpdateOAuth2Client(ctx context.Context, allowedCorsOrigins []string, audience []string, authorizationCodeGrantAccessTokenLifespan *string, authorizationCodeGrantIDTokenLifespan *string, authorizationCodeGrantRefreshTokenLifespan *string, backChannelLogoutSessionRequired *bool, backChannelLogoutURI *string, clientCredentialsGrantAccessTokenLifespan *string, clientID string, clientName *string, clientSecret *string, clientSecretExpiresAt *int64, clientURI *string, contacts []string, frontchannelLogoutSessionRequired *bool, frontchannelLogoutURI *string, grantTypes []string, implicitGrantAccessTokenLifespan *string, implicitGrantIDTokenLifespan *string, jwks map[string]interface{}, jwksURI *string, jwtBearerGrantAccessTokenLifespan *string, logoURI *string, metadata map[string]interface{}, policyURI *string, postLogoutRedirectUris []string, redirectUris []string, responseTypes []string, scope *string, sectorIdentifierURI *string, subjectType *string, tokenEndpointAuthMethod *string, tokenEndpointAuthSigningAlgorithm *string, tosURI *string, userinfoSignedResponseAlgorithm *string, loginBindings *model.LoginBindingsInput) (*model.OAuth2Client, error)
	DeleteOAuth2Client(ctx context.Context, clientID string) (*model.OAuth2Client, error)
	AcceptOAuth2ConsentRequest(ctx context.Context, challenge string, grantAccessTokenAudience []string, grantScope []string, remember *bool, rememberFor *int64) (*model.OAuth2RedirectTo, error)
	RejectOAuth2ConsentRequest(ctx context.Context, challenge string) (*model.OAuth2RedirectTo, error)
	AcceptOAuth2LoginRequest(ctx context.Context, challenge string, acr *string, amr []string, context map[string]interface{}, remember *bool, rememberFor *int64, subject string) (*model.OAuth2RedirectTo, error)
	RejectOAuth2LoginRequest(ctx context.Context, challenge string) (*model.OAuth2RedirectTo, error)
	CreateObservabilityTenant(ctx context.Context, id string, name *string, admins *model.ObservabilityTenantPermissionBindingsInput, metricsReaders *model.ObservabilityTenantPermissionBindingsInput, metricsWriters *model.ObservabilityTenantPermissionBindingsInput, metricsDeleters *model.ObservabilityTenantPermissionBindingsInput, metricsRulesReaders *model.ObservabilityTenantPermissionBindingsInput, metricsRulesWriters *model.ObservabilityTenantPermissionBindingsInput, metricsRulesDeleters *model.ObservabilityTenantPermissionBindingsInput, metricsAlertsReaders *model.ObservabilityTenantPermissionBindingsInput, metricsAlertsWriters *model.ObservabilityTenantPermissionBindingsInput, logsReaders *model.ObservabilityTenantPermissionBindingsInput, logsWriters *model.ObservabilityTenantPermissionBindingsInput, logsDeleters *model.ObservabilityTenantPermissionBindingsInput, logsRulesReaders *model.ObservabilityTenantPermissionBindingsInput, logsRulesWriters *model.ObservabilityTenantPermissionBindingsInput, logsRulesDeleters *model.ObservabilityTenantPermissionBindingsInput, tracesReaders *model.ObservabilityTenantPermissionBindingsInput, tracesWriters *model.ObservabilityTenantPermissionBindingsInput, limits *model.ObservabilityTenantLimitsInput) (*model.ObservabilityTenant, error)
	UpdateObservabilityTenant(ctx context.Context, id string, name *string, admins *model.ObservabilityTenantPermissionBindingsInput, metricsReaders *model.ObservabilityTenantPermissionBindingsInput, metricsWriters *model.ObservabilityTenantPermissionBindingsInput, metricsDeleters *model.ObservabilityTenantPermissionBindingsInput, metricsRulesReaders *model.ObservabilityTenantPermissionBindingsInput, metricsRulesWriters *model.ObservabilityTenantPermissionBindingsInput, metricsRulesDeleters *model.ObservabilityTenantPermissionBindingsInput, metricsAlertsReaders *model.ObservabilityTenantPermissionBindingsInput, metricsAlertsWriters *model.ObservabilityTenantPermissionBindingsInput, logsReaders *model.ObservabilityTenantPermissionBindingsInput, logsWriters *model.ObservabilityTenantPermissionBindingsInput, logsDeleters *model.ObservabilityTenantPermissionBindingsInput, logsRulesReaders *model.ObservabilityTenantPermissionBindingsInput, logsRulesWriters *model.ObservabilityTenantPermissionBindingsInput, logsRulesDeleters *model.ObservabilityTenantPermissionBindingsInput, tracesReaders *model.ObservabilityTenantPermissionBindingsInput, tracesWriters *model.ObservabilityTenantPermissionBindingsInput, limits *model.ObservabilityTenantLimitsInput) (*model.ObservabilityTenant, error)
	DeleteObservabilityTenant(ctx context.Context, id string) (*model.ObservabilityTenant, error)
	Organization(ctx context.Context, name string, admins []string) (*model.Organization, error)
}
type OAuth2ClientResolver interface {
	Owner(ctx context.Context, obj *model.OAuth2Client) (*string, error)

	LoginBindings(ctx context.Context, obj *model.OAuth2Client) (*model.LoginBindings, error)
}
type ObservabilityTenantResolver interface {
	Admins(ctx context.Context, obj *model.ObservabilityTenant) (*model.ObservabilityTenantPermissionBindings, error)
	MetricsReaders(ctx context.Context, obj *model.ObservabilityTenant) (*model.ObservabilityTenantPermissionBindings, error)
	MetricsWriters(ctx context.Context, obj *model.ObservabilityTenant) (*model.ObservabilityTenantPermissionBindings, error)
	MetricsDeleters(ctx context.Context, obj *model.ObservabilityTenant) (*model.ObservabilityTenantPermissionBindings, error)
	MetricsRulesReaders(ctx context.Context, obj *model.ObservabilityTenant) (*model.ObservabilityTenantPermissionBindings, error)
	MetricsRulesWriters(ctx context.Context, obj *model.ObservabilityTenant) (*model.ObservabilityTenantPermissionBindings, error)
	MetricsRulesDeleters(ctx context.Context, obj *model.ObservabilityTenant) (*model.ObservabilityTenantPermissionBindings, error)
	MetricsAlertsReaders(ctx context.Context, obj *model.ObservabilityTenant) (*model.ObservabilityTenantPermissionBindings, error)
	MetricsAlertsWriters(ctx context.Context, obj *model.ObservabilityTenant) (*model.ObservabilityTenantPermissionBindings, error)
	LogsReaders(ctx context.Context, obj *model.ObservabilityTenant) (*model.ObservabilityTenantPermissionBindings, error)
	LogsWriters(ctx context.Context, obj *model.ObservabilityTenant) (*model.ObservabilityTenantPermissionBindings, error)
	LogsDeleters(ctx context.Context, obj *model.ObservabilityTenant) (*model.ObservabilityTenantPermissionBindings, error)
	LogsRulesReaders(ctx context.Context, obj *model.ObservabilityTenant) (*model.ObservabilityTenantPermissionBindings, error)
	LogsRulesWriters(ctx context.Context, obj *model.ObservabilityTenant) (*model.ObservabilityTenantPermissionBindings, error)
	LogsRulesDeleters(ctx context.Context, obj *model.ObservabilityTenant) (*model.ObservabilityTenantPermissionBindings, error)
	TracesReaders(ctx context.Context, obj *model.ObservabilityTenant) (*model.ObservabilityTenantPermissionBindings, error)
	TracesWriters(ctx context.Context, obj *model.ObservabilityTenant) (*model.ObservabilityTenantPermissionBindings, error)
}
type ObservabilityTenantPermissionBindingsResolver interface {
	Users(ctx context.Context, obj *model.ObservabilityTenantPermissionBindings) ([]*model.User, error)
	Groups(ctx context.Context, obj *model.ObservabilityTenantPermissionBindings) ([]*model.Group, error)
	Oauth2Clients(ctx context.Context, obj *model.ObservabilityTenantPermissionBindings) ([]*model.OAuth2Client, error)
}
type OrganizationResolver interface {
	Admins(ctx context.Context, obj *model.Organization) ([]*model.User, error)
}
type QueryResolver interface {
	ListUsers(ctx context.Context) ([]*model.User, error)
	GetUser(ctx context.Context, id string) (*model.User, error)
	ListGroups(ctx context.Context) ([]*model.Group, error)
	ListOAuth2Clients(ctx context.Context) ([]*model.OAuth2Client, error)
	GetOAuth2Client(ctx context.Context, clientID string) (*model.OAuth2Client, error)
	Oauth2ConsentRequest(ctx context.Context, challenge string) (*model.OAuth2ConsentRequest, error)
	Oauth2LoginRequest(ctx context.Context, challenge string) (*model.OAuth2LoginRequest, error)
	ListObservabilityTenants(ctx context.Context) ([]*model.ObservabilityTenant, error)
	GetObservabilityTenant(ctx context.Context, id string) (*model.ObservabilityTenant, error)
	ListOrganizations(ctx context.Context) ([]*model.Organization, error)
	Organization(ctx context.Context, name string) (*model.Organization, error)
}
type UserResolver interface {
	Groups(ctx context.Context, obj *model.User) ([]*model.Group, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "ForwardingRule.ingest":
		if e.complexity.ForwardingRule.Ingest == nil {
			break
		}

		return e.complexity.ForwardingRule.Ingest(childComplexity), true

	case "Group.members":
		if e.complexity.Group.Members == nil {
			break
		}

		return e.complexity.Group.Members(childComplexity), true

	case "Group.name":
		if e.complexity.Group.Name == nil {
			break
		}

		return e.complexity.Group.Name(childComplexity), true

	case "LoginBindings.groups":
		if e.complexity.LoginBindings.Groups == nil {
			break
		}

		return e.complexity.LoginBindings.Groups(childComplexity), true

	case "LoginBindings.users":
		if e.complexity.LoginBindings.Users == nil {
			break
		}

		return e.complexity.LoginBindings.Users(childComplexity), true

	case "LokiLimits.requestRate":
		if e.complexity.LokiLimits.RequestRate == nil {
			break
		}

		return e.complexity.LokiLimits.RequestRate(childComplexity), true

	case "MimirLimits.acceptHASamples":
		if e.complexity.MimirLimits.AcceptHASamples == nil {
			break
		}

		return e.complexity.MimirLimits.AcceptHASamples(childComplexity), true

	case "MimirLimits.alertmanagerMaxAlertsCount":
		if e.complexity.MimirLimits.AlertmanagerMaxAlertsCount == nil {
			break
		}

		return e.complexity.MimirLimits.AlertmanagerMaxAlertsCount(childComplexity), true

	case "MimirLimits.alertmanagerMaxAlertsSizeBytes":
		if e.complexity.MimirLimits.AlertmanagerMaxAlertsSizeBytes == nil {
			break
		}

		return e.complexity.MimirLimits.AlertmanagerMaxAlertsSizeBytes(childComplexity), true

	case "MimirLimits.alertmanagerMaxConfigSizeBytes":
		if e.complexity.MimirLimits.AlertmanagerMaxConfigSizeBytes == nil {
			break
		}

		return e.complexity.MimirLimits.AlertmanagerMaxConfigSizeBytes(childComplexity), true

	case "MimirLimits.alertmanagerMaxDispatcherAggregationGroups":
		if e.complexity.MimirLimits.AlertmanagerMaxDispatcherAggregationGroups == nil {
			break
		}

		return e.complexity.MimirLimits.AlertmanagerMaxDispatcherAggregationGroups(childComplexity), true

	case "MimirLimits.alertmanagerMaxTemplateSizeBytes":
		if e.complexity.MimirLimits.AlertmanagerMaxTemplateSizeBytes == nil {
			break
		}

		return e.complexity.MimirLimits.AlertmanagerMaxTemplateSizeBytes(childComplexity), true

	case "MimirLimits.alertmanagerMaxTemplatesCount":
		if e.complexity.MimirLimits.AlertmanagerMaxTemplatesCount == nil {
			break
		}

		return e.complexity.MimirLimits.AlertmanagerMaxTemplatesCount(childComplexity), true

	case "MimirLimits.alertmanagerReceiversBlockCIDRNetworks":
		if e.complexity.MimirLimits.AlertmanagerReceiversBlockCIDRNetworks == nil {
			break
		}

		return e.complexity.MimirLimits.AlertmanagerReceiversBlockCIDRNetworks(childComplexity), true

	case "MimirLimits.alertmanagerReceiversBlockPrivateAddresses":
		if e.complexity.MimirLimits.AlertmanagerReceiversBlockPrivateAddresses == nil {
			break
		}

		return e.complexity.MimirLimits.AlertmanagerReceiversBlockPrivateAddresses(childComplexity), true

	case "MimirLimits.cardinalityAnalysisEnabled":
		if e.complexity.MimirLimits.CardinalityAnalysisEnabled == nil {
			break
		}

		return e.complexity.MimirLimits.CardinalityAnalysisEnabled(childComplexity), true

	case "MimirLimits.compactorBlockUploadEnabled":
		if e.complexity.MimirLimits.CompactorBlockUploadEnabled == nil {
			break
		}

		return e.complexity.MimirLimits.CompactorBlockUploadEnabled(childComplexity), true

	case "MimirLimits.compactorBlockUploadValidationEnabled":
		if e.complexity.MimirLimits.CompactorBlockUploadValidationEnabled == nil {
			break
		}

		return e.complexity.MimirLimits.CompactorBlockUploadValidationEnabled(childComplexity), true

	case "MimirLimits.compactorBlockUploadVerifyChunks":
		if e.complexity.MimirLimits.CompactorBlockUploadVerifyChunks == nil {
			break
		}

		return e.complexity.MimirLimits.CompactorBlockUploadVerifyChunks(childComplexity), true

	case "MimirLimits.compactorBlocksRetentionPeriod":
		if e.complexity.MimirLimits.CompactorBlocksRetentionPeriod == nil {
			break
		}

		return e.complexity.MimirLimits.CompactorBlocksRetentionPeriod(childComplexity), true

	case "MimirLimits.compactorPartialBlockDeletionDelay":
		if e.complexity.MimirLimits.CompactorPartialBlockDeletionDelay == nil {
			break
		}

		return e.complexity.MimirLimits.CompactorPartialBlockDeletionDelay(childComplexity), true

	case "MimirLimits.compactorSplitAndMergeShards":
		if e.complexity.MimirLimits.CompactorSplitAndMergeShards == nil {
			break
		}

		return e.complexity.MimirLimits.CompactorSplitAndMergeShards(childComplexity), true

	case "MimirLimits.compactorSplitGroups":
		if e.complexity.MimirLimits.CompactorSplitGroups == nil {
			break
		}

		return e.complexity.MimirLimits.CompactorSplitGroups(childComplexity), true

	case "MimirLimits.compactorTenantShardSize":
		if e.complexity.MimirLimits.CompactorTenantShardSize == nil {
			break
		}

		return e.complexity.MimirLimits.CompactorTenantShardSize(childComplexity), true

	case "MimirLimits.creationGracePeriod":
		if e.complexity.MimirLimits.CreationGracePeriod == nil {
			break
		}

		return e.complexity.MimirLimits.CreationGracePeriod(childComplexity), true

	case "MimirLimits.dropLabels":
		if e.complexity.MimirLimits.DropLabels == nil {
			break
		}

		return e.complexity.MimirLimits.DropLabels(childComplexity), true

	case "MimirLimits.enforceMetadataMetricName":
		if e.complexity.MimirLimits.EnforceMetadataMetricName == nil {
			break
		}

		return e.complexity.MimirLimits.EnforceMetadataMetricName(childComplexity), true

	case "MimirLimits.forwardingDropOlderThan":
		if e.complexity.MimirLimits.ForwardingDropOlderThan == nil {
			break
		}

		return e.complexity.MimirLimits.ForwardingDropOlderThan(childComplexity), true

	case "MimirLimits.forwardingEndpoint":
		if e.complexity.MimirLimits.ForwardingEndpoint == nil {
			break
		}

		return e.complexity.MimirLimits.ForwardingEndpoint(childComplexity), true

	case "MimirLimits.forwardingRules":
		if e.complexity.MimirLimits.ForwardingRules == nil {
			break
		}

		return e.complexity.MimirLimits.ForwardingRules(childComplexity), true

	case "MimirLimits.haClusterLabel":
		if e.complexity.MimirLimits.HAClusterLabel == nil {
			break
		}

		return e.complexity.MimirLimits.HAClusterLabel(childComplexity), true

	case "MimirLimits.haMaxClusters":
		if e.complexity.MimirLimits.HAMaxClusters == nil {
			break
		}

		return e.complexity.MimirLimits.HAMaxClusters(childComplexity), true

	case "MimirLimits.haReplicaLabel":
		if e.complexity.MimirLimits.HAReplicaLabel == nil {
			break
		}

		return e.complexity.MimirLimits.HAReplicaLabel(childComplexity), true

	case "MimirLimits.ingestionBurstSize":
		if e.complexity.MimirLimits.IngestionBurstSize == nil {
			break
		}

		return e.complexity.MimirLimits.IngestionBurstSize(childComplexity), true

	case "MimirLimits.ingestionRate":
		if e.complexity.MimirLimits.IngestionRate == nil {
			break
		}

		return e.complexity.MimirLimits.IngestionRate(childComplexity), true

	case "MimirLimits.ingestionTenantShardSize":
		if e.complexity.MimirLimits.IngestionTenantShardSize == nil {
			break
		}

		return e.complexity.MimirLimits.IngestionTenantShardSize(childComplexity), true

	case "MimirLimits.labelNamesAndValuesResultsMaxSizeBytes":
		if e.complexity.MimirLimits.LabelNamesAndValuesResultsMaxSizeBytes == nil {
			break
		}

		return e.complexity.MimirLimits.LabelNamesAndValuesResultsMaxSizeBytes(childComplexity), true

	case "MimirLimits.labelValuesMaxCardinalityLabelNamesPerRequest":
		if e.complexity.MimirLimits.LabelValuesMaxCardinalityLabelNamesPerRequest == nil {
			break
		}

		return e.complexity.MimirLimits.LabelValuesMaxCardinalityLabelNamesPerRequest(childComplexity), true

	case "MimirLimits.maxCacheFreshness":
		if e.complexity.MimirLimits.MaxCacheFreshness == nil {
			break
		}

		return e.complexity.MimirLimits.MaxCacheFreshness(childComplexity), true

	case "MimirLimits.maxChunksPerQuery":
		if e.complexity.MimirLimits.MaxChunksPerQuery == nil {
			break
		}

		return e.complexity.MimirLimits.MaxChunksPerQuery(childComplexity), true

	case "MimirLimits.maxFetchedChunkBytesPerQuery":
		if e.complexity.MimirLimits.MaxFetchedChunkBytesPerQuery == nil {
			break
		}

		return e.complexity.MimirLimits.MaxFetchedChunkBytesPerQuery(childComplexity), true

	case "MimirLimits.maxFetchedSeriesPerQuery":
		if e.complexity.MimirLimits.MaxFetchedSeriesPerQuery == nil {
			break
		}

		return e.complexity.MimirLimits.MaxFetchedSeriesPerQuery(childComplexity), true

	case "MimirLimits.maxGlobalExemplarsPerUser":
		if e.complexity.MimirLimits.MaxGlobalExemplarsPerUser == nil {
			break
		}

		return e.complexity.MimirLimits.MaxGlobalExemplarsPerUser(childComplexity), true

	case "MimirLimits.maxGlobalMetadataPerMetric":
		if e.complexity.MimirLimits.MaxGlobalMetadataPerMetric == nil {
			break
		}

		return e.complexity.MimirLimits.MaxGlobalMetadataPerMetric(childComplexity), true

	case "MimirLimits.maxGlobalMetricsWithMetadataPerUser":
		if e.complexity.MimirLimits.MaxGlobalMetricsWithMetadataPerUser == nil {
			break
		}

		return e.complexity.MimirLimits.MaxGlobalMetricsWithMetadataPerUser(childComplexity), true

	case "MimirLimits.maxGlobalSeriesPerMetric":
		if e.complexity.MimirLimits.MaxGlobalSeriesPerMetric == nil {
			break
		}

		return e.complexity.MimirLimits.MaxGlobalSeriesPerMetric(childComplexity), true

	case "MimirLimits.maxGlobalSeriesPerUser":
		if e.complexity.MimirLimits.MaxGlobalSeriesPerUser == nil {
			break
		}

		return e.complexity.MimirLimits.MaxGlobalSeriesPerUser(childComplexity), true

	case "MimirLimits.maxLabelNameLength":
		if e.complexity.MimirLimits.MaxLabelNameLength == nil {
			break
		}

		return e.complexity.MimirLimits.MaxLabelNameLength(childComplexity), true

	case "MimirLimits.maxLabelNamesPerSeries":
		if e.complexity.MimirLimits.MaxLabelNamesPerSeries == nil {
			break
		}

		return e.complexity.MimirLimits.MaxLabelNamesPerSeries(childComplexity), true

	case "MimirLimits.maxLabelValueLength":
		if e.complexity.MimirLimits.MaxLabelValueLength == nil {
			break
		}

		return e.complexity.MimirLimits.MaxLabelValueLength(childComplexity), true

	case "MimirLimits.maxLabelsQueryLength":
		if e.complexity.MimirLimits.MaxLabelsQueryLength == nil {
			break
		}

		return e.complexity.MimirLimits.MaxLabelsQueryLength(childComplexity), true

	case "MimirLimits.maxMetadataLength":
		if e.complexity.MimirLimits.MaxMetadataLength == nil {
			break
		}

		return e.complexity.MimirLimits.MaxMetadataLength(childComplexity), true

	case "MimirLimits.maxPartialQueryLength":
		if e.complexity.MimirLimits.MaxPartialQueryLength == nil {
			break
		}

		return e.complexity.MimirLimits.MaxPartialQueryLength(childComplexity), true

	case "MimirLimits.maxQueriersPerTenant":
		if e.complexity.MimirLimits.MaxQueriersPerTenant == nil {
			break
		}

		return e.complexity.MimirLimits.MaxQueriersPerTenant(childComplexity), true

	case "MimirLimits.maxQueryExpressionSizeBytes":
		if e.complexity.MimirLimits.MaxQueryExpressionSizeBytes == nil {
			break
		}

		return e.complexity.MimirLimits.MaxQueryExpressionSizeBytes(childComplexity), true

	case "MimirLimits.maxQueryLookback":
		if e.complexity.MimirLimits.MaxQueryLookback == nil {
			break
		}

		return e.complexity.MimirLimits.MaxQueryLookback(childComplexity), true

	case "MimirLimits.maxQueryParallelism":
		if e.complexity.MimirLimits.MaxQueryParallelism == nil {
			break
		}

		return e.complexity.MimirLimits.MaxQueryParallelism(childComplexity), true

	case "MimirLimits.maxTotalQueryLength":
		if e.complexity.MimirLimits.MaxTotalQueryLength == nil {
			break
		}

		return e.complexity.MimirLimits.MaxTotalQueryLength(childComplexity), true

	case "MimirLimits.nativeHistogramsIngestionEnabled":
		if e.complexity.MimirLimits.NativeHistogramsIngestionEnabled == nil {
			break
		}

		return e.complexity.MimirLimits.NativeHistogramsIngestionEnabled(childComplexity), true

	case "MimirLimits.notificationRateLimit":
		if e.complexity.MimirLimits.NotificationRateLimit == nil {
			break
		}

		return e.complexity.MimirLimits.NotificationRateLimit(childComplexity), true

	case "MimirLimits.notificationRateLimitPerIntegration":
		if e.complexity.MimirLimits.NotificationRateLimitPerIntegration == nil {
			break
		}

		return e.complexity.MimirLimits.NotificationRateLimitPerIntegration(childComplexity), true

	case "MimirLimits.outOfOrderBlocksExternalLabelEnabled":
		if e.complexity.MimirLimits.OutOfOrderBlocksExternalLabelEnabled == nil {
			break
		}

		return e.complexity.MimirLimits.OutOfOrderBlocksExternalLabelEnabled(childComplexity), true

	case "MimirLimits.outOfOrderTimeWindow":
		if e.complexity.MimirLimits.OutOfOrderTimeWindow == nil {
			break
		}

		return e.complexity.MimirLimits.OutOfOrderTimeWindow(childComplexity), true

	case "MimirLimits.queryShardingMaxRegexpSizeBytes":
		if e.complexity.MimirLimits.QueryShardingMaxRegexpSizeBytes == nil {
			break
		}

		return e.complexity.MimirLimits.QueryShardingMaxRegexpSizeBytes(childComplexity), true

	case "MimirLimits.queryShardingMaxShardedQueries":
		if e.complexity.MimirLimits.QueryShardingMaxShardedQueries == nil {
			break
		}

		return e.complexity.MimirLimits.QueryShardingMaxShardedQueries(childComplexity), true

	case "MimirLimits.queryShardingTotalShards":
		if e.complexity.MimirLimits.QueryShardingTotalShards == nil {
			break
		}

		return e.complexity.MimirLimits.QueryShardingTotalShards(childComplexity), true

	case "MimirLimits.requestBurstSize":
		if e.complexity.MimirLimits.RequestBurstSize == nil {
			break
		}

		return e.complexity.MimirLimits.RequestBurstSize(childComplexity), true

	case "MimirLimits.requestRate":
		if e.complexity.MimirLimits.RequestRate == nil {
			break
		}

		return e.complexity.MimirLimits.RequestRate(childComplexity), true

	case "MimirLimits.resultsCacheTTL":
		if e.complexity.MimirLimits.ResultsCacheTTL == nil {
			break
		}

		return e.complexity.MimirLimits.ResultsCacheTTL(childComplexity), true

	case "MimirLimits.resultsCacheTTLForOutOfOrderTimeWindow":
		if e.complexity.MimirLimits.ResultsCacheTTLForOutOfOrderTimeWindow == nil {
			break
		}

		return e.complexity.MimirLimits.ResultsCacheTTLForOutOfOrderTimeWindow(childComplexity), true

	case "MimirLimits.rulerAlertingRulesEvaluationEnabled":
		if e.complexity.MimirLimits.RulerAlertingRulesEvaluationEnabled == nil {
			break
		}

		return e.complexity.MimirLimits.RulerAlertingRulesEvaluationEnabled(childComplexity), true

	case "MimirLimits.rulerEvaluationDelay":
		if e.complexity.MimirLimits.RulerEvaluationDelay == nil {
			break
		}

		return e.complexity.MimirLimits.RulerEvaluationDelay(childComplexity), true

	case "MimirLimits.rulerMaxRuleGroupsPerTenant":
		if e.complexity.MimirLimits.RulerMaxRuleGroupsPerTenant == nil {
			break
		}

		return e.complexity.MimirLimits.RulerMaxRuleGroupsPerTenant(childComplexity), true

	case "MimirLimits.rulerMaxRulesPerRuleGroup":
		if e.complexity.MimirLimits.RulerMaxRulesPerRuleGroup == nil {
			break
		}

		return e.complexity.MimirLimits.RulerMaxRulesPerRuleGroup(childComplexity), true

	case "MimirLimits.rulerRecordingRulesEvaluationEnabled":
		if e.complexity.MimirLimits.RulerRecordingRulesEvaluationEnabled == nil {
			break
		}

		return e.complexity.MimirLimits.RulerRecordingRulesEvaluationEnabled(childComplexity), true

	case "MimirLimits.rulerTenantShardSize":
		if e.complexity.MimirLimits.RulerTenantShardSize == nil {
			break
		}

		return e.complexity.MimirLimits.RulerTenantShardSize(childComplexity), true

	case "MimirLimits.s3SSEKMSEncryptionContext":
		if e.complexity.MimirLimits.S3SSEKMSEncryptionContext == nil {
			break
		}

		return e.complexity.MimirLimits.S3SSEKMSEncryptionContext(childComplexity), true

	case "MimirLimits.s3SSEKMSKeyID":
		if e.complexity.MimirLimits.S3SSEKMSKeyID == nil {
			break
		}

		return e.complexity.MimirLimits.S3SSEKMSKeyID(childComplexity), true

	case "MimirLimits.s3SSEType":
		if e.complexity.MimirLimits.S3SSEType == nil {
			break
		}

		return e.complexity.MimirLimits.S3SSEType(childComplexity), true

	case "MimirLimits.separateMetricsGroupLabel":
		if e.complexity.MimirLimits.SeparateMetricsGroupLabel == nil {
			break
		}

		return e.complexity.MimirLimits.SeparateMetricsGroupLabel(childComplexity), true

	case "MimirLimits.splitInstantQueriesByInterval":
		if e.complexity.MimirLimits.SplitInstantQueriesByInterval == nil {
			break
		}

		return e.complexity.MimirLimits.SplitInstantQueriesByInterval(childComplexity), true

	case "MimirLimits.storeGatewayTenantShardSize":
		if e.complexity.MimirLimits.StoreGatewayTenantShardSize == nil {
			break
		}

		return e.complexity.MimirLimits.StoreGatewayTenantShardSize(childComplexity), true

	case "Mutation.acceptOAuth2ConsentRequest":
		if e.complexity.Mutation.AcceptOAuth2ConsentRequest == nil {
			break
		}

		args, err := ec.field_Mutation_acceptOAuth2ConsentRequest_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AcceptOAuth2ConsentRequest(childComplexity, args["challenge"].(string), args["grantAccessTokenAudience"].([]string), args["grantScope"].([]string), args["remember"].(*bool), args["rememberFor"].(*int64)), true

	case "Mutation.acceptOAuth2LoginRequest":
		if e.complexity.Mutation.AcceptOAuth2LoginRequest == nil {
			break
		}

		args, err := ec.field_Mutation_acceptOAuth2LoginRequest_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AcceptOAuth2LoginRequest(childComplexity, args["challenge"].(string), args["acr"].(*string), args["amr"].([]string), args["context"].(map[string]interface{}), args["remember"].(*bool), args["rememberFor"].(*int64), args["subject"].(string)), true

	case "Mutation.createOAuth2Client":
		if e.complexity.Mutation.CreateOAuth2Client == nil {
			break
		}

		args, err := ec.field_Mutation_createOAuth2Client_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateOAuth2Client(childComplexity, args["allowedCorsOrigins"].([]string), args["audience"].([]string), args["authorizationCodeGrantAccessTokenLifespan"].(*string), args["authorizationCodeGrantIdTokenLifespan"].(*string), args["authorizationCodeGrantRefreshTokenLifespan"].(*string), args["backChannelLogoutSessionRequired"].(*bool), args["backChannelLogoutUri"].(*string), args["clientCredentialsGrantAccessTokenLifespan"].(*string), args["clientName"].(*string), args["clientSecret"].(*string), args["ClientSecretExpiresAt"].(*int64), args["clientUri"].(*string), args["contacts"].([]string), args["frontchannelLogoutSessionRequired"].(*bool), args["frontchannelLogoutUri"].(*string), args["grantTypes"].([]string), args["implicitGrantAccessTokenLifespan"].(*string), args["implicitGrantIdTokenLifespan"].(*string), args["jwks"].(map[string]interface{}), args["jwksUri"].(*string), args["jwtBearerGrantAccessTokenLifespan"].(*string), args["logoUri"].(*string), args["metadata"].(map[string]interface{}), args["policyUri"].(*string), args["postLogoutRedirectUris"].([]string), args["redirectUris"].([]string), args["responseTypes"].([]string), args["scope"].(*string), args["sectorIdentifierUri"].(*string), args["subjectType"].(*string), args["tokenEndpointAuthMethod"].(*string), args["tokenEndpointAuthSigningAlgorithm"].(*string), args["tosUri"].(*string), args["userinfoSignedResponseAlgorithm"].(*string), args["loginBindings"].(*model.LoginBindingsInput)), true

	case "Mutation.createObservabilityTenant":
		if e.complexity.Mutation.CreateObservabilityTenant == nil {
			break
		}

		args, err := ec.field_Mutation_createObservabilityTenant_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateObservabilityTenant(childComplexity, args["id"].(string), args["name"].(*string), args["admins"].(*model.ObservabilityTenantPermissionBindingsInput), args["metricsReaders"].(*model.ObservabilityTenantPermissionBindingsInput), args["metricsWriters"].(*model.ObservabilityTenantPermissionBindingsInput), args["metricsDeleters"].(*model.ObservabilityTenantPermissionBindingsInput), args["metricsRulesReaders"].(*model.ObservabilityTenantPermissionBindingsInput), args["metricsRulesWriters"].(*model.ObservabilityTenantPermissionBindingsInput), args["metricsRulesDeleters"].(*model.ObservabilityTenantPermissionBindingsInput), args["metricsAlertsReaders"].(*model.ObservabilityTenantPermissionBindingsInput), args["metricsAlertsWriters"].(*model.ObservabilityTenantPermissionBindingsInput), args["logsReaders"].(*model.ObservabilityTenantPermissionBindingsInput), args["logsWriters"].(*model.ObservabilityTenantPermissionBindingsInput), args["logsDeleters"].(*model.ObservabilityTenantPermissionBindingsInput), args["logsRulesReaders"].(*model.ObservabilityTenantPermissionBindingsInput), args["logsRulesWriters"].(*model.ObservabilityTenantPermissionBindingsInput), args["logsRulesDeleters"].(*model.ObservabilityTenantPermissionBindingsInput), args["tracesReaders"].(*model.ObservabilityTenantPermissionBindingsInput), args["tracesWriters"].(*model.ObservabilityTenantPermissionBindingsInput), args["limits"].(*model.ObservabilityTenantLimitsInput)), true

	case "Mutation.createUser":
		if e.complexity.Mutation.CreateUser == nil {
			break
		}

		args, err := ec.field_Mutation_createUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUser(childComplexity, args["email"].(string), args["name"].(*model.NameInput)), true

	case "Mutation.deleteGroup":
		if e.complexity.Mutation.DeleteGroup == nil {
			break
		}

		args, err := ec.field_Mutation_deleteGroup_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteGroup(childComplexity, args["name"].(string)), true

	case "Mutation.deleteOAuth2Client":
		if e.complexity.Mutation.DeleteOAuth2Client == nil {
			break
		}

		args, err := ec.field_Mutation_deleteOAuth2Client_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteOAuth2Client(childComplexity, args["clientId"].(string)), true

	case "Mutation.deleteObservabilityTenant":
		if e.complexity.Mutation.DeleteObservabilityTenant == nil {
			break
		}

		args, err := ec.field_Mutation_deleteObservabilityTenant_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteObservabilityTenant(childComplexity, args["id"].(string)), true

	case "Mutation.deleteUser":
		if e.complexity.Mutation.DeleteUser == nil {
			break
		}

		args, err := ec.field_Mutation_deleteUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteUser(childComplexity, args["id"].(string)), true

	case "Mutation.group":
		if e.complexity.Mutation.Group == nil {
			break
		}

		args, err := ec.field_Mutation_group_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Group(childComplexity, args["name"].(string), args["members"].([]string)), true

	case "Mutation.organization":
		if e.complexity.Mutation.Organization == nil {
			break
		}

		args, err := ec.field_Mutation_organization_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Organization(childComplexity, args["name"].(string), args["admins"].([]string)), true

	case "Mutation.rejectOAuth2ConsentRequest":
		if e.complexity.Mutation.RejectOAuth2ConsentRequest == nil {
			break
		}

		args, err := ec.field_Mutation_rejectOAuth2ConsentRequest_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RejectOAuth2ConsentRequest(childComplexity, args["challenge"].(string)), true

	case "Mutation.rejectOAuth2LoginRequest":
		if e.complexity.Mutation.RejectOAuth2LoginRequest == nil {
			break
		}

		args, err := ec.field_Mutation_rejectOAuth2LoginRequest_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RejectOAuth2LoginRequest(childComplexity, args["challenge"].(string)), true

	case "Mutation.updateOAuth2Client":
		if e.complexity.Mutation.UpdateOAuth2Client == nil {
			break
		}

		args, err := ec.field_Mutation_updateOAuth2Client_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateOAuth2Client(childComplexity, args["allowedCorsOrigins"].([]string), args["audience"].([]string), args["authorizationCodeGrantAccessTokenLifespan"].(*string), args["authorizationCodeGrantIdTokenLifespan"].(*string), args["authorizationCodeGrantRefreshTokenLifespan"].(*string), args["backChannelLogoutSessionRequired"].(*bool), args["backChannelLogoutUri"].(*string), args["clientCredentialsGrantAccessTokenLifespan"].(*string), args["clientId"].(string), args["clientName"].(*string), args["clientSecret"].(*string), args["ClientSecretExpiresAt"].(*int64), args["clientUri"].(*string), args["contacts"].([]string), args["frontchannelLogoutSessionRequired"].(*bool), args["frontchannelLogoutUri"].(*string), args["grantTypes"].([]string), args["implicitGrantAccessTokenLifespan"].(*string), args["implicitGrantIdTokenLifespan"].(*string), args["jwks"].(map[string]interface{}), args["jwksUri"].(*string), args["jwtBearerGrantAccessTokenLifespan"].(*string), args["logoUri"].(*string), args["metadata"].(map[string]interface{}), args["policyUri"].(*string), args["postLogoutRedirectUris"].([]string), args["redirectUris"].([]string), args["responseTypes"].([]string), args["scope"].(*string), args["sectorIdentifierUri"].(*string), args["subjectType"].(*string), args["tokenEndpointAuthMethod"].(*string), args["tokenEndpointAuthSigningAlgorithm"].(*string), args["tosUri"].(*string), args["userinfoSignedResponseAlgorithm"].(*string), args["loginBindings"].(*model.LoginBindingsInput)), true

	case "Mutation.updateObservabilityTenant":
		if e.complexity.Mutation.UpdateObservabilityTenant == nil {
			break
		}

		args, err := ec.field_Mutation_updateObservabilityTenant_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateObservabilityTenant(childComplexity, args["id"].(string), args["name"].(*string), args["admins"].(*model.ObservabilityTenantPermissionBindingsInput), args["metricsReaders"].(*model.ObservabilityTenantPermissionBindingsInput), args["metricsWriters"].(*model.ObservabilityTenantPermissionBindingsInput), args["metricsDeleters"].(*model.ObservabilityTenantPermissionBindingsInput), args["metricsRulesReaders"].(*model.ObservabilityTenantPermissionBindingsInput), args["metricsRulesWriters"].(*model.ObservabilityTenantPermissionBindingsInput), args["metricsRulesDeleters"].(*model.ObservabilityTenantPermissionBindingsInput), args["metricsAlertsReaders"].(*model.ObservabilityTenantPermissionBindingsInput), args["metricsAlertsWriters"].(*model.ObservabilityTenantPermissionBindingsInput), args["logsReaders"].(*model.ObservabilityTenantPermissionBindingsInput), args["logsWriters"].(*model.ObservabilityTenantPermissionBindingsInput), args["logsDeleters"].(*model.ObservabilityTenantPermissionBindingsInput), args["logsRulesReaders"].(*model.ObservabilityTenantPermissionBindingsInput), args["logsRulesWriters"].(*model.ObservabilityTenantPermissionBindingsInput), args["logsRulesDeleters"].(*model.ObservabilityTenantPermissionBindingsInput), args["tracesReaders"].(*model.ObservabilityTenantPermissionBindingsInput), args["tracesWriters"].(*model.ObservabilityTenantPermissionBindingsInput), args["limits"].(*model.ObservabilityTenantLimitsInput)), true

	case "Name.first":
		if e.complexity.Name.First == nil {
			break
		}

		return e.complexity.Name.First(childComplexity), true

	case "Name.last":
		if e.complexity.Name.Last == nil {
			break
		}

		return e.complexity.Name.Last(childComplexity), true

	case "OAuth2Client.allowedCorsOrigins":
		if e.complexity.OAuth2Client.AllowedCorsOrigins == nil {
			break
		}

		return e.complexity.OAuth2Client.AllowedCorsOrigins(childComplexity), true

	case "OAuth2Client.audience":
		if e.complexity.OAuth2Client.Audience == nil {
			break
		}

		return e.complexity.OAuth2Client.Audience(childComplexity), true

	case "OAuth2Client.authorizationCodeGrantAccessTokenLifespan":
		if e.complexity.OAuth2Client.AuthorizationCodeGrantAccessTokenLifespan == nil {
			break
		}

		return e.complexity.OAuth2Client.AuthorizationCodeGrantAccessTokenLifespan(childComplexity), true

	case "OAuth2Client.authorizationCodeGrantIdTokenLifespan":
		if e.complexity.OAuth2Client.AuthorizationCodeGrantIDTokenLifespan == nil {
			break
		}

		return e.complexity.OAuth2Client.AuthorizationCodeGrantIDTokenLifespan(childComplexity), true

	case "OAuth2Client.authorizationCodeGrantRefreshTokenLifespan":
		if e.complexity.OAuth2Client.AuthorizationCodeGrantRefreshTokenLifespan == nil {
			break
		}

		return e.complexity.OAuth2Client.AuthorizationCodeGrantRefreshTokenLifespan(childComplexity), true

	case "OAuth2Client.backChannelLogoutSessionRequired":
		if e.complexity.OAuth2Client.BackChannelLogoutSessionRequired == nil {
			break
		}

		return e.complexity.OAuth2Client.BackChannelLogoutSessionRequired(childComplexity), true

	case "OAuth2Client.backChannelLogoutUri":
		if e.complexity.OAuth2Client.BackChannelLogoutURI == nil {
			break
		}

		return e.complexity.OAuth2Client.BackChannelLogoutURI(childComplexity), true

	case "OAuth2Client.clientCredentialsGrantAccessTokenLifespan":
		if e.complexity.OAuth2Client.ClientCredentialsGrantAccessTokenLifespan == nil {
			break
		}

		return e.complexity.OAuth2Client.ClientCredentialsGrantAccessTokenLifespan(childComplexity), true

	case "OAuth2Client.clientId":
		if e.complexity.OAuth2Client.ClientID == nil {
			break
		}

		return e.complexity.OAuth2Client.ClientID(childComplexity), true

	case "OAuth2Client.clientName":
		if e.complexity.OAuth2Client.ClientName == nil {
			break
		}

		return e.complexity.OAuth2Client.ClientName(childComplexity), true

	case "OAuth2Client.clientSecret":
		if e.complexity.OAuth2Client.ClientSecret == nil {
			break
		}

		return e.complexity.OAuth2Client.ClientSecret(childComplexity), true

	case "OAuth2Client.ClientSecretExpiresAt":
		if e.complexity.OAuth2Client.ClientSecretExpiresAt == nil {
			break
		}

		return e.complexity.OAuth2Client.ClientSecretExpiresAt(childComplexity), true

	case "OAuth2Client.clientUri":
		if e.complexity.OAuth2Client.ClientURI == nil {
			break
		}

		return e.complexity.OAuth2Client.ClientURI(childComplexity), true

	case "OAuth2Client.contacts":
		if e.complexity.OAuth2Client.Contacts == nil {
			break
		}

		return e.complexity.OAuth2Client.Contacts(childComplexity), true

	case "OAuth2Client.createdAt":
		if e.complexity.OAuth2Client.CreatedAt == nil {
			break
		}

		return e.complexity.OAuth2Client.CreatedAt(childComplexity), true

	case "OAuth2Client.frontchannelLogoutSessionRequired":
		if e.complexity.OAuth2Client.FrontchannelLogoutSessionRequired == nil {
			break
		}

		return e.complexity.OAuth2Client.FrontchannelLogoutSessionRequired(childComplexity), true

	case "OAuth2Client.frontchannelLogoutUri":
		if e.complexity.OAuth2Client.FrontchannelLogoutURI == nil {
			break
		}

		return e.complexity.OAuth2Client.FrontchannelLogoutURI(childComplexity), true

	case "OAuth2Client.grantTypes":
		if e.complexity.OAuth2Client.GrantTypes == nil {
			break
		}

		return e.complexity.OAuth2Client.GrantTypes(childComplexity), true

	case "OAuth2Client.implicitGrantAccessTokenLifespan":
		if e.complexity.OAuth2Client.ImplicitGrantAccessTokenLifespan == nil {
			break
		}

		return e.complexity.OAuth2Client.ImplicitGrantAccessTokenLifespan(childComplexity), true

	case "OAuth2Client.implicitGrantIdTokenLifespan":
		if e.complexity.OAuth2Client.ImplicitGrantIDTokenLifespan == nil {
			break
		}

		return e.complexity.OAuth2Client.ImplicitGrantIDTokenLifespan(childComplexity), true

	case "OAuth2Client.jwks":
		if e.complexity.OAuth2Client.Jwks == nil {
			break
		}

		return e.complexity.OAuth2Client.Jwks(childComplexity), true

	case "OAuth2Client.jwksUri":
		if e.complexity.OAuth2Client.JwksURI == nil {
			break
		}

		return e.complexity.OAuth2Client.JwksURI(childComplexity), true

	case "OAuth2Client.jwtBearerGrantAccessTokenLifespan":
		if e.complexity.OAuth2Client.JwtBearerGrantAccessTokenLifespan == nil {
			break
		}

		return e.complexity.OAuth2Client.JwtBearerGrantAccessTokenLifespan(childComplexity), true

	case "OAuth2Client.loginBindings":
		if e.complexity.OAuth2Client.LoginBindings == nil {
			break
		}

		return e.complexity.OAuth2Client.LoginBindings(childComplexity), true

	case "OAuth2Client.logoUri":
		if e.complexity.OAuth2Client.LogoURI == nil {
			break
		}

		return e.complexity.OAuth2Client.LogoURI(childComplexity), true

	case "OAuth2Client.metadata":
		if e.complexity.OAuth2Client.Metadata == nil {
			break
		}

		return e.complexity.OAuth2Client.Metadata(childComplexity), true

	case "OAuth2Client.owner":
		if e.complexity.OAuth2Client.Owner == nil {
			break
		}

		return e.complexity.OAuth2Client.Owner(childComplexity), true

	case "OAuth2Client.policyUri":
		if e.complexity.OAuth2Client.PolicyURI == nil {
			break
		}

		return e.complexity.OAuth2Client.PolicyURI(childComplexity), true

	case "OAuth2Client.postLogoutRedirectUris":
		if e.complexity.OAuth2Client.PostLogoutRedirectUris == nil {
			break
		}

		return e.complexity.OAuth2Client.PostLogoutRedirectUris(childComplexity), true

	case "OAuth2Client.redirectUris":
		if e.complexity.OAuth2Client.RedirectUris == nil {
			break
		}

		return e.complexity.OAuth2Client.RedirectUris(childComplexity), true

	case "OAuth2Client.responseTypes":
		if e.complexity.OAuth2Client.ResponseTypes == nil {
			break
		}

		return e.complexity.OAuth2Client.ResponseTypes(childComplexity), true

	case "OAuth2Client.scope":
		if e.complexity.OAuth2Client.Scope == nil {
			break
		}

		return e.complexity.OAuth2Client.Scope(childComplexity), true

	case "OAuth2Client.sectorIdentifierUri":
		if e.complexity.OAuth2Client.SectorIdentifierURI == nil {
			break
		}

		return e.complexity.OAuth2Client.SectorIdentifierURI(childComplexity), true

	case "OAuth2Client.subjectType":
		if e.complexity.OAuth2Client.SubjectType == nil {
			break
		}

		return e.complexity.OAuth2Client.SubjectType(childComplexity), true

	case "OAuth2Client.tokenEndpointAuthMethod":
		if e.complexity.OAuth2Client.TokenEndpointAuthMethod == nil {
			break
		}

		return e.complexity.OAuth2Client.TokenEndpointAuthMethod(childComplexity), true

	case "OAuth2Client.tokenEndpointAuthSigningAlgorithm":
		if e.complexity.OAuth2Client.TokenEndpointAuthSigningAlgorithm == nil {
			break
		}

		return e.complexity.OAuth2Client.TokenEndpointAuthSigningAlgorithm(childComplexity), true

	case "OAuth2Client.tosUri":
		if e.complexity.OAuth2Client.TosURI == nil {
			break
		}

		return e.complexity.OAuth2Client.TosURI(childComplexity), true

	case "OAuth2Client.updatedAt":
		if e.complexity.OAuth2Client.UpdatedAt == nil {
			break
		}

		return e.complexity.OAuth2Client.UpdatedAt(childComplexity), true

	case "OAuth2Client.userinfoSignedResponseAlgorithm":
		if e.complexity.OAuth2Client.UserinfoSignedResponseAlgorithm == nil {
			break
		}

		return e.complexity.OAuth2Client.UserinfoSignedResponseAlgorithm(childComplexity), true

	case "OAuth2ConsentRequest.acr":
		if e.complexity.OAuth2ConsentRequest.Acr == nil {
			break
		}

		return e.complexity.OAuth2ConsentRequest.Acr(childComplexity), true

	case "OAuth2ConsentRequest.amr":
		if e.complexity.OAuth2ConsentRequest.Amr == nil {
			break
		}

		return e.complexity.OAuth2ConsentRequest.Amr(childComplexity), true

	case "OAuth2ConsentRequest.challenge":
		if e.complexity.OAuth2ConsentRequest.Challenge == nil {
			break
		}

		return e.complexity.OAuth2ConsentRequest.Challenge(childComplexity), true

	case "OAuth2ConsentRequest.client":
		if e.complexity.OAuth2ConsentRequest.Client == nil {
			break
		}

		return e.complexity.OAuth2ConsentRequest.Client(childComplexity), true

	case "OAuth2ConsentRequest.context":
		if e.complexity.OAuth2ConsentRequest.Context == nil {
			break
		}

		return e.complexity.OAuth2ConsentRequest.Context(childComplexity), true

	case "OAuth2ConsentRequest.loginChallenge":
		if e.complexity.OAuth2ConsentRequest.LoginChallenge == nil {
			break
		}

		return e.complexity.OAuth2ConsentRequest.LoginChallenge(childComplexity), true

	case "OAuth2ConsentRequest.loginSessionId":
		if e.complexity.OAuth2ConsentRequest.LoginSessionID == nil {
			break
		}

		return e.complexity.OAuth2ConsentRequest.LoginSessionID(childComplexity), true

	case "OAuth2ConsentRequest.oidcContext":
		if e.complexity.OAuth2ConsentRequest.OidcContext == nil {
			break
		}

		return e.complexity.OAuth2ConsentRequest.OidcContext(childComplexity), true

	case "OAuth2ConsentRequest.redirectTo":
		if e.complexity.OAuth2ConsentRequest.RedirectTo == nil {
			break
		}

		return e.complexity.OAuth2ConsentRequest.RedirectTo(childComplexity), true

	case "OAuth2ConsentRequest.requestUrl":
		if e.complexity.OAuth2ConsentRequest.RequestURL == nil {
			break
		}

		return e.complexity.OAuth2ConsentRequest.RequestURL(childComplexity), true

	case "OAuth2ConsentRequest.requestedAccessTokenAudience":
		if e.complexity.OAuth2ConsentRequest.RequestedAccessTokenAudience == nil {
			break
		}

		return e.complexity.OAuth2ConsentRequest.RequestedAccessTokenAudience(childComplexity), true

	case "OAuth2ConsentRequest.requestedScope":
		if e.complexity.OAuth2ConsentRequest.RequestedScope == nil {
			break
		}

		return e.complexity.OAuth2ConsentRequest.RequestedScope(childComplexity), true

	case "OAuth2ConsentRequest.skip":
		if e.complexity.OAuth2ConsentRequest.Skip == nil {
			break
		}

		return e.complexity.OAuth2ConsentRequest.Skip(childComplexity), true

	case "OAuth2ConsentRequest.subject":
		if e.complexity.OAuth2ConsentRequest.Subject == nil {
			break
		}

		return e.complexity.OAuth2ConsentRequest.Subject(childComplexity), true

	case "OAuth2LoginRequest.challenge":
		if e.complexity.OAuth2LoginRequest.Challenge == nil {
			break
		}

		return e.complexity.OAuth2LoginRequest.Challenge(childComplexity), true

	case "OAuth2LoginRequest.client":
		if e.complexity.OAuth2LoginRequest.Client == nil {
			break
		}

		return e.complexity.OAuth2LoginRequest.Client(childComplexity), true

	case "OAuth2LoginRequest.oidcContext":
		if e.complexity.OAuth2LoginRequest.OidcContext == nil {
			break
		}

		return e.complexity.OAuth2LoginRequest.OidcContext(childComplexity), true

	case "OAuth2LoginRequest.redirectTo":
		if e.complexity.OAuth2LoginRequest.RedirectTo == nil {
			break
		}

		return e.complexity.OAuth2LoginRequest.RedirectTo(childComplexity), true

	case "OAuth2LoginRequest.requestUrl":
		if e.complexity.OAuth2LoginRequest.RequestURL == nil {
			break
		}

		return e.complexity.OAuth2LoginRequest.RequestURL(childComplexity), true

	case "OAuth2LoginRequest.requestedAccessTokenAudience":
		if e.complexity.OAuth2LoginRequest.RequestedAccessTokenAudience == nil {
			break
		}

		return e.complexity.OAuth2LoginRequest.RequestedAccessTokenAudience(childComplexity), true

	case "OAuth2LoginRequest.requestedScope":
		if e.complexity.OAuth2LoginRequest.RequestedScope == nil {
			break
		}

		return e.complexity.OAuth2LoginRequest.RequestedScope(childComplexity), true

	case "OAuth2LoginRequest.sessionId":
		if e.complexity.OAuth2LoginRequest.SessionID == nil {
			break
		}

		return e.complexity.OAuth2LoginRequest.SessionID(childComplexity), true

	case "OAuth2LoginRequest.skip":
		if e.complexity.OAuth2LoginRequest.Skip == nil {
			break
		}

		return e.complexity.OAuth2LoginRequest.Skip(childComplexity), true

	case "OAuth2LoginRequest.subject":
		if e.complexity.OAuth2LoginRequest.Subject == nil {
			break
		}

		return e.complexity.OAuth2LoginRequest.Subject(childComplexity), true

	case "OAuth2RedirectTo.redirectTo":
		if e.complexity.OAuth2RedirectTo.RedirectTo == nil {
			break
		}

		return e.complexity.OAuth2RedirectTo.RedirectTo(childComplexity), true

	case "ObservabilityTenant.admins":
		if e.complexity.ObservabilityTenant.Admins == nil {
			break
		}

		return e.complexity.ObservabilityTenant.Admins(childComplexity), true

	case "ObservabilityTenant.id":
		if e.complexity.ObservabilityTenant.ID == nil {
			break
		}

		return e.complexity.ObservabilityTenant.ID(childComplexity), true

	case "ObservabilityTenant.limits":
		if e.complexity.ObservabilityTenant.Limits == nil {
			break
		}

		return e.complexity.ObservabilityTenant.Limits(childComplexity), true

	case "ObservabilityTenant.logsDeleters":
		if e.complexity.ObservabilityTenant.LogsDeleters == nil {
			break
		}

		return e.complexity.ObservabilityTenant.LogsDeleters(childComplexity), true

	case "ObservabilityTenant.logsReaders":
		if e.complexity.ObservabilityTenant.LogsReaders == nil {
			break
		}

		return e.complexity.ObservabilityTenant.LogsReaders(childComplexity), true

	case "ObservabilityTenant.logsRulesDeleters":
		if e.complexity.ObservabilityTenant.LogsRulesDeleters == nil {
			break
		}

		return e.complexity.ObservabilityTenant.LogsRulesDeleters(childComplexity), true

	case "ObservabilityTenant.logsRulesReaders":
		if e.complexity.ObservabilityTenant.LogsRulesReaders == nil {
			break
		}

		return e.complexity.ObservabilityTenant.LogsRulesReaders(childComplexity), true

	case "ObservabilityTenant.logsRulesWriters":
		if e.complexity.ObservabilityTenant.LogsRulesWriters == nil {
			break
		}

		return e.complexity.ObservabilityTenant.LogsRulesWriters(childComplexity), true

	case "ObservabilityTenant.logsWriters":
		if e.complexity.ObservabilityTenant.LogsWriters == nil {
			break
		}

		return e.complexity.ObservabilityTenant.LogsWriters(childComplexity), true

	case "ObservabilityTenant.metricsAlertsReaders":
		if e.complexity.ObservabilityTenant.MetricsAlertsReaders == nil {
			break
		}

		return e.complexity.ObservabilityTenant.MetricsAlertsReaders(childComplexity), true

	case "ObservabilityTenant.metricsAlertsWriters":
		if e.complexity.ObservabilityTenant.MetricsAlertsWriters == nil {
			break
		}

		return e.complexity.ObservabilityTenant.MetricsAlertsWriters(childComplexity), true

	case "ObservabilityTenant.metricsDeleters":
		if e.complexity.ObservabilityTenant.MetricsDeleters == nil {
			break
		}

		return e.complexity.ObservabilityTenant.MetricsDeleters(childComplexity), true

	case "ObservabilityTenant.metricsReaders":
		if e.complexity.ObservabilityTenant.MetricsReaders == nil {
			break
		}

		return e.complexity.ObservabilityTenant.MetricsReaders(childComplexity), true

	case "ObservabilityTenant.metricsRulesDeleters":
		if e.complexity.ObservabilityTenant.MetricsRulesDeleters == nil {
			break
		}

		return e.complexity.ObservabilityTenant.MetricsRulesDeleters(childComplexity), true

	case "ObservabilityTenant.metricsRulesReaders":
		if e.complexity.ObservabilityTenant.MetricsRulesReaders == nil {
			break
		}

		return e.complexity.ObservabilityTenant.MetricsRulesReaders(childComplexity), true

	case "ObservabilityTenant.metricsRulesWriters":
		if e.complexity.ObservabilityTenant.MetricsRulesWriters == nil {
			break
		}

		return e.complexity.ObservabilityTenant.MetricsRulesWriters(childComplexity), true

	case "ObservabilityTenant.metricsWriters":
		if e.complexity.ObservabilityTenant.MetricsWriters == nil {
			break
		}

		return e.complexity.ObservabilityTenant.MetricsWriters(childComplexity), true

	case "ObservabilityTenant.name":
		if e.complexity.ObservabilityTenant.Name == nil {
			break
		}

		return e.complexity.ObservabilityTenant.Name(childComplexity), true

	case "ObservabilityTenant.tracesReaders":
		if e.complexity.ObservabilityTenant.TracesReaders == nil {
			break
		}

		return e.complexity.ObservabilityTenant.TracesReaders(childComplexity), true

	case "ObservabilityTenant.tracesWriters":
		if e.complexity.ObservabilityTenant.TracesWriters == nil {
			break
		}

		return e.complexity.ObservabilityTenant.TracesWriters(childComplexity), true

	case "ObservabilityTenantLimits.mimir":
		if e.complexity.ObservabilityTenantLimits.Mimir == nil {
			break
		}

		return e.complexity.ObservabilityTenantLimits.Mimir(childComplexity), true

	case "ObservabilityTenantPermissionBindings.groups":
		if e.complexity.ObservabilityTenantPermissionBindings.Groups == nil {
			break
		}

		return e.complexity.ObservabilityTenantPermissionBindings.Groups(childComplexity), true

	case "ObservabilityTenantPermissionBindings.oauth2Clients":
		if e.complexity.ObservabilityTenantPermissionBindings.Oauth2Clients == nil {
			break
		}

		return e.complexity.ObservabilityTenantPermissionBindings.Oauth2Clients(childComplexity), true

	case "ObservabilityTenantPermissionBindings.users":
		if e.complexity.ObservabilityTenantPermissionBindings.Users == nil {
			break
		}

		return e.complexity.ObservabilityTenantPermissionBindings.Users(childComplexity), true

	case "OidcContext.acrValues":
		if e.complexity.OidcContext.AcrValues == nil {
			break
		}

		return e.complexity.OidcContext.AcrValues(childComplexity), true

	case "OidcContext.display":
		if e.complexity.OidcContext.Display == nil {
			break
		}

		return e.complexity.OidcContext.Display(childComplexity), true

	case "OidcContext.idTokenHintClaims":
		if e.complexity.OidcContext.IDTokenHintClaims == nil {
			break
		}

		return e.complexity.OidcContext.IDTokenHintClaims(childComplexity), true

	case "OidcContext.loginHint":
		if e.complexity.OidcContext.LoginHint == nil {
			break
		}

		return e.complexity.OidcContext.LoginHint(childComplexity), true

	case "OidcContext.uiLocales":
		if e.complexity.OidcContext.UILocales == nil {
			break
		}

		return e.complexity.OidcContext.UILocales(childComplexity), true

	case "Organization.admins":
		if e.complexity.Organization.Admins == nil {
			break
		}

		return e.complexity.Organization.Admins(childComplexity), true

	case "Organization.name":
		if e.complexity.Organization.Name == nil {
			break
		}

		return e.complexity.Organization.Name(childComplexity), true

	case "Query.getOAuth2Client":
		if e.complexity.Query.GetOAuth2Client == nil {
			break
		}

		args, err := ec.field_Query_getOAuth2Client_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetOAuth2Client(childComplexity, args["clientId"].(string)), true

	case "Query.getObservabilityTenant":
		if e.complexity.Query.GetObservabilityTenant == nil {
			break
		}

		args, err := ec.field_Query_getObservabilityTenant_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetObservabilityTenant(childComplexity, args["id"].(string)), true

	case "Query.getUser":
		if e.complexity.Query.GetUser == nil {
			break
		}

		args, err := ec.field_Query_getUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetUser(childComplexity, args["id"].(string)), true

	case "Query.listGroups":
		if e.complexity.Query.ListGroups == nil {
			break
		}

		return e.complexity.Query.ListGroups(childComplexity), true

	case "Query.listOAuth2Clients":
		if e.complexity.Query.ListOAuth2Clients == nil {
			break
		}

		return e.complexity.Query.ListOAuth2Clients(childComplexity), true

	case "Query.listObservabilityTenants":
		if e.complexity.Query.ListObservabilityTenants == nil {
			break
		}

		return e.complexity.Query.ListObservabilityTenants(childComplexity), true

	case "Query.listOrganizations":
		if e.complexity.Query.ListOrganizations == nil {
			break
		}

		return e.complexity.Query.ListOrganizations(childComplexity), true

	case "Query.listUsers":
		if e.complexity.Query.ListUsers == nil {
			break
		}

		return e.complexity.Query.ListUsers(childComplexity), true

	case "Query.oauth2ConsentRequest":
		if e.complexity.Query.Oauth2ConsentRequest == nil {
			break
		}

		args, err := ec.field_Query_oauth2ConsentRequest_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Oauth2ConsentRequest(childComplexity, args["challenge"].(string)), true

	case "Query.oauth2LoginRequest":
		if e.complexity.Query.Oauth2LoginRequest == nil {
			break
		}

		args, err := ec.field_Query_oauth2LoginRequest_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Oauth2LoginRequest(childComplexity, args["challenge"].(string)), true

	case "Query.organization":
		if e.complexity.Query.Organization == nil {
			break
		}

		args, err := ec.field_Query_organization_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Organization(childComplexity, args["name"].(string)), true

	case "TempoLimits.requestRate":
		if e.complexity.TempoLimits.RequestRate == nil {
			break
		}

		return e.complexity.TempoLimits.RequestRate(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.groups":
		if e.complexity.User.Groups == nil {
			break
		}

		return e.complexity.User.Groups(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.recoveryLink":
		if e.complexity.User.RecoveryLink == nil {
			break
		}

		return e.complexity.User.RecoveryLink(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAcceptOAuth2ConsentRequestSession,
		ec.unmarshalInputAdmin,
		ec.unmarshalInputLoginBindingsInput,
		ec.unmarshalInputMimirLimitsInput,
		ec.unmarshalInputNameInput,
		ec.unmarshalInputObservabilityTenantLimitsInput,
		ec.unmarshalInputObservabilityTenantPermissionBindingsInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._queryMiddleware(ctx, rc.Operation, func(ctx context.Context) (interface{}, error) {
					return ec._Query(ctx, rc.Operation.SelectionSet), nil
				})
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._mutationMiddleware(ctx, rc.Operation, func(ctx context.Context) (interface{}, error) {
				return ec._Mutation(ctx, rc.Operation.SelectionSet), nil
			})
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../directives.graphqls", Input: `#check if the user is authenticated or not
directive @isAuthenticated on QUERY | MUTATION | FIELD | FIELD_DEFINITION

#checks user permissions using Keto
directive @checkPermissions on QUERY | MUTATION | FIELD | FIELD_DEFINITION
`, BuiltIn: false},
	{Name: "../group.graphqls", Input: `"Representation a group of users."
type Group {
  "The unique name of the group."
  name: String!

  "The users that are admins of the organization."
  members: [User!]

  # "The organization that the group belongs to."
  # organization: Organization!
}

extend type Query {
  "Get a list of all users."
  listGroups: [Group!] @checkPermissions @isAuthenticated
}

extend type Mutation {
  "Create or update a group."
  group(
    "The unique name of the group."
    name: String!

    "The IDs of the users that are members of the group."
    members: [String!]
  ): Group! @checkPermissions @isAuthenticated

  "Delete a group."
  deleteGroup(
    "The unique name of the group."
    name: String!
  ): Group! @checkPermissions @isAuthenticated
}
`, BuiltIn: false},
	{Name: "../oauth2client.graphqls", Input: `scalar Time
scalar Map

"Representation of the information about an OAuth2 Client sourced from Hydra."
type OAuth2Client {

  "OAuth 2.0 Client Allowed CORS Origins. AllowedCORSOrigins is an array of allowed CORS origins. If the array is empty, the value of the first element is considered valid."
  allowedCorsOrigins: [String!]

  "OAuth 2.0 Client Audience. Audience is an array of URLs that the OAuth 2.0 Client is allowed to request tokens for."
  audience: [String!]

  "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
  authorizationCodeGrantAccessTokenLifespan: String

  "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
  authorizationCodeGrantIdTokenLifespan: String

  "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
  authorizationCodeGrantRefreshTokenLifespan: String

  "OpenID Connect Back-Channel Logout Session Required  Boolean value specifying whether the RP requires that a sid (session ID) Claim be included in the Logout Token to identify the RP session with the OP when the backchannel_logout_uri is used. If omitted, the default value is false."
  backChannelLogoutSessionRequired: Boolean

  "OpenID Connect Back-Channel Logout URI. RP URL that will cause the RP to log itself out when sent a Logout Token by the OP."
  backChannelLogoutUri: String

  "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
  clientCredentialsGrantAccessTokenLifespan: String

  "OAuth 2.0 Client ID. The ID is autogenerated and immutable."
  clientId: String

  "OAuth 2.0 Client Name. The human-readable name of the client to be presented to the end-user during authorization."
  clientName: String

  "OAuth 2.0 Client Secret. The secret will be included in the create request as cleartext, and then never again. The secret is kept in hashed format and is not recoverable once lost."
  clientSecret: String

  "OAuth 2.0 Client Secret Expires At. The field is currently not supported and its value is always 0."
  ClientSecretExpiresAt: Int

  "OAuth 2.0 Client URI. ClientURI is a URL string of a web page providing information about the client. If present, the server SHOULD display this URL to the end-user in a clickable fashion."
  clientUri: String

  "OAuth 2.0 Client Contacts. Contacts is an array of strings representing ways to contact people responsible for this client, typically email addresses."
  contacts: [String!]

  "OAuth 2.0 Client Creation Date. CreatedAt returns the timestamp of the client's creation."
  createdAt: Time

  "OpenID Connect Front-Channel Logout Session Required. Boolean value specifying whether the RP requires that iss (issuer) and sid (session ID) query parameters be included to identify the RP session with the OP when the frontchannel_logout_uri is used. If omitted, the default value is false."
  frontchannelLogoutSessionRequired: Boolean

  "OpenID Connect Front-Channel Logout URI. RP URL that will cause the RP to log itself out when rendered in an iframe by the OP."
  frontchannelLogoutUri: String

  grantTypes: [String!]

  "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
  implicitGrantAccessTokenLifespan: String

  "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
  implicitGrantIdTokenLifespan: String

  "OAuth 2.0 Client JSON Web Key Set. Client's JSON Web Key Set [JWK] document, passed by value. The semantics of the jwks parameter are the same as the jwks_uri parameter, other than that the JWK Set is passed by value, rather than by reference. This parameter is intended only to be used by Clients that, for some reason, are unable to use the jwks_uri parameter, for instance, by native applications that might not have a location to host the contents of the JWK Set. If a Client can use jwks_uri, it MUST NOT use jwks. One significant downside of jwks is that it does not enable key rotation (which jwks_uri does, as described in Section 10 of OpenID Connect Core 1.0 [OpenID.Core]). The jwks_uri and jwks parameters MUST NOT be used together."
  jwks: Map

  "OAuth 2.0 Client JSON Web Key Set URI. Client's JSON Web Key Set [JWK] document URI, passed by reference. The semantics of the jwks_uri parameter are the same as the jwks parameter, other than that the JWK Set is passed by reference, rather than by value. The jwks_uri and jwks parameters MUST NOT be used together."
  jwksUri: String

  "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
  jwtBearerGrantAccessTokenLifespan: String

  "OAuth 2.0 Client Logo URI. A URL string referencing the client's logo."
  logoUri: String

  "OAuth 2.0 Client Metadata. Metadata is a map of key-value pairs that contain additional information about the client."
  metadata: Map

  "OAuth 2.0 Client Owner. Owner is a string identifying the owner of the OAuth 2.0 Client."
  owner: String

  "OAuth 2.0 Client Policy URI. PolicyURI is a URL string that points to a human-readable privacy policy document that describes how the deployment organization collects, uses, retains, and discloses personal data."
  policyUri: String

  "OAuth 2.0 Client Post Logout Redirect URIs. PostLogoutRedirectUris is an array of allowed URLs to which the RP is allowed to redirect the End-User's User Agent after a logout has been performed."
  postLogoutRedirectUris: [String!]

  "OAuth 2.0 Client Redirect URIs. RedirectUris is an array of allowed redirect URLs for the OAuth 2.0 Client."
  redirectUris: [String!]

  "OAuth 2.0 Client Response Types. ResponseTypes is an array of the OAuth 2.0 response type strings that the client can use at the Authorization Endpoint."
  responseTypes: [String!]

  "OAuth 2.0 Client Scope. Scope is a string containing a space-separated list of scope values (as described in Section 3.3 of OAuth 2.0 [RFC6749]) that the client can use when requesting access tokens."
  scope: String

  "OAuth 2.0 Client Sector Identifier URI. SectorIdentifierURI is a URL string using the https scheme referencing a file with a single JSON array of redirect_uri values."
  sectorIdentifierUri: String

  "OAuth 2.0 Client Subject Type. SubjectType requested for responses to this Client. The subject_types_supported Discovery parameter contains a list of the supported subject_type values for this server. Valid types include pairwise and public."
  subjectType: String

  "OAuth 2.0 Client Token Endpoint Auth Method. TokenEndpointAuthMethod is the requested Client Authentication method for the Token Endpoint. The token_endpoint_auth_methods_supported Discovery parameter contains a list of the authentication methods supported by this server. Valid types include client_secret_post, client_secret_basic, private_key_jwt, and none."
  tokenEndpointAuthMethod: String

  "OAuth 2.0 Client Token Endpoint Auth Signing Algorithm. TokenEndpointAuthSigningAlgorithm is the requested Client Authentication signing algorithm for the Token Endpoint. The token_endpoint_auth_signing_alg_values_supported Discovery parameter contains a list of the supported signing algorithms for the token endpoint."
  tokenEndpointAuthSigningAlgorithm: String

  "OAuth 2.0 Client Terms of Service URI. A URL string pointing to a human-readable terms of service document for the client that describes a contractual relationship between the end-user and the client that the end-user accepts when authorizing the client."
  tosUri: String

  "OAuth 2.0 Client Updated Date. UpdatedAt returns the timestamp of the client's last update."
  updatedAt: Time

  "OpenID Connect Userinfo Signed Response Algorithm. UserInfoSignedResponseAlg is a string containing the JWS signing algorithm (alg) parameter required for signing UserInfo Responses. The value none MAY be used, which indicates that the UserInfo Response will not be signed. The alg value RS256 MUST be used unless support for RS256 has been explicitly disabled. If support for RS256 has been disabled, the value none MUST be used."
  userinfoSignedResponseAlgorithm: String

  # "The organization that owns this OAuth2 Client."
  # organization: Organization!

  "The users and groups that are allowed to login with this OAuth2 Client."
  loginBindings: LoginBindings
}

"Representation of users and groups that are allowed to login with through OAuth2 Client."
type LoginBindings {
  "The users that are allowed to login with this OAuth2 Client."
  users: [User!]

  "The groups that are allowed to login with this OAuth2 Client."
  groups: [Group!]
}

input LoginBindingsInput {
  "The users that are allowed to login with this OAuth2 Client."
  users: [ID!]

  "The groups that are allowed to login with this OAuth2 Client."
  groups: [ID!]
}

extend type Query {
  "Get a list of all OAuth2 Clients."
  listOAuth2Clients: [OAuth2Client!]! @checkPermissions @isAuthenticated

  "Get a single OAuth2 Client by ID."
  getOAuth2Client(
    "The ID of the OAuth2 Client."
    clientId: ID!
  ): OAuth2Client @checkPermissions @isAuthenticated
}

extend type Mutation {
  "Create a new OAuth2 Client."
  createOAuth2Client(
    "OAuth 2.0 Client Allowed CORS Origins. AllowedCORSOrigins is an array of allowed CORS origins. If the array is empty, the value of the first element is considered valid."
    allowedCorsOrigins: [String!]

    "OAuth 2.0 Client Audience. Audience is an array of URLs that the OAuth 2.0 Client is allowed to request tokens for."
    audience: [String!]

    "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
    authorizationCodeGrantAccessTokenLifespan: String

    "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
    authorizationCodeGrantIdTokenLifespan: String

    "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
    authorizationCodeGrantRefreshTokenLifespan: String

    "OpenID Connect Back-Channel Logout Session Required  Boolean value specifying whether the RP requires that a sid (session ID) Claim be included in the Logout Token to identify the RP session with the OP when the backchannel_logout_uri is used. If omitted, the default value is false."
    backChannelLogoutSessionRequired: Boolean

    "OpenID Connect Back-Channel Logout URI. RP URL that will cause the RP to log itself out when sent a Logout Token by the OP."
    backChannelLogoutUri: String

    "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
    clientCredentialsGrantAccessTokenLifespan: String

    "OAuth 2.0 Client Name. The human-readable name of the client to be presented to the end-user during authorization."
    clientName: String

    "OAuth 2.0 Client Secret. The secret will be included in the create request as cleartext, and then never again. The secret is kept in hashed format and is not recoverable once lost."
    clientSecret: String

    "OAuth 2.0 Client Secret Expires At. The field is currently not supported and its value is always 0."
    ClientSecretExpiresAt: Int

    "OAuth 2.0 Client URI. ClientURI is a URL string of a web page providing information about the client. If present, the server SHOULD display this URL to the end-user in a clickable fashion."
    clientUri: String

    "OAuth 2.0 Client Contacts. Contacts is an array of strings representing ways to contact people responsible for this client, typically email addresses."
    contacts: [String!]

    "OpenID Connect Front-Channel Logout Session Required. Boolean value specifying whether the RP requires that iss (issuer) and sid (session ID) query parameters be included to identify the RP session with the OP when the frontchannel_logout_uri is used. If omitted, the default value is false."
    frontchannelLogoutSessionRequired: Boolean

    "OpenID Connect Front-Channel Logout URI. RP URL that will cause the RP to log itself out when rendered in an iframe by the OP."
    frontchannelLogoutUri: String

    grantTypes: [String!]

    "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
    implicitGrantAccessTokenLifespan: String

    "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
    implicitGrantIdTokenLifespan: String

    "OAuth 2.0 Client JSON Web Key Set. Client's JSON Web Key Set [JWK] document, passed by value. The semantics of the jwks parameter are the same as the jwks_uri parameter, other than that the JWK Set is passed by value, rather than by reference. This parameter is intended only to be used by Clients that, for some reason, are unable to use the jwks_uri parameter, for instance, by native applications that might not have a location to host the contents of the JWK Set. If a Client can use jwks_uri, it MUST NOT use jwks. One significant downside of jwks is that it does not enable key rotation (which jwks_uri does, as described in Section 10 of OpenID Connect Core 1.0 [OpenID.Core]). The jwks_uri and jwks parameters MUST NOT be used together."
    jwks: Map

    "OAuth 2.0 Client JSON Web Key Set URI. Client's JSON Web Key Set [JWK] document URI, passed by reference. The semantics of the jwks_uri parameter are the same as the jwks parameter, other than that the JWK Set is passed by reference, rather than by value. The jwks_uri and jwks parameters MUST NOT be used together."
    jwksUri: String

    "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
    jwtBearerGrantAccessTokenLifespan: String

    "OAuth 2.0 Client Logo URI. A URL string referencing the client's logo."
    logoUri: String

    "OAuth 2.0 Client Metadata. Metadata is a map of key-value pairs that contain additional information about the client."
    metadata: Map

    "OAuth 2.0 Client Policy URI. PolicyURI is a URL string that points to a human-readable privacy policy document that describes how the deployment organization collects, uses, retains, and discloses personal data."
    policyUri: String

    "OAuth 2.0 Client Post Logout Redirect URIs. PostLogoutRedirectUris is an array of allowed URLs to which the RP is allowed to redirect the End-User's User Agent after a logout has been performed."
    postLogoutRedirectUris: [String!]

    "OAuth 2.0 Client Redirect URIs. RedirectUris is an array of allowed redirect URLs for the OAuth 2.0 Client."
    redirectUris: [String!]

    "OAuth 2.0 Client Response Types. ResponseTypes is an array of the OAuth 2.0 response type strings that the client can use at the Authorization Endpoint."
    responseTypes: [String!]

    "OAuth 2.0 Client Scope. Scope is a string containing a space-separated list of scope values (as described in Section 3.3 of OAuth 2.0 [RFC6749]) that the client can use when requesting access tokens."
    scope: String

    "OAuth 2.0 Client Sector Identifier URI. SectorIdentifierURI is a URL string using the https scheme referencing a file with a single JSON array of redirect_uri values."
    sectorIdentifierUri: String

    "OAuth 2.0 Client Subject Type. SubjectType requested for responses to this Client. The subject_types_supported Discovery parameter contains a list of the supported subject_type values for this server. Valid types include pairwise and public."
    subjectType: String

    "OAuth 2.0 Client Token Endpoint Auth Method. TokenEndpointAuthMethod is the requested Client Authentication method for the Token Endpoint. The token_endpoint_auth_methods_supported Discovery parameter contains a list of the authentication methods supported by this server. Valid types include client_secret_post, client_secret_basic, private_key_jwt, and none."
    tokenEndpointAuthMethod: String

    "OAuth 2.0 Client Token Endpoint Auth Signing Algorithm. TokenEndpointAuthSigningAlgorithm is the requested Client Authentication signing algorithm for the Token Endpoint. The token_endpoint_auth_signing_alg_values_supported Discovery parameter contains a list of the supported signing algorithms for the token endpoint."
    tokenEndpointAuthSigningAlgorithm: String

    "OAuth 2.0 Client Terms of Service URI. A URL string pointing to a human-readable terms of service document for the client that describes a contractual relationship between the end-user and the client that the end-user accepts when authorizing the client."
    tosUri: String

    "OpenID Connect Userinfo Signed Response Algorithm. UserInfoSignedResponseAlg is a string containing the JWS signing algorithm (alg) parameter required for signing UserInfo Responses. The value none MAY be used, which indicates that the UserInfo Response will not be signed. The alg value RS256 MUST be used unless support for RS256 has been explicitly disabled. If support for RS256 has been disabled, the value none MUST be used."
    userinfoSignedResponseAlgorithm: String

    "The users and groups that are allowed to login with this OAuth2 Client."
    loginBindings: LoginBindingsInput
  ): OAuth2Client! @checkPermissions @isAuthenticated

  "Update an OAuth 2 Client."
  updateOAuth2Client(
    "OAuth 2.0 Client Allowed CORS Origins. AllowedCORSOrigins is an array of allowed CORS origins. If the array is empty, the value of the first element is considered valid."
    allowedCorsOrigins: [String!]

    "OAuth 2.0 Client Audience. Audience is an array of URLs that the OAuth 2.0 Client is allowed to request tokens for."
    audience: [String!]

    "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
    authorizationCodeGrantAccessTokenLifespan: String

    "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
    authorizationCodeGrantIdTokenLifespan: String

    "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
    authorizationCodeGrantRefreshTokenLifespan: String

    "OpenID Connect Back-Channel Logout Session Required  Boolean value specifying whether the RP requires that a sid (session ID) Claim be included in the Logout Token to identify the RP session with the OP when the backchannel_logout_uri is used. If omitted, the default value is false."
    backChannelLogoutSessionRequired: Boolean

    "OpenID Connect Back-Channel Logout URI. RP URL that will cause the RP to log itself out when sent a Logout Token by the OP."
    backChannelLogoutUri: String

    "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
    clientCredentialsGrantAccessTokenLifespan: String

    "OAuth 2.0 Client ID. The ID is autogenerated and immutable."
    clientId: String!

    "OAuth 2.0 Client Name. The human-readable name of the client to be presented to the end-user during authorization."
    clientName: String

    "OAuth 2.0 Client Secret. The secret will be included in the create request as cleartext, and then never again. The secret is kept in hashed format and is not recoverable once lost."
    clientSecret: String

    "OAuth 2.0 Client Secret Expires At. The field is currently not supported and its value is always 0."
    ClientSecretExpiresAt: Int

    "OAuth 2.0 Client URI. ClientURI is a URL string of a web page providing information about the client. If present, the server SHOULD display this URL to the end-user in a clickable fashion."
    clientUri: String

    "OAuth 2.0 Client Contacts. Contacts is an array of strings representing ways to contact people responsible for this client, typically email addresses."
    contacts: [String!]

    "OpenID Connect Front-Channel Logout Session Required. Boolean value specifying whether the RP requires that iss (issuer) and sid (session ID) query parameters be included to identify the RP session with the OP when the frontchannel_logout_uri is used. If omitted, the default value is false."
    frontchannelLogoutSessionRequired: Boolean

    "OpenID Connect Front-Channel Logout URI. RP URL that will cause the RP to log itself out when rendered in an iframe by the OP."
    frontchannelLogoutUri: String

    grantTypes: [String!]

    "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
    implicitGrantAccessTokenLifespan: String

    "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
    implicitGrantIdTokenLifespan: String

    "OAuth 2.0 Client JSON Web Key Set. Client's JSON Web Key Set [JWK] document, passed by value. The semantics of the jwks parameter are the same as the jwks_uri parameter, other than that the JWK Set is passed by value, rather than by reference. This parameter is intended only to be used by Clients that, for some reason, are unable to use the jwks_uri parameter, for instance, by native applications that might not have a location to host the contents of the JWK Set. If a Client can use jwks_uri, it MUST NOT use jwks. One significant downside of jwks is that it does not enable key rotation (which jwks_uri does, as described in Section 10 of OpenID Connect Core 1.0 [OpenID.Core]). The jwks_uri and jwks parameters MUST NOT be used together."
    jwks: Map

    "OAuth 2.0 Client JSON Web Key Set URI. Client's JSON Web Key Set [JWK] document URI, passed by reference. The semantics of the jwks_uri parameter are the same as the jwks parameter, other than that the JWK Set is passed by reference, rather than by value. The jwks_uri and jwks parameters MUST NOT be used together."
    jwksUri: String

    "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
    jwtBearerGrantAccessTokenLifespan: String

    "OAuth 2.0 Client Logo URI. A URL string referencing the client's logo."
    logoUri: String

    "OAuth 2.0 Client Metadata. Metadata is a map of key-value pairs that contain additional information about the client."
    metadata: Map

    "OAuth 2.0 Client Policy URI. PolicyURI is a URL string that points to a human-readable privacy policy document that describes how the deployment organization collects, uses, retains, and discloses personal data."
    policyUri: String

    "OAuth 2.0 Client Post Logout Redirect URIs. PostLogoutRedirectUris is an array of allowed URLs to which the RP is allowed to redirect the End-User's User Agent after a logout has been performed."
    postLogoutRedirectUris: [String!]

    "OAuth 2.0 Client Redirect URIs. RedirectUris is an array of allowed redirect URLs for the OAuth 2.0 Client."
    redirectUris: [String!]

    "OAuth 2.0 Client Response Types. ResponseTypes is an array of the OAuth 2.0 response type strings that the client can use at the Authorization Endpoint."
    responseTypes: [String!]

    "OAuth 2.0 Client Scope. Scope is a string containing a space-separated list of scope values (as described in Section 3.3 of OAuth 2.0 [RFC6749]) that the client can use when requesting access tokens."
    scope: String

    "OAuth 2.0 Client Sector Identifier URI. SectorIdentifierURI is a URL string using the https scheme referencing a file with a single JSON array of redirect_uri values."
    sectorIdentifierUri: String

    "OAuth 2.0 Client Subject Type. SubjectType requested for responses to this Client. The subject_types_supported Discovery parameter contains a list of the supported subject_type values for this server. Valid types include pairwise and public."
    subjectType: String

    "OAuth 2.0 Client Token Endpoint Auth Method. TokenEndpointAuthMethod is the requested Client Authentication method for the Token Endpoint. The token_endpoint_auth_methods_supported Discovery parameter contains a list of the authentication methods supported by this server. Valid types include client_secret_post, client_secret_basic, private_key_jwt, and none."
    tokenEndpointAuthMethod: String

    "OAuth 2.0 Client Token Endpoint Auth Signing Algorithm. TokenEndpointAuthSigningAlgorithm is the requested Client Authentication signing algorithm for the Token Endpoint. The token_endpoint_auth_signing_alg_values_supported Discovery parameter contains a list of the supported signing algorithms for the token endpoint."
    tokenEndpointAuthSigningAlgorithm: String

    "OAuth 2.0 Client Terms of Service URI. A URL string pointing to a human-readable terms of service document for the client that describes a contractual relationship between the end-user and the client that the end-user accepts when authorizing the client."
    tosUri: String

    "OpenID Connect Userinfo Signed Response Algorithm. UserInfoSignedResponseAlg is a string containing the JWS signing algorithm (alg) parameter required for signing UserInfo Responses. The value none MAY be used, which indicates that the UserInfo Response will not be signed. The alg value RS256 MUST be used unless support for RS256 has been explicitly disabled. If support for RS256 has been disabled, the value none MUST be used."
    userinfoSignedResponseAlgorithm: String

    "The users and groups that are allowed to login with this OAuth2 Client."
    loginBindings: LoginBindingsInput
  ): OAuth2Client! @checkPermissions @isAuthenticated

  "Delete an OAuth2 Client."
  deleteOAuth2Client(
    "OAuth 2.0 Client ID. The ID is autogenerated and immutable."
    clientId: String!
  ): OAuth2Client! @checkPermissions @isAuthenticated
}
`, BuiltIn: false},
	{Name: "../oauth2consent.graphqls", Input: `"OAuth2ConsentRequest represents an OAuth 2.0 consent request."
type OAuth2ConsentRequest {
  "ACR represents the Authentication AuthorizationContext Class Reference value for this authentication session. You can use it to express that, for example, a user authenticated using two factor authentication."
  acr: String

  "AMR represents the Authentication Methods References. It lists the method used to authenticate the end-user. For instance, if the end-user authenticated using password and OTP, the AMR value would be [\"pwd\", \"otp\"]."
  amr: [String!]

  "The challenge is a random string which is used to identify the consent request."
  challenge: String!

  "The client is the OAuth 2.0 Client requesting the OAuth 2.0 Authorization."
  client: OAuth2Client!

  "Context contains arbitrary context that is forwarded from the login request. This is useful if you want to pass data from the login request to the consent request."
  context: Map

  "LoginChallenge is the login challenge this consent challenge belongs to. It can be used to associate a login and consent request in the login & consent app."
  loginChallenge: String

  "LoginSessionID is the login session ID. If the user-agent reuses a login session (via cookie / remember flag) this ID will remain the same. If the user-agent did not have an existing authentication session (e.g. remember is false) this will be a new random value. This value is used as the \"sid\" parameter in the ID Token and in OIDC Front-/Back- channel logout. It's value can generally be used to associate consecutive login requests by a certain user."
  loginSessionId: String

  "OIDCContext contains the OIDC context of the request. If the OAuth 2.0 Authorization request was not an OpenID Connect request, this value will be nil."
  oidcContext: OidcContext

  "RequestURL is the original OAuth 2.0 Authorization URL requested by the OAuth 2.0 client. It is the URL which initiates the OAuth 2.0 Authorization Code or OAuth 2.0 Implicit flow. This URL is typically not needed, but might come in handy if you want to deal with additional request parameters."
  requestUrl: String

  "RequestedAccessTokenAudience contains the audience (client) that the OAuth 2.0 Client requested the OAuth 2.0 Access Token to be issued for."
  requestedAccessTokenAudience: [String!]

  "RequestedScope contains the OAuth 2.0 Scope requested by the OAuth 2.0 Client."
  requestedScope: [String!]

  "Skip is true when the client has requested the same scopes from the same user before. If this is true, you can skip asking the user to grant the requested scopes, or you can force showing the UI by setting this value to false."
  skip: Boolean

  "Subject is the user ID of the end-user that authenticated. This value will be set to the 'sub' claim in the ID Token."
  subject: String!

  "The URL to redirect to if an error occurred."
  redirectTo: String
}

"OIDC Context for a consent request."
type OidcContext {
  "ACRValues is the Authentication AuthorizationContext Class Reference requested in the OAuth 2.0 Authorization request. It is a parameter defined by OpenID Connect and expresses which level of authentication (e.g. 2FA) is required.  OpenID Connect defines it as follows: > Requested Authentication AuthorizationContext Class Reference values. Space-separated string that specifies the acr values that the Authorization Server is being requested to use for processing this Authentication Request, with the values appearing in order of preference. The Authentication AuthorizationContext Class satisfied by the authentication performed is returned as the acr Claim Value, as specified in Section 2. The acr Claim is requested as a Voluntary Claim by this parameter."
  acrValues: [String!]

  "Display is the display mode requested in the OAuth 2.0 Authorization request. It is a parameter defined by OpenID Connect and expresses how the Authorization Server displays authentication and consent user interfaces to the End-User.  OpenID Connect defines it as follows: > ASCII string value that specifies how the Authorization Server displays the authentication and consent user interface pages to the End-User. The defined values are: page: The Authorization Server SHOULD display the authentication and consent UI consistent with a full User Agent page view. If the display parameter is not specified, this is the default display mode. popup: The Authorization Server SHOULD display the authentication and consent UI consistent with a popup User Agent window. The popup User Agent window should be of an appropriate size for a login-focused dialog and should not obscure the entire window that it is popping up over. touch: The Authorization Server SHOULD display the authentication and consent UI consistent with a device that leverages a touch interface. > The display parameter is used only if the prompt parameter value is not none. If the prompt parameter value is none, the display parameter is ignored."
  display: String

  "IDTokenHintClaims contains the claims from the ID Token hint if it was present in the OAuth 2.0 Authorization request."
  idTokenHintClaims: Map

  "LoginHint is the login hint requested in the OAuth 2.0 Authorization request. It is a parameter defined by OpenID Connect and expresses the preferred login identifier the End-User might use to log in (if necessary).  OpenID Connect defines it as follows: > Hint to the Authorization Server about the login identifier the End-User might use to log in (if necessary). > This hint can be used by an RP if it first asks the End-User for their e-mail address (or other identifier) and then wants to pass that value as a hint to the discovered authorization service. > It is RECOMMENDED that the hint value match the value used for discovery. > This value MAY also be a phone number in the format specified for the phone_number Claim. > The use of this parameter is left to the OP's discretion."
  loginHint: String

  "UILocales is the End-User'id preferred languages and scripts for the user interface, represented as a space-separated list of BCP47 [RFC5646] language tag values, ordered by preference. For instance, the value \"fr-CA fr en\" represents a preference for French as spoken in Canada, then French (without a region designation), followed by English (without a region designation). An error SHOULD NOT result if some or all of the requested locales are not supported by the OpenID Provider."
  uiLocales: [String!]
}

type OAuth2RedirectTo {
  "RedirectTo can be used to redirect the user-agent to a specific location. This is useful if you want to redirect the user-agent to a specific location after the consent flow has been completed."
  redirectTo: String!
}

input AcceptOAuth2ConsentRequestSession {
  "AccessToken sets session data for the access and refresh token, as well as any future tokens issued by the refresh grant. Keep in mind that this data will be available to anyone performing OAuth 2.0 Challenge Introspection. If only your services can perform OAuth 2.0 Challenge Introspection, this is usually fine. But if third parties can access that endpoint as well, sensitive data from the session might be exposed to them. Use with care!"
  accessToken: Map

  "IDToken sets session data for the OpenID Connect ID token. Keep in mind that the session'id payloads are readable by anyone that has access to the ID Challenge. Use with care!"
  idToken: Map
}

extend type Query {
  "OAuth2ConsentRequest returns the OAuth 2.0 consent request information."
  oauth2ConsentRequest(
    "The challenge to fetch the consent request for."
    challenge: String!
  ): OAuth2ConsentRequest
}

extend type Mutation {
  "AcceptOAuth2ConsentRequest accepts an OAuth 2.0 consent request. If the request was granted, a code or access token will be issued. If the request was denied, the request will be rejected."
  acceptOAuth2ConsentRequest(
    "The challenge to accept."
    challenge: String!

    "The audience to grant."
    grantAccessTokenAudience: [String!]

    "The scopes to grant."
    grantScope: [String!]

    "Remember, if set to true, tells ORY Hydra to remember this consent authorization and reuse it if the same client asks the same user for the same, or a subset of, scope."
    remember: Boolean

    "RememberFor sets how long the consent authorization should be remembered for in seconds. If set to 0, the authorization will be remembered indefinitely."
    rememberFor: Int
  ): OAuth2RedirectTo!

  "RejectOAuth2ConsentRequest rejects an OAuth 2.0 consent request."
  rejectOAuth2ConsentRequest(
    "The challenge to reject."
    challenge: String!
  ): OAuth2RedirectTo!
}
`, BuiltIn: false},
	{Name: "../oauth2login.graphqls", Input: `"OAuth2LoginRequest represents an OAuth 2.0 login request."
type OAuth2LoginRequest {
  "The challenge is a random string which is used to identify the consent request."
  challenge: String!

  "The client is the OAuth 2.0 Client requesting the OAuth 2.0 Authorization."
  client: OAuth2Client!

  "OIDCContext contains the OIDC context of the request. If the OAuth 2.0 Authorization request was not an OpenID Connect request, this value will be nil."
  oidcContext: OidcContext

  "RequestURL is the original OAuth 2.0 Authorization URL requested by the OAuth 2.0 client. It is the URL which initiates the OAuth 2.0 Authorization Code or OAuth 2.0 Implicit flow. This URL is typically not needed, but might come in handy if you want to deal with additional request parameters."
  requestUrl: String

  "RequestedAccessTokenAudience contains the audience (client) that the OAuth 2.0 Client requested the OAuth 2.0 Access Token to be issued for."
  requestedAccessTokenAudience: [String!]

  "RequestedScope contains the OAuth 2.0 Scope requested by the OAuth 2.0 Client."
  requestedScope: [String!]

  "SessionID is the login session ID. If the user-agent reuses a login session (via cookie / remember flag) this ID will remain the same. If the user-agent did not have an existing authentication session (e.g. remember is false) this will be a new random value. This value is used as the 'sid' parameter in the ID Token and in OIDC Front-/Back- channel logout. It's value can generally be used to associate consecutive login requests by a certain user."
  sessionId: String

  "Skip is true when the client has requested the same scopes from the same user before. If this is true, you can skip asking the user to grant the requested scopes, or you can force showing the UI by setting this value to false."
  skip: Boolean

  "Subject is the user ID of the end-user that authenticated. This value will be set to the 'sub' claim in the ID Token."
  subject: String!

  "The URL to redirect to if an error occurred."
  redirectTo: String
}

extend type Query {
  "OAuth2LoginRequest returns the OAuth 2.0 login request information."
  oauth2LoginRequest(
    "The challenge to fetch the login request for."
    challenge: String!
  ): OAuth2LoginRequest
}

extend type Mutation {
  "AcceptOAuth2LoginRequest accepts an OAuth 2.0 login request. If the request was granted, a code or access token will be issued. If the request was denied, the request will be rejected."
  acceptOAuth2LoginRequest(
    "The challenge to accept."
    challenge: String!

    "ACR represents the Authentication AuthorizationContext Class Reference value for this authentication session. You can use it to express that, for example, a user authenticated using two factor authentication."
    acr: String

    "AMR represents the Authentication Methods References. It lists the method used to authenticate the end-user. For instance, if the end-user authenticated using password and OTP, the AMR value would be ['pwd', 'otp']."
    amr: [String!]

    "Context contains arbitrary context that is forwarded from the login request. This is useful if you want to pass data from the login request to the consent request."
    context: Map

    "Remember, if set to true, tells ORY Hydra to remember this login authorization and reuse it if the same client asks the same user for the same, or a subset of, scope."
    remember: Boolean

    "RememberFor sets how long the login authorization should be remembered for in seconds. If set to 0, the authorization will be remembered indefinitely."
    rememberFor: Int

    "Subject is the user ID of the end-user that authenticated."
    subject: String!
  ): OAuth2RedirectTo!

  "RejectOAuth2LoginRequest rejects an OAuth 2.0 login request."
  rejectOAuth2LoginRequest(
    "The challenge to reject."
    challenge: String!
  ): OAuth2RedirectTo!
}
`, BuiltIn: false},
	{Name: "../observabilitytenant.graphqls", Input: `"Representation a tenant in the Grafana observability stack where metrics, logs and traces can be sent to or retrieved from."
type ObservabilityTenant {
  "The unique id of the tenant."
  id: String!

  "The display name of the tenant."
  name: String

  # "The organization that the tenant belongs to."
  # organization: Organization!

  "The users, groups or clients that are admins of the observability tenant and can change its permissions."
  admins: ObservabilityTenantPermissionBindings

  "The users, groups or clients that can read metrics from the tenant."
  metricsReaders: ObservabilityTenantPermissionBindings

  "The users, groups or clients that can write metrics to the tenant."
  metricsWriters: ObservabilityTenantPermissionBindings

  "The users, groups or clients that can delete metrics from the tenant."
  metricsDeleters: ObservabilityTenantPermissionBindings

  "The users, groups or clients that can read metric rules from the tenant."
  metricsRulesReaders: ObservabilityTenantPermissionBindings

  "The users, groups or clients that can write metric rules to the tenant."
  metricsRulesWriters: ObservabilityTenantPermissionBindings

  "The users, groups or clients that can delete metric rules from the tenant."
  metricsRulesDeleters: ObservabilityTenantPermissionBindings

  "The users, groups or clients that can view the Alertmanager UI and get the Alertmanager configuration for a tenant."
  metricsAlertsReaders: ObservabilityTenantPermissionBindings

  "The users, groups or clients that can create silences in the Alertmanager UI and create and delete the Alertmanager configuration for a tenant."
  metricsAlertsWriters: ObservabilityTenantPermissionBindings

  "The users, groups or clients that can read logs from the tenant."
  logsReaders: ObservabilityTenantPermissionBindings

  "The users, groups or clients that can write logs to the tenant."
  logsWriters: ObservabilityTenantPermissionBindings

  "The users, groups or clients that can delete logs from the tenant."
  logsDeleters: ObservabilityTenantPermissionBindings

  "The users, groups or clients that can read log rules from the tenant."
  logsRulesReaders: ObservabilityTenantPermissionBindings

  "The users, groups or clients that can write log rules to the tenant."
  logsRulesWriters: ObservabilityTenantPermissionBindings

  "The users, groups or clients that can delete log rules from the tenant."
  logsRulesDeleters: ObservabilityTenantPermissionBindings

  "The users, groups or clients that can read traces from the tenant."
  tracesReaders: ObservabilityTenantPermissionBindings

  "The users, groups or clients that can write traces to the tenant."
  tracesWriters: ObservabilityTenantPermissionBindings

  "The limits of the tenant."
  limits: ObservabilityTenantLimits
}

"Representation of the limits of a tenant."
type ObservabilityTenantLimits {
  "The limits for Mimir for the tenant."
  mimir: MimirLimits

  # "The limits for Loki for the tenant."
  # loki: LokiLimits

  # "The limits for Tempo for the tenant."
  # tempo: TempoLimits
}

"Inputs for the limits of a tenant."
input ObservabilityTenantLimitsInput {
  "The limits for Mimir for the tenant."
  mimir: MimirLimitsInput

  # "The limits for Loki for the tenant."
  # loki: LokiLimitsInput

  # "The limits for Tempo for the tenant."
  # tempo: TempoLimitsInput
}

scalar Duration
scalar FloatMap
scalar ForwardingRuleMap

"Representation of the limits for Mimir for a tenant."
type MimirLimits {
  requestRate: Float

  requestBurstSize: Int
	
	ingestionRate: Float
	
	ingestionBurstSize: Int
	
	acceptHASamples: Boolean
	
	haClusterLabel: String
	
	haReplicaLabel: String
	
	haMaxClusters: Int
	
	dropLabels: [String]
	
	maxLabelNameLength: Int
	
	maxLabelValueLength: Int
	
	maxLabelNamesPerSeries: Int
	
	maxMetadataLength: Int
	
	creationGracePeriod: Duration
	
	enforceMetadataMetricName: Boolean
	
	ingestionTenantShardSize: Int
	
  # metricRelabelConfigs
	
	

	
	
	
	maxGlobalSeriesPerUser: Int
	
	maxGlobalSeriesPerMetric: Int
	
	
	maxGlobalMetricsWithMetadataPerUser: Int
	
	maxGlobalMetadataPerMetric: Int
	
	
	
	maxGlobalExemplarsPerUser: Int
	
	
	nativeHistogramsIngestionEnabled: Boolean
	
	# activeSeriesCustomTrackersConfig: 
	
	
	outOfOrderTimeWindow: Duration
	
	outOfOrderBlocksExternalLabelEnabled: Boolean
	

	
	
	separateMetricsGroupLabel: String

	
	
	maxChunksPerQuery: Int
	
	maxFetchedSeriesPerQuery: Int
	
	maxFetchedChunkBytesPerQuery: Int
	
	maxQueryLookback: Duration
	
	maxPartialQueryLength: Duration
	
	maxQueryParallelism: Int
	
	maxLabelsQueryLength: Duration
	
	maxCacheFreshness: Duration
	
	maxQueriersPerTenant: Int
	
	queryShardingTotalShards: Int
	
	queryShardingMaxShardedQueries: Int
	
	queryShardingMaxRegexpSizeBytes: Int
	
	splitInstantQueriesByInterval: Duration

	
	
	maxTotalQueryLength: Duration
	
	resultsCacheTTL: Duration
	
	resultsCacheTTLForOutOfOrderTimeWindow: Duration
	
	maxQueryExpressionSizeBytes: Int

	
	
	cardinalityAnalysisEnabled: Boolean
	
	labelNamesAndValuesResultsMaxSizeBytes: Int
	
	labelValuesMaxCardinalityLabelNamesPerRequest: Int

	
	
	rulerEvaluationDelay: Duration
	
	rulerTenantShardSize: Int
	
	rulerMaxRulesPerRuleGroup: Int
	
	rulerMaxRuleGroupsPerTenant: Int
	
	rulerRecordingRulesEvaluationEnabled: Boolean
	
	rulerAlertingRulesEvaluationEnabled: Boolean

	
	
	storeGatewayTenantShardSize: Int

	
	
	compactorBlocksRetentionPeriod: Duration
	
	compactorSplitAndMergeShards: Int
	
	compactorSplitGroups: Int
	
	compactorTenantShardSize: Int
	
	compactorPartialBlockDeletionDelay: Duration
	
	compactorBlockUploadEnabled: Boolean
	
	compactorBlockUploadValidationEnabled: Boolean
	
	compactorBlockUploadVerifyChunks: Boolean

	
	
	
	s3SSEType: String
	
	s3SSEKMSKeyID: String
	
	s3SSEKMSEncryptionContext: String

	
	
	
	alertmanagerReceiversBlockCIDRNetworks: String
	
	alertmanagerReceiversBlockPrivateAddresses: Boolean

	
	notificationRateLimit: Float
	
	notificationRateLimitPerIntegration: FloatMap

	
	alertmanagerMaxConfigSizeBytes: Int
	
	alertmanagerMaxTemplatesCount: Int
	
	alertmanagerMaxTemplateSizeBytes: Int
	
	alertmanagerMaxDispatcherAggregationGroups: Int
	
	alertmanagerMaxAlertsCount: Int
	
	alertmanagerMaxAlertsSizeBytes: Int

	
	forwardingEndpoint: String
	
	forwardingDropOlderThan: Duration
	
	forwardingRules: ForwardingRuleMap
}

input MimirLimitsInput {
  requestRate: Float

  requestBurstSize: Int
	
	ingestionRate: Float
	
	ingestionBurstSize: Int
	
	acceptHASamples: Boolean
	
	haClusterLabel: String
	
	haReplicaLabel: String
	
	haMaxClusters: Int
	
	dropLabels: [String]
	
	maxLabelNameLength: Int
	
	maxLabelValueLength: Int
	
	maxLabelNamesPerSeries: Int
	
	maxMetadataLength: Int
	
	creationGracePeriod: Duration
	
	enforceMetadataMetricName: Boolean
	
	ingestionTenantShardSize: Int
	
  # metricRelabelConfigs
	
	

	
	
	
	maxGlobalSeriesPerUser: Int
	
	maxGlobalSeriesPerMetric: Int
	
	
	maxGlobalMetricsWithMetadataPerUser: Int
	
	maxGlobalMetadataPerMetric: Int
	
	
	
	maxGlobalExemplarsPerUser: Int
	
	
	nativeHistogramsIngestionEnabled: Boolean
	
	# activeSeriesCustomTrackersConfig: 
	
	
	outOfOrderTimeWindow: Duration
	
	outOfOrderBlocksExternalLabelEnabled: Boolean
	

	
	
	separateMetricsGroupLabel: String

	
	
	maxChunksPerQuery: Int
	
	maxFetchedSeriesPerQuery: Int
	
	maxFetchedChunkBytesPerQuery: Int
	
	maxQueryLookback: Duration
	
	maxPartialQueryLength: Duration
	
	maxQueryParallelism: Int
	
	maxLabelsQueryLength: Duration
	
	maxCacheFreshness: Duration
	
	maxQueriersPerTenant: Int
	
	queryShardingTotalShards: Int
	
	queryShardingMaxShardedQueries: Int
	
	queryShardingMaxRegexpSizeBytes: Int
	
	splitInstantQueriesByInterval: Duration

	
	
	maxTotalQueryLength: Duration
	
	resultsCacheTTL: Duration
	
	resultsCacheTTLForOutOfOrderTimeWindow: Duration
	
	maxQueryExpressionSizeBytes: Int

	
	
	cardinalityAnalysisEnabled: Boolean
	
	labelNamesAndValuesResultsMaxSizeBytes: Int
	
	labelValuesMaxCardinalityLabelNamesPerRequest: Int

	
	
	rulerEvaluationDelay: Duration
	
	rulerTenantShardSize: Int
	
	rulerMaxRulesPerRuleGroup: Int
	
	rulerMaxRuleGroupsPerTenant: Int
	
	rulerRecordingRulesEvaluationEnabled: Boolean
	
	rulerAlertingRulesEvaluationEnabled: Boolean

	
	
	storeGatewayTenantShardSize: Int

	
	
	compactorBlocksRetentionPeriod: Duration
	
	compactorSplitAndMergeShards: Int
	
	compactorSplitGroups: Int
	
	compactorTenantShardSize: Int
	
	compactorPartialBlockDeletionDelay: Duration
	
	compactorBlockUploadEnabled: Boolean
	
	compactorBlockUploadValidationEnabled: Boolean
	
	compactorBlockUploadVerifyChunks: Boolean

	
	
	
	s3SSEType: String
	
	s3SSEKMSKeyID: String
	
	s3SSEKMSEncryptionContext: String

	
	
	
	alertmanagerReceiversBlockCIDRNetworks: String
	
	alertmanagerReceiversBlockPrivateAddresses: Boolean

	
	notificationRateLimit: Float
	
	notificationRateLimitPerIntegration: FloatMap

	
	alertmanagerMaxConfigSizeBytes: Int
	
	alertmanagerMaxTemplatesCount: Int
	
	alertmanagerMaxTemplateSizeBytes: Int
	
	alertmanagerMaxDispatcherAggregationGroups: Int
	
	alertmanagerMaxAlertsCount: Int
	
	alertmanagerMaxAlertsSizeBytes: Int

	
	forwardingEndpoint: String
	
	forwardingDropOlderThan: Duration
	
	forwardingRules: ForwardingRuleMap
}

type ForwardingRule {
  "Ingest defines whether a metric should still be pushed to the Ingesters despite it being forwarded."
	ingest: Boolean
}

"Representation of the limits for Loki for a tenant."
type LokiLimits {
  requestRate: Float
}

"Representation of the limits for Tempo for a tenant."
type TempoLimits {
  requestRate: Float
}

"Representation of the users, groups and oauth2 clients that have a set of permissions on a tenant."
type ObservabilityTenantPermissionBindings {
  "The users that have a particular permission on a tenant."
  users: [User!]

  "The groups have a particular permission on a tenant."
  groups: [Group!]

  "The oauth2 clients  have a particular permission on a tenant."
  oauth2Clients: [OAuth2Client!] # TODO: add check so that an oauth2 client can only be added to a single tenant
}

input ObservabilityTenantPermissionBindingsInput {
  "The IDs of users that can view a tenant."
  users: [String!]

  "The names of groups that can view a tenant."
  groups: [String!]

  "The clientIDs oauth2 clients that can send data a tenant."
  oauth2Clients: [String!]
}

extend type Query {
  "Get a list of all users."
  listObservabilityTenants: [ObservabilityTenant!]! @checkPermissions @isAuthenticated

  getObservabilityTenant(
    "The unique ID of the tenant."
    id: String!
  ): ObservabilityTenant! @checkPermissions @isAuthenticated
}

extend type Mutation {
  "Create an observability tenant."
  createObservabilityTenant(
    "The unique ID of the tenant."
    id: String!
    "The display name of the tenant."
    name: String
    "The users, groups or clients that are admins of the observability tenant and can change its permissions."
    admins: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can read metrics from the tenant."
    metricsReaders: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can write metrics to the tenant."
    metricsWriters: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can delete metrics from the tenant."
    metricsDeleters: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can read metric rules from the tenant."
    metricsRulesReaders: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can write metric rules to the tenant."
    metricsRulesWriters: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can delete metric rules from the tenant."
    metricsRulesDeleters: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can view the Alertmanager UI and get the Alertmanager configuration for a tenant."
    metricsAlertsReaders: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can create silences in the Alertmanager UI and create and delete the Alertmanager configuration for a tenant."
    metricsAlertsWriters: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can read logs from the tenant."
    logsReaders: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can write logs to the tenant."
    logsWriters: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can delete logs from the tenant."
    logsDeleters: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can read log rules from the tenant."
    logsRulesReaders: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can write log rules to the tenant."
    logsRulesWriters: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can delete log rules from the tenant."
    logsRulesDeleters: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can read traces from the tenant."
    tracesReaders: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can write traces to the tenant."
    tracesWriters: ObservabilityTenantPermissionBindingsInput
    "The limits for the tenant."
    limits: ObservabilityTenantLimitsInput
  ): ObservabilityTenant! @checkPermissions @isAuthenticated

  "Update an observability tenant."
  updateObservabilityTenant(
    "The unique ID of the tenant."
    id: String!
    "The display name of the tenant."
    name: String
    "The users, groups or clients that are admins of the observability tenant and can change its permissions."
    admins: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can read metrics from the tenant."
    metricsReaders: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can write metrics to the tenant."
    metricsWriters: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can delete metrics from the tenant."
    metricsDeleters: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can read metric rules from the tenant."
    metricsRulesReaders: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can write metric rules to the tenant."
    metricsRulesWriters: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can delete metric rules from the tenant."
    metricsRulesDeleters: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can view the Alertmanager UI and get the Alertmanager configuration for a tenant."
    metricsAlertsReaders: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can create silences in the Alertmanager UI and create and delete the Alertmanager configuration for a tenant."
    metricsAlertsWriters: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can read logs from the tenant."
    logsReaders: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can write logs to the tenant."
    logsWriters: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can delete logs from the tenant."
    logsDeleters: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can read log rules from the tenant."
    logsRulesReaders: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can write log rules to the tenant."
    logsRulesWriters: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can delete log rules from the tenant."
    logsRulesDeleters: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can read traces from the tenant."
    tracesReaders: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can write traces to the tenant."
    tracesWriters: ObservabilityTenantPermissionBindingsInput
    "The limits for the tenant."
    limits: ObservabilityTenantLimitsInput
  ): ObservabilityTenant! @checkPermissions @isAuthenticated

  "Delete an observability tenant."
  deleteObservabilityTenant(
    "The unique ID of the tenant."
    id: String!
  ): ObservabilityTenant! @checkPermissions @isAuthenticated
}
`, BuiltIn: false},
	{Name: "../organization.graphqls", Input: `"Representation an Organization in the auth stack."
type Organization {
  "The unique name of the organization."
  name: String!

  "The users that are admins of the organization."
  admins: [User!]
}

"Input for adding a user to an organization as an administrator."
input Admin {
  "The ID of the user to add as an admin."
  id: ID!
}

extend type Query {
  "Get a list of all users."
  listOrganizations: [Organization!]! @checkPermissions @isAuthenticated

  "Get a single organization by name."
  organization(
    "The name of the organization."
    name: String!
  ): Organization! @checkPermissions @isAuthenticated
}

extend type Mutation {
  "Create a new organization."
  organization(
    "The name of the organization."
    name: String!,

    "The IDs of the users that are organization admins."
    admins: [String!]!
    ): Organization! @checkPermissions @isAuthenticated
}
`, BuiltIn: false},
	{Name: "../user.graphqls", Input: `"Representation of the information about a user sourced from Kratos."
type User {
  "The unique ID of the user."
  id: ID!

  "The user's full name."
  name: Name

  "The user's email address."
  email: String!

  "The groups the user belongs to."
  groups: [Group!]

  # "The organization the user belongs to."
  # organization: Organization!

  "The link a user can use to recover their account."
  recoveryLink: String
}

"The first and last name of a user."
type Name {
  "The user's first name."
  first: String

  "The user's last name."
  last: String
}

input NameInput {
  "The user's first name."
  first: String

  "The user's last name."
  last: String
}

type Query {
  "Get a list of all users."
  listUsers: [User!]! @checkPermissions @isAuthenticated

  "Get a user by ID."
  getUser(id: ID!): User! @checkPermissions @isAuthenticated
}

type Mutation {
  "Create a new user."
  createUser(
    "The user's email address."
    email: String!
  
    "The user's name."
    name: NameInput

  ): User! @checkPermissions @isAuthenticated

  "Delete a user."
  deleteUser(
    "The ID of the user to delete."
    id: ID!
  ): User! @checkPermissions @isAuthenticated
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_acceptOAuth2ConsentRequest_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["challenge"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("challenge"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["challenge"] = arg0
	var arg1 []string
	if tmp, ok := rawArgs["grantAccessTokenAudience"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("grantAccessTokenAudience"))
		arg1, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["grantAccessTokenAudience"] = arg1
	var arg2 []string
	if tmp, ok := rawArgs["grantScope"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("grantScope"))
		arg2, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["grantScope"] = arg2
	var arg3 *bool
	if tmp, ok := rawArgs["remember"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remember"))
		arg3, err = ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["remember"] = arg3
	var arg4 *int64
	if tmp, ok := rawArgs["rememberFor"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rememberFor"))
		arg4, err = ec.unmarshalOInt2ᚖint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["rememberFor"] = arg4
	return args, nil
}

func (ec *executionContext) field_Mutation_acceptOAuth2LoginRequest_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["challenge"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("challenge"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["challenge"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["acr"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("acr"))
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["acr"] = arg1
	var arg2 []string
	if tmp, ok := rawArgs["amr"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amr"))
		arg2, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["amr"] = arg2
	var arg3 map[string]interface{}
	if tmp, ok := rawArgs["context"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("context"))
		arg3, err = ec.unmarshalOMap2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["context"] = arg3
	var arg4 *bool
	if tmp, ok := rawArgs["remember"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remember"))
		arg4, err = ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["remember"] = arg4
	var arg5 *int64
	if tmp, ok := rawArgs["rememberFor"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rememberFor"))
		arg5, err = ec.unmarshalOInt2ᚖint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["rememberFor"] = arg5
	var arg6 string
	if tmp, ok := rawArgs["subject"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subject"))
		arg6, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["subject"] = arg6
	return args, nil
}

func (ec *executionContext) field_Mutation_createOAuth2Client_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["allowedCorsOrigins"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("allowedCorsOrigins"))
		arg0, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["allowedCorsOrigins"] = arg0
	var arg1 []string
	if tmp, ok := rawArgs["audience"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("audience"))
		arg1, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["audience"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["authorizationCodeGrantAccessTokenLifespan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizationCodeGrantAccessTokenLifespan"))
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authorizationCodeGrantAccessTokenLifespan"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["authorizationCodeGrantIdTokenLifespan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizationCodeGrantIdTokenLifespan"))
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authorizationCodeGrantIdTokenLifespan"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["authorizationCodeGrantRefreshTokenLifespan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizationCodeGrantRefreshTokenLifespan"))
		arg4, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authorizationCodeGrantRefreshTokenLifespan"] = arg4
	var arg5 *bool
	if tmp, ok := rawArgs["backChannelLogoutSessionRequired"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backChannelLogoutSessionRequired"))
		arg5, err = ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["backChannelLogoutSessionRequired"] = arg5
	var arg6 *string
	if tmp, ok := rawArgs["backChannelLogoutUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backChannelLogoutUri"))
		arg6, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["backChannelLogoutUri"] = arg6
	var arg7 *string
	if tmp, ok := rawArgs["clientCredentialsGrantAccessTokenLifespan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientCredentialsGrantAccessTokenLifespan"))
		arg7, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clientCredentialsGrantAccessTokenLifespan"] = arg7
	var arg8 *string
	if tmp, ok := rawArgs["clientName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientName"))
		arg8, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clientName"] = arg8
	var arg9 *string
	if tmp, ok := rawArgs["clientSecret"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientSecret"))
		arg9, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clientSecret"] = arg9
	var arg10 *int64
	if tmp, ok := rawArgs["ClientSecretExpiresAt"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ClientSecretExpiresAt"))
		arg10, err = ec.unmarshalOInt2ᚖint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["ClientSecretExpiresAt"] = arg10
	var arg11 *string
	if tmp, ok := rawArgs["clientUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientUri"))
		arg11, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clientUri"] = arg11
	var arg12 []string
	if tmp, ok := rawArgs["contacts"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contacts"))
		arg12, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["contacts"] = arg12
	var arg13 *bool
	if tmp, ok := rawArgs["frontchannelLogoutSessionRequired"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("frontchannelLogoutSessionRequired"))
		arg13, err = ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["frontchannelLogoutSessionRequired"] = arg13
	var arg14 *string
	if tmp, ok := rawArgs["frontchannelLogoutUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("frontchannelLogoutUri"))
		arg14, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["frontchannelLogoutUri"] = arg14
	var arg15 []string
	if tmp, ok := rawArgs["grantTypes"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("grantTypes"))
		arg15, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["grantTypes"] = arg15
	var arg16 *string
	if tmp, ok := rawArgs["implicitGrantAccessTokenLifespan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("implicitGrantAccessTokenLifespan"))
		arg16, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["implicitGrantAccessTokenLifespan"] = arg16
	var arg17 *string
	if tmp, ok := rawArgs["implicitGrantIdTokenLifespan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("implicitGrantIdTokenLifespan"))
		arg17, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["implicitGrantIdTokenLifespan"] = arg17
	var arg18 map[string]interface{}
	if tmp, ok := rawArgs["jwks"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jwks"))
		arg18, err = ec.unmarshalOMap2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["jwks"] = arg18
	var arg19 *string
	if tmp, ok := rawArgs["jwksUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jwksUri"))
		arg19, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["jwksUri"] = arg19
	var arg20 *string
	if tmp, ok := rawArgs["jwtBearerGrantAccessTokenLifespan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jwtBearerGrantAccessTokenLifespan"))
		arg20, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["jwtBearerGrantAccessTokenLifespan"] = arg20
	var arg21 *string
	if tmp, ok := rawArgs["logoUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logoUri"))
		arg21, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["logoUri"] = arg21
	var arg22 map[string]interface{}
	if tmp, ok := rawArgs["metadata"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metadata"))
		arg22, err = ec.unmarshalOMap2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["metadata"] = arg22
	var arg23 *string
	if tmp, ok := rawArgs["policyUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("policyUri"))
		arg23, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["policyUri"] = arg23
	var arg24 []string
	if tmp, ok := rawArgs["postLogoutRedirectUris"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("postLogoutRedirectUris"))
		arg24, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["postLogoutRedirectUris"] = arg24
	var arg25 []string
	if tmp, ok := rawArgs["redirectUris"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("redirectUris"))
		arg25, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["redirectUris"] = arg25
	var arg26 []string
	if tmp, ok := rawArgs["responseTypes"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("responseTypes"))
		arg26, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["responseTypes"] = arg26
	var arg27 *string
	if tmp, ok := rawArgs["scope"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scope"))
		arg27, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["scope"] = arg27
	var arg28 *string
	if tmp, ok := rawArgs["sectorIdentifierUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sectorIdentifierUri"))
		arg28, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sectorIdentifierUri"] = arg28
	var arg29 *string
	if tmp, ok := rawArgs["subjectType"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subjectType"))
		arg29, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["subjectType"] = arg29
	var arg30 *string
	if tmp, ok := rawArgs["tokenEndpointAuthMethod"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenEndpointAuthMethod"))
		arg30, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tokenEndpointAuthMethod"] = arg30
	var arg31 *string
	if tmp, ok := rawArgs["tokenEndpointAuthSigningAlgorithm"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenEndpointAuthSigningAlgorithm"))
		arg31, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tokenEndpointAuthSigningAlgorithm"] = arg31
	var arg32 *string
	if tmp, ok := rawArgs["tosUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tosUri"))
		arg32, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tosUri"] = arg32
	var arg33 *string
	if tmp, ok := rawArgs["userinfoSignedResponseAlgorithm"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userinfoSignedResponseAlgorithm"))
		arg33, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userinfoSignedResponseAlgorithm"] = arg33
	var arg34 *model.LoginBindingsInput
	if tmp, ok := rawArgs["loginBindings"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("loginBindings"))
		arg34, err = ec.unmarshalOLoginBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐLoginBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["loginBindings"] = arg34
	return args, nil
}

func (ec *executionContext) field_Mutation_createObservabilityTenant_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg1
	var arg2 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["admins"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("admins"))
		arg2, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["admins"] = arg2
	var arg3 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["metricsReaders"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsReaders"))
		arg3, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["metricsReaders"] = arg3
	var arg4 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["metricsWriters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsWriters"))
		arg4, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["metricsWriters"] = arg4
	var arg5 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["metricsDeleters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsDeleters"))
		arg5, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["metricsDeleters"] = arg5
	var arg6 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["metricsRulesReaders"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsRulesReaders"))
		arg6, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["metricsRulesReaders"] = arg6
	var arg7 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["metricsRulesWriters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsRulesWriters"))
		arg7, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["metricsRulesWriters"] = arg7
	var arg8 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["metricsRulesDeleters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsRulesDeleters"))
		arg8, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["metricsRulesDeleters"] = arg8
	var arg9 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["metricsAlertsReaders"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsAlertsReaders"))
		arg9, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["metricsAlertsReaders"] = arg9
	var arg10 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["metricsAlertsWriters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsAlertsWriters"))
		arg10, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["metricsAlertsWriters"] = arg10
	var arg11 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["logsReaders"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logsReaders"))
		arg11, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["logsReaders"] = arg11
	var arg12 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["logsWriters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logsWriters"))
		arg12, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["logsWriters"] = arg12
	var arg13 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["logsDeleters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logsDeleters"))
		arg13, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["logsDeleters"] = arg13
	var arg14 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["logsRulesReaders"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logsRulesReaders"))
		arg14, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["logsRulesReaders"] = arg14
	var arg15 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["logsRulesWriters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logsRulesWriters"))
		arg15, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["logsRulesWriters"] = arg15
	var arg16 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["logsRulesDeleters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logsRulesDeleters"))
		arg16, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["logsRulesDeleters"] = arg16
	var arg17 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["tracesReaders"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tracesReaders"))
		arg17, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tracesReaders"] = arg17
	var arg18 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["tracesWriters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tracesWriters"))
		arg18, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tracesWriters"] = arg18
	var arg19 *model.ObservabilityTenantLimitsInput
	if tmp, ok := rawArgs["limits"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limits"))
		arg19, err = ec.unmarshalOObservabilityTenantLimitsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantLimitsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limits"] = arg19
	return args, nil
}

func (ec *executionContext) field_Mutation_createUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["email"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["email"] = arg0
	var arg1 *model.NameInput
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg1, err = ec.unmarshalONameInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐNameInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteGroup_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteOAuth2Client_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["clientId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clientId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteObservabilityTenant_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_group_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 []string
	if tmp, ok := rawArgs["members"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("members"))
		arg1, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["members"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_organization_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 []string
	if tmp, ok := rawArgs["admins"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("admins"))
		arg1, err = ec.unmarshalNString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["admins"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_rejectOAuth2ConsentRequest_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["challenge"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("challenge"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["challenge"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_rejectOAuth2LoginRequest_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["challenge"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("challenge"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["challenge"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateOAuth2Client_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["allowedCorsOrigins"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("allowedCorsOrigins"))
		arg0, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["allowedCorsOrigins"] = arg0
	var arg1 []string
	if tmp, ok := rawArgs["audience"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("audience"))
		arg1, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["audience"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["authorizationCodeGrantAccessTokenLifespan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizationCodeGrantAccessTokenLifespan"))
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authorizationCodeGrantAccessTokenLifespan"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["authorizationCodeGrantIdTokenLifespan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizationCodeGrantIdTokenLifespan"))
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authorizationCodeGrantIdTokenLifespan"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["authorizationCodeGrantRefreshTokenLifespan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizationCodeGrantRefreshTokenLifespan"))
		arg4, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authorizationCodeGrantRefreshTokenLifespan"] = arg4
	var arg5 *bool
	if tmp, ok := rawArgs["backChannelLogoutSessionRequired"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backChannelLogoutSessionRequired"))
		arg5, err = ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["backChannelLogoutSessionRequired"] = arg5
	var arg6 *string
	if tmp, ok := rawArgs["backChannelLogoutUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backChannelLogoutUri"))
		arg6, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["backChannelLogoutUri"] = arg6
	var arg7 *string
	if tmp, ok := rawArgs["clientCredentialsGrantAccessTokenLifespan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientCredentialsGrantAccessTokenLifespan"))
		arg7, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clientCredentialsGrantAccessTokenLifespan"] = arg7
	var arg8 string
	if tmp, ok := rawArgs["clientId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientId"))
		arg8, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clientId"] = arg8
	var arg9 *string
	if tmp, ok := rawArgs["clientName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientName"))
		arg9, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clientName"] = arg9
	var arg10 *string
	if tmp, ok := rawArgs["clientSecret"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientSecret"))
		arg10, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clientSecret"] = arg10
	var arg11 *int64
	if tmp, ok := rawArgs["ClientSecretExpiresAt"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ClientSecretExpiresAt"))
		arg11, err = ec.unmarshalOInt2ᚖint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["ClientSecretExpiresAt"] = arg11
	var arg12 *string
	if tmp, ok := rawArgs["clientUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientUri"))
		arg12, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clientUri"] = arg12
	var arg13 []string
	if tmp, ok := rawArgs["contacts"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contacts"))
		arg13, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["contacts"] = arg13
	var arg14 *bool
	if tmp, ok := rawArgs["frontchannelLogoutSessionRequired"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("frontchannelLogoutSessionRequired"))
		arg14, err = ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["frontchannelLogoutSessionRequired"] = arg14
	var arg15 *string
	if tmp, ok := rawArgs["frontchannelLogoutUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("frontchannelLogoutUri"))
		arg15, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["frontchannelLogoutUri"] = arg15
	var arg16 []string
	if tmp, ok := rawArgs["grantTypes"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("grantTypes"))
		arg16, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["grantTypes"] = arg16
	var arg17 *string
	if tmp, ok := rawArgs["implicitGrantAccessTokenLifespan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("implicitGrantAccessTokenLifespan"))
		arg17, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["implicitGrantAccessTokenLifespan"] = arg17
	var arg18 *string
	if tmp, ok := rawArgs["implicitGrantIdTokenLifespan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("implicitGrantIdTokenLifespan"))
		arg18, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["implicitGrantIdTokenLifespan"] = arg18
	var arg19 map[string]interface{}
	if tmp, ok := rawArgs["jwks"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jwks"))
		arg19, err = ec.unmarshalOMap2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["jwks"] = arg19
	var arg20 *string
	if tmp, ok := rawArgs["jwksUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jwksUri"))
		arg20, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["jwksUri"] = arg20
	var arg21 *string
	if tmp, ok := rawArgs["jwtBearerGrantAccessTokenLifespan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jwtBearerGrantAccessTokenLifespan"))
		arg21, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["jwtBearerGrantAccessTokenLifespan"] = arg21
	var arg22 *string
	if tmp, ok := rawArgs["logoUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logoUri"))
		arg22, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["logoUri"] = arg22
	var arg23 map[string]interface{}
	if tmp, ok := rawArgs["metadata"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metadata"))
		arg23, err = ec.unmarshalOMap2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["metadata"] = arg23
	var arg24 *string
	if tmp, ok := rawArgs["policyUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("policyUri"))
		arg24, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["policyUri"] = arg24
	var arg25 []string
	if tmp, ok := rawArgs["postLogoutRedirectUris"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("postLogoutRedirectUris"))
		arg25, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["postLogoutRedirectUris"] = arg25
	var arg26 []string
	if tmp, ok := rawArgs["redirectUris"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("redirectUris"))
		arg26, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["redirectUris"] = arg26
	var arg27 []string
	if tmp, ok := rawArgs["responseTypes"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("responseTypes"))
		arg27, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["responseTypes"] = arg27
	var arg28 *string
	if tmp, ok := rawArgs["scope"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scope"))
		arg28, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["scope"] = arg28
	var arg29 *string
	if tmp, ok := rawArgs["sectorIdentifierUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sectorIdentifierUri"))
		arg29, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sectorIdentifierUri"] = arg29
	var arg30 *string
	if tmp, ok := rawArgs["subjectType"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subjectType"))
		arg30, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["subjectType"] = arg30
	var arg31 *string
	if tmp, ok := rawArgs["tokenEndpointAuthMethod"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenEndpointAuthMethod"))
		arg31, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tokenEndpointAuthMethod"] = arg31
	var arg32 *string
	if tmp, ok := rawArgs["tokenEndpointAuthSigningAlgorithm"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenEndpointAuthSigningAlgorithm"))
		arg32, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tokenEndpointAuthSigningAlgorithm"] = arg32
	var arg33 *string
	if tmp, ok := rawArgs["tosUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tosUri"))
		arg33, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tosUri"] = arg33
	var arg34 *string
	if tmp, ok := rawArgs["userinfoSignedResponseAlgorithm"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userinfoSignedResponseAlgorithm"))
		arg34, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userinfoSignedResponseAlgorithm"] = arg34
	var arg35 *model.LoginBindingsInput
	if tmp, ok := rawArgs["loginBindings"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("loginBindings"))
		arg35, err = ec.unmarshalOLoginBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐLoginBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["loginBindings"] = arg35
	return args, nil
}

func (ec *executionContext) field_Mutation_updateObservabilityTenant_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg1
	var arg2 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["admins"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("admins"))
		arg2, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["admins"] = arg2
	var arg3 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["metricsReaders"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsReaders"))
		arg3, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["metricsReaders"] = arg3
	var arg4 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["metricsWriters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsWriters"))
		arg4, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["metricsWriters"] = arg4
	var arg5 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["metricsDeleters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsDeleters"))
		arg5, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["metricsDeleters"] = arg5
	var arg6 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["metricsRulesReaders"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsRulesReaders"))
		arg6, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["metricsRulesReaders"] = arg6
	var arg7 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["metricsRulesWriters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsRulesWriters"))
		arg7, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["metricsRulesWriters"] = arg7
	var arg8 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["metricsRulesDeleters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsRulesDeleters"))
		arg8, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["metricsRulesDeleters"] = arg8
	var arg9 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["metricsAlertsReaders"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsAlertsReaders"))
		arg9, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["metricsAlertsReaders"] = arg9
	var arg10 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["metricsAlertsWriters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsAlertsWriters"))
		arg10, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["metricsAlertsWriters"] = arg10
	var arg11 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["logsReaders"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logsReaders"))
		arg11, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["logsReaders"] = arg11
	var arg12 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["logsWriters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logsWriters"))
		arg12, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["logsWriters"] = arg12
	var arg13 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["logsDeleters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logsDeleters"))
		arg13, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["logsDeleters"] = arg13
	var arg14 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["logsRulesReaders"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logsRulesReaders"))
		arg14, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["logsRulesReaders"] = arg14
	var arg15 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["logsRulesWriters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logsRulesWriters"))
		arg15, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["logsRulesWriters"] = arg15
	var arg16 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["logsRulesDeleters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logsRulesDeleters"))
		arg16, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["logsRulesDeleters"] = arg16
	var arg17 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["tracesReaders"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tracesReaders"))
		arg17, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tracesReaders"] = arg17
	var arg18 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["tracesWriters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tracesWriters"))
		arg18, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tracesWriters"] = arg18
	var arg19 *model.ObservabilityTenantLimitsInput
	if tmp, ok := rawArgs["limits"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limits"))
		arg19, err = ec.unmarshalOObservabilityTenantLimitsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantLimitsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limits"] = arg19
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getOAuth2Client_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["clientId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clientId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getObservabilityTenant_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_oauth2ConsentRequest_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["challenge"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("challenge"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["challenge"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_oauth2LoginRequest_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["challenge"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("challenge"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["challenge"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_organization_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

func (ec *executionContext) _queryMiddleware(ctx context.Context, obj *ast.OperationDefinition, next func(ctx context.Context) (interface{}, error)) graphql.Marshaler {

	for _, d := range obj.Directives {
		switch d.Name {
		case "checkPermissions":
			n := next
			next = func(ctx context.Context) (interface{}, error) {
				if ec.directives.CheckPermissions == nil {
					return nil, errors.New("directive checkPermissions is not implemented")
				}
				return ec.directives.CheckPermissions(ctx, obj, n)
			}
		case "isAuthenticated":
			n := next
			next = func(ctx context.Context) (interface{}, error) {
				if ec.directives.IsAuthenticated == nil {
					return nil, errors.New("directive isAuthenticated is not implemented")
				}
				return ec.directives.IsAuthenticated(ctx, obj, n)
			}
		}
	}
	tmp, err := next(ctx)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if data, ok := tmp.(graphql.Marshaler); ok {
		return data
	}
	ec.Errorf(ctx, `unexpected type %T from directive, should be graphql.Marshaler`, tmp)
	return graphql.Null

}

func (ec *executionContext) _mutationMiddleware(ctx context.Context, obj *ast.OperationDefinition, next func(ctx context.Context) (interface{}, error)) graphql.Marshaler {

	for _, d := range obj.Directives {
		switch d.Name {
		case "checkPermissions":
			n := next
			next = func(ctx context.Context) (interface{}, error) {
				if ec.directives.CheckPermissions == nil {
					return nil, errors.New("directive checkPermissions is not implemented")
				}
				return ec.directives.CheckPermissions(ctx, obj, n)
			}
		case "isAuthenticated":
			n := next
			next = func(ctx context.Context) (interface{}, error) {
				if ec.directives.IsAuthenticated == nil {
					return nil, errors.New("directive isAuthenticated is not implemented")
				}
				return ec.directives.IsAuthenticated(ctx, obj, n)
			}
		}
	}
	tmp, err := next(ctx)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if data, ok := tmp.(graphql.Marshaler); ok {
		return data
	}
	ec.Errorf(ctx, `unexpected type %T from directive, should be graphql.Marshaler`, tmp)
	return graphql.Null

}

func (ec *executionContext) _fieldMiddleware(ctx context.Context, obj interface{}, next graphql.Resolver) interface{} {
	fc := graphql.GetFieldContext(ctx)
	for _, d := range fc.Field.Directives {
		switch d.Name {
		case "checkPermissions":
			n := next
			next = func(ctx context.Context) (interface{}, error) {
				if ec.directives.CheckPermissions == nil {
					return nil, errors.New("directive checkPermissions is not implemented")
				}
				return ec.directives.CheckPermissions(ctx, obj, n)
			}
		case "isAuthenticated":
			n := next
			next = func(ctx context.Context) (interface{}, error) {
				if ec.directives.IsAuthenticated == nil {
					return nil, errors.New("directive isAuthenticated is not implemented")
				}
				return ec.directives.IsAuthenticated(ctx, obj, n)
			}
		}
	}
	res, err := ec.ResolverMiddleware(ctx, next)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return res
}

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _ForwardingRule_ingest(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.ForwardingRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ForwardingRule_ingest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ingest, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ForwardingRule_ingest(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ForwardingRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Group_name(ctx context.Context, field graphql.CollectedField, obj *model.Group) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Group_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Group_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Group",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Group_members(ctx context.Context, field graphql.CollectedField, obj *model.Group) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Group_members(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Group().Members(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.User)
	fc.Result = res
	return ec.marshalOUser2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐUserᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Group_members(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Group",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "recoveryLink":
				return ec.fieldContext_User_recoveryLink(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoginBindings_users(ctx context.Context, field graphql.CollectedField, obj *model.LoginBindings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoginBindings_users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.LoginBindings().Users(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.User)
	fc.Result = res
	return ec.marshalOUser2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐUserᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoginBindings_users(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoginBindings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "recoveryLink":
				return ec.fieldContext_User_recoveryLink(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoginBindings_groups(ctx context.Context, field graphql.CollectedField, obj *model.LoginBindings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoginBindings_groups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.LoginBindings().Groups(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Group)
	fc.Result = res
	return ec.marshalOGroup2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐGroupᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoginBindings_groups(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoginBindings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Group_name(ctx, field)
			case "members":
				return ec.fieldContext_Group_members(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Group", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_requestRate(ctx context.Context, field graphql.CollectedField, obj *model.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_requestRate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestRate, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2ᚖfloat64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_requestRate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_requestRate(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_requestRate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestRate, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2ᚖfloat64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_requestRate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_requestBurstSize(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_requestBurstSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestBurstSize, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_requestBurstSize(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_ingestionRate(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_ingestionRate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IngestionRate, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2ᚖfloat64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_ingestionRate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_ingestionBurstSize(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_ingestionBurstSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IngestionBurstSize, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_ingestionBurstSize(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_acceptHASamples(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_acceptHASamples(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AcceptHASamples, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_acceptHASamples(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_haClusterLabel(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_haClusterLabel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HAClusterLabel, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_haClusterLabel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_haReplicaLabel(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_haReplicaLabel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HAReplicaLabel, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_haReplicaLabel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_haMaxClusters(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_haMaxClusters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HAMaxClusters, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_haMaxClusters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_dropLabels(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_dropLabels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DropLabels, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2ᚕᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_dropLabels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_maxLabelNameLength(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_maxLabelNameLength(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxLabelNameLength, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_maxLabelNameLength(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_maxLabelValueLength(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_maxLabelValueLength(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxLabelValueLength, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_maxLabelValueLength(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_maxLabelNamesPerSeries(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_maxLabelNamesPerSeries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxLabelNamesPerSeries, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_maxLabelNamesPerSeries(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_maxMetadataLength(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_maxMetadataLength(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxMetadataLength, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_maxMetadataLength(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_creationGracePeriod(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_creationGracePeriod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationGracePeriod, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_creationGracePeriod(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_enforceMetadataMetricName(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_enforceMetadataMetricName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnforceMetadataMetricName, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_enforceMetadataMetricName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_ingestionTenantShardSize(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_ingestionTenantShardSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IngestionTenantShardSize, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_ingestionTenantShardSize(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_maxGlobalSeriesPerUser(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_maxGlobalSeriesPerUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxGlobalSeriesPerUser, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_maxGlobalSeriesPerUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_maxGlobalSeriesPerMetric(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_maxGlobalSeriesPerMetric(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxGlobalSeriesPerMetric, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_maxGlobalSeriesPerMetric(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_maxGlobalMetricsWithMetadataPerUser(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_maxGlobalMetricsWithMetadataPerUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxGlobalMetricsWithMetadataPerUser, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_maxGlobalMetricsWithMetadataPerUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_maxGlobalMetadataPerMetric(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_maxGlobalMetadataPerMetric(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxGlobalMetadataPerMetric, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_maxGlobalMetadataPerMetric(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_maxGlobalExemplarsPerUser(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_maxGlobalExemplarsPerUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxGlobalExemplarsPerUser, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_maxGlobalExemplarsPerUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_nativeHistogramsIngestionEnabled(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_nativeHistogramsIngestionEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NativeHistogramsIngestionEnabled, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_nativeHistogramsIngestionEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_outOfOrderTimeWindow(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_outOfOrderTimeWindow(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OutOfOrderTimeWindow, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_outOfOrderTimeWindow(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_outOfOrderBlocksExternalLabelEnabled(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_outOfOrderBlocksExternalLabelEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OutOfOrderBlocksExternalLabelEnabled, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_outOfOrderBlocksExternalLabelEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_separateMetricsGroupLabel(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_separateMetricsGroupLabel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SeparateMetricsGroupLabel, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_separateMetricsGroupLabel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_maxChunksPerQuery(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_maxChunksPerQuery(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxChunksPerQuery, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_maxChunksPerQuery(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_maxFetchedSeriesPerQuery(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_maxFetchedSeriesPerQuery(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxFetchedSeriesPerQuery, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_maxFetchedSeriesPerQuery(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_maxFetchedChunkBytesPerQuery(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_maxFetchedChunkBytesPerQuery(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxFetchedChunkBytesPerQuery, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_maxFetchedChunkBytesPerQuery(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_maxQueryLookback(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_maxQueryLookback(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxQueryLookback, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_maxQueryLookback(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_maxPartialQueryLength(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_maxPartialQueryLength(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxPartialQueryLength, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_maxPartialQueryLength(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_maxQueryParallelism(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_maxQueryParallelism(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxQueryParallelism, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_maxQueryParallelism(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_maxLabelsQueryLength(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_maxLabelsQueryLength(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxLabelsQueryLength, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_maxLabelsQueryLength(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_maxCacheFreshness(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_maxCacheFreshness(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxCacheFreshness, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_maxCacheFreshness(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_maxQueriersPerTenant(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_maxQueriersPerTenant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxQueriersPerTenant, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_maxQueriersPerTenant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_queryShardingTotalShards(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_queryShardingTotalShards(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryShardingTotalShards, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_queryShardingTotalShards(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_queryShardingMaxShardedQueries(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_queryShardingMaxShardedQueries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryShardingMaxShardedQueries, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_queryShardingMaxShardedQueries(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_queryShardingMaxRegexpSizeBytes(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_queryShardingMaxRegexpSizeBytes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryShardingMaxRegexpSizeBytes, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_queryShardingMaxRegexpSizeBytes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_splitInstantQueriesByInterval(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_splitInstantQueriesByInterval(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SplitInstantQueriesByInterval, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_splitInstantQueriesByInterval(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_maxTotalQueryLength(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_maxTotalQueryLength(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxTotalQueryLength, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_maxTotalQueryLength(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_resultsCacheTTL(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_resultsCacheTTL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResultsCacheTTL, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_resultsCacheTTL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_resultsCacheTTLForOutOfOrderTimeWindow(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_resultsCacheTTLForOutOfOrderTimeWindow(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResultsCacheTTLForOutOfOrderTimeWindow, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_resultsCacheTTLForOutOfOrderTimeWindow(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_maxQueryExpressionSizeBytes(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_maxQueryExpressionSizeBytes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxQueryExpressionSizeBytes, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_maxQueryExpressionSizeBytes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_cardinalityAnalysisEnabled(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_cardinalityAnalysisEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CardinalityAnalysisEnabled, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_cardinalityAnalysisEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_labelNamesAndValuesResultsMaxSizeBytes(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_labelNamesAndValuesResultsMaxSizeBytes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LabelNamesAndValuesResultsMaxSizeBytes, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_labelNamesAndValuesResultsMaxSizeBytes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_labelValuesMaxCardinalityLabelNamesPerRequest(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_labelValuesMaxCardinalityLabelNamesPerRequest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LabelValuesMaxCardinalityLabelNamesPerRequest, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_labelValuesMaxCardinalityLabelNamesPerRequest(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_rulerEvaluationDelay(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_rulerEvaluationDelay(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RulerEvaluationDelay, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_rulerEvaluationDelay(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_rulerTenantShardSize(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_rulerTenantShardSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RulerTenantShardSize, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_rulerTenantShardSize(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_rulerMaxRulesPerRuleGroup(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_rulerMaxRulesPerRuleGroup(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RulerMaxRulesPerRuleGroup, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_rulerMaxRulesPerRuleGroup(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_rulerMaxRuleGroupsPerTenant(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_rulerMaxRuleGroupsPerTenant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RulerMaxRuleGroupsPerTenant, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_rulerMaxRuleGroupsPerTenant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_rulerRecordingRulesEvaluationEnabled(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_rulerRecordingRulesEvaluationEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RulerRecordingRulesEvaluationEnabled, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_rulerRecordingRulesEvaluationEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_rulerAlertingRulesEvaluationEnabled(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_rulerAlertingRulesEvaluationEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RulerAlertingRulesEvaluationEnabled, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_rulerAlertingRulesEvaluationEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_storeGatewayTenantShardSize(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_storeGatewayTenantShardSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StoreGatewayTenantShardSize, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_storeGatewayTenantShardSize(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_compactorBlocksRetentionPeriod(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_compactorBlocksRetentionPeriod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompactorBlocksRetentionPeriod, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_compactorBlocksRetentionPeriod(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_compactorSplitAndMergeShards(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_compactorSplitAndMergeShards(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompactorSplitAndMergeShards, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_compactorSplitAndMergeShards(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_compactorSplitGroups(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_compactorSplitGroups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompactorSplitGroups, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_compactorSplitGroups(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_compactorTenantShardSize(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_compactorTenantShardSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompactorTenantShardSize, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_compactorTenantShardSize(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_compactorPartialBlockDeletionDelay(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_compactorPartialBlockDeletionDelay(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompactorPartialBlockDeletionDelay, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_compactorPartialBlockDeletionDelay(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_compactorBlockUploadEnabled(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_compactorBlockUploadEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompactorBlockUploadEnabled, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_compactorBlockUploadEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_compactorBlockUploadValidationEnabled(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_compactorBlockUploadValidationEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompactorBlockUploadValidationEnabled, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_compactorBlockUploadValidationEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_compactorBlockUploadVerifyChunks(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_compactorBlockUploadVerifyChunks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompactorBlockUploadVerifyChunks, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_compactorBlockUploadVerifyChunks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_s3SSEType(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_s3SSEType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.S3SSEType, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_s3SSEType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_s3SSEKMSKeyID(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_s3SSEKMSKeyID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.S3SSEKMSKeyID, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_s3SSEKMSKeyID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_s3SSEKMSEncryptionContext(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_s3SSEKMSEncryptionContext(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.S3SSEKMSEncryptionContext, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_s3SSEKMSEncryptionContext(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_alertmanagerReceiversBlockCIDRNetworks(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_alertmanagerReceiversBlockCIDRNetworks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AlertmanagerReceiversBlockCIDRNetworks, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_alertmanagerReceiversBlockCIDRNetworks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_alertmanagerReceiversBlockPrivateAddresses(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_alertmanagerReceiversBlockPrivateAddresses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AlertmanagerReceiversBlockPrivateAddresses, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_alertmanagerReceiversBlockPrivateAddresses(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_notificationRateLimit(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_notificationRateLimit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NotificationRateLimit, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2ᚖfloat64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_notificationRateLimit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_notificationRateLimitPerIntegration(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_notificationRateLimitPerIntegration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NotificationRateLimitPerIntegration, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]*float64)
	fc.Result = res
	return ec.marshalOFloatMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_notificationRateLimitPerIntegration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FloatMap does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_alertmanagerMaxConfigSizeBytes(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_alertmanagerMaxConfigSizeBytes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AlertmanagerMaxConfigSizeBytes, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_alertmanagerMaxConfigSizeBytes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_alertmanagerMaxTemplatesCount(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_alertmanagerMaxTemplatesCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AlertmanagerMaxTemplatesCount, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_alertmanagerMaxTemplatesCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_alertmanagerMaxTemplateSizeBytes(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_alertmanagerMaxTemplateSizeBytes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AlertmanagerMaxTemplateSizeBytes, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_alertmanagerMaxTemplateSizeBytes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_alertmanagerMaxDispatcherAggregationGroups(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_alertmanagerMaxDispatcherAggregationGroups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AlertmanagerMaxDispatcherAggregationGroups, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_alertmanagerMaxDispatcherAggregationGroups(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_alertmanagerMaxAlertsCount(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_alertmanagerMaxAlertsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AlertmanagerMaxAlertsCount, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_alertmanagerMaxAlertsCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_alertmanagerMaxAlertsSizeBytes(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_alertmanagerMaxAlertsSizeBytes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AlertmanagerMaxAlertsSizeBytes, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_alertmanagerMaxAlertsSizeBytes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_forwardingEndpoint(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_forwardingEndpoint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ForwardingEndpoint, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_forwardingEndpoint(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_forwardingDropOlderThan(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_forwardingDropOlderThan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ForwardingDropOlderThan, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_forwardingDropOlderThan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_forwardingRules(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_forwardingRules(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ForwardingRules, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]*v1alpha1.ForwardingRule)
	fc.Result = res
	return ec.marshalOForwardingRuleMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_forwardingRules(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ForwardingRuleMap does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateUser(rctx, fc.Args["email"].(string), fc.Args["name"].(*model.NameInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/trace-shield/graph/model.User`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	fc.Result = res
	return ec.marshalNUser2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "recoveryLink":
				return ec.fieldContext_User_recoveryLink(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteUser(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/trace-shield/graph/model.User`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	fc.Result = res
	return ec.marshalNUser2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "recoveryLink":
				return ec.fieldContext_User_recoveryLink(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_group(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_group(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().Group(rctx, fc.Args["name"].(string), fc.Args["members"].([]string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Group); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/trace-shield/graph/model.Group`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Group)
	fc.Result = res
	return ec.marshalNGroup2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_group(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Group_name(ctx, field)
			case "members":
				return ec.fieldContext_Group_members(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Group", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_group_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteGroup(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteGroup(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteGroup(rctx, fc.Args["name"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Group); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/trace-shield/graph/model.Group`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Group)
	fc.Result = res
	return ec.marshalNGroup2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteGroup(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Group_name(ctx, field)
			case "members":
				return ec.fieldContext_Group_members(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Group", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteGroup_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createOAuth2Client(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createOAuth2Client(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateOAuth2Client(rctx, fc.Args["allowedCorsOrigins"].([]string), fc.Args["audience"].([]string), fc.Args["authorizationCodeGrantAccessTokenLifespan"].(*string), fc.Args["authorizationCodeGrantIdTokenLifespan"].(*string), fc.Args["authorizationCodeGrantRefreshTokenLifespan"].(*string), fc.Args["backChannelLogoutSessionRequired"].(*bool), fc.Args["backChannelLogoutUri"].(*string), fc.Args["clientCredentialsGrantAccessTokenLifespan"].(*string), fc.Args["clientName"].(*string), fc.Args["clientSecret"].(*string), fc.Args["ClientSecretExpiresAt"].(*int64), fc.Args["clientUri"].(*string), fc.Args["contacts"].([]string), fc.Args["frontchannelLogoutSessionRequired"].(*bool), fc.Args["frontchannelLogoutUri"].(*string), fc.Args["grantTypes"].([]string), fc.Args["implicitGrantAccessTokenLifespan"].(*string), fc.Args["implicitGrantIdTokenLifespan"].(*string), fc.Args["jwks"].(map[string]interface{}), fc.Args["jwksUri"].(*string), fc.Args["jwtBearerGrantAccessTokenLifespan"].(*string), fc.Args["logoUri"].(*string), fc.Args["metadata"].(map[string]interface{}), fc.Args["policyUri"].(*string), fc.Args["postLogoutRedirectUris"].([]string), fc.Args["redirectUris"].([]string), fc.Args["responseTypes"].([]string), fc.Args["scope"].(*string), fc.Args["sectorIdentifierUri"].(*string), fc.Args["subjectType"].(*string), fc.Args["tokenEndpointAuthMethod"].(*string), fc.Args["tokenEndpointAuthSigningAlgorithm"].(*string), fc.Args["tosUri"].(*string), fc.Args["userinfoSignedResponseAlgorithm"].(*string), fc.Args["loginBindings"].(*model.LoginBindingsInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.OAuth2Client); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/trace-shield/graph/model.OAuth2Client`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.OAuth2Client)
	fc.Result = res
	return ec.marshalNOAuth2Client2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2Client(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createOAuth2Client(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "allowedCorsOrigins":
				return ec.fieldContext_OAuth2Client_allowedCorsOrigins(ctx, field)
			case "audience":
				return ec.fieldContext_OAuth2Client_audience(ctx, field)
			case "authorizationCodeGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantAccessTokenLifespan(ctx, field)
			case "authorizationCodeGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantIdTokenLifespan(ctx, field)
			case "authorizationCodeGrantRefreshTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantRefreshTokenLifespan(ctx, field)
			case "backChannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_backChannelLogoutSessionRequired(ctx, field)
			case "backChannelLogoutUri":
				return ec.fieldContext_OAuth2Client_backChannelLogoutUri(ctx, field)
			case "clientCredentialsGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_clientCredentialsGrantAccessTokenLifespan(ctx, field)
			case "clientId":
				return ec.fieldContext_OAuth2Client_clientId(ctx, field)
			case "clientName":
				return ec.fieldContext_OAuth2Client_clientName(ctx, field)
			case "clientSecret":
				return ec.fieldContext_OAuth2Client_clientSecret(ctx, field)
			case "ClientSecretExpiresAt":
				return ec.fieldContext_OAuth2Client_ClientSecretExpiresAt(ctx, field)
			case "clientUri":
				return ec.fieldContext_OAuth2Client_clientUri(ctx, field)
			case "contacts":
				return ec.fieldContext_OAuth2Client_contacts(ctx, field)
			case "createdAt":
				return ec.fieldContext_OAuth2Client_createdAt(ctx, field)
			case "frontchannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutSessionRequired(ctx, field)
			case "frontchannelLogoutUri":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutUri(ctx, field)
			case "grantTypes":
				return ec.fieldContext_OAuth2Client_grantTypes(ctx, field)
			case "implicitGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantAccessTokenLifespan(ctx, field)
			case "implicitGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantIdTokenLifespan(ctx, field)
			case "jwks":
				return ec.fieldContext_OAuth2Client_jwks(ctx, field)
			case "jwksUri":
				return ec.fieldContext_OAuth2Client_jwksUri(ctx, field)
			case "jwtBearerGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_jwtBearerGrantAccessTokenLifespan(ctx, field)
			case "logoUri":
				return ec.fieldContext_OAuth2Client_logoUri(ctx, field)
			case "metadata":
				return ec.fieldContext_OAuth2Client_metadata(ctx, field)
			case "owner":
				return ec.fieldContext_OAuth2Client_owner(ctx, field)
			case "policyUri":
				return ec.fieldContext_OAuth2Client_policyUri(ctx, field)
			case "postLogoutRedirectUris":
				return ec.fieldContext_OAuth2Client_postLogoutRedirectUris(ctx, field)
			case "redirectUris":
				return ec.fieldContext_OAuth2Client_redirectUris(ctx, field)
			case "responseTypes":
				return ec.fieldContext_OAuth2Client_responseTypes(ctx, field)
			case "scope":
				return ec.fieldContext_OAuth2Client_scope(ctx, field)
			case "sectorIdentifierUri":
				return ec.fieldContext_OAuth2Client_sectorIdentifierUri(ctx, field)
			case "subjectType":
				return ec.fieldContext_OAuth2Client_subjectType(ctx, field)
			case "tokenEndpointAuthMethod":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthMethod(ctx, field)
			case "tokenEndpointAuthSigningAlgorithm":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthSigningAlgorithm(ctx, field)
			case "tosUri":
				return ec.fieldContext_OAuth2Client_tosUri(ctx, field)
			case "updatedAt":
				return ec.fieldContext_OAuth2Client_updatedAt(ctx, field)
			case "userinfoSignedResponseAlgorithm":
				return ec.fieldContext_OAuth2Client_userinfoSignedResponseAlgorithm(ctx, field)
			case "loginBindings":
				return ec.fieldContext_OAuth2Client_loginBindings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OAuth2Client", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createOAuth2Client_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateOAuth2Client(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateOAuth2Client(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateOAuth2Client(rctx, fc.Args["allowedCorsOrigins"].([]string), fc.Args["audience"].([]string), fc.Args["authorizationCodeGrantAccessTokenLifespan"].(*string), fc.Args["authorizationCodeGrantIdTokenLifespan"].(*string), fc.Args["authorizationCodeGrantRefreshTokenLifespan"].(*string), fc.Args["backChannelLogoutSessionRequired"].(*bool), fc.Args["backChannelLogoutUri"].(*string), fc.Args["clientCredentialsGrantAccessTokenLifespan"].(*string), fc.Args["clientId"].(string), fc.Args["clientName"].(*string), fc.Args["clientSecret"].(*string), fc.Args["ClientSecretExpiresAt"].(*int64), fc.Args["clientUri"].(*string), fc.Args["contacts"].([]string), fc.Args["frontchannelLogoutSessionRequired"].(*bool), fc.Args["frontchannelLogoutUri"].(*string), fc.Args["grantTypes"].([]string), fc.Args["implicitGrantAccessTokenLifespan"].(*string), fc.Args["implicitGrantIdTokenLifespan"].(*string), fc.Args["jwks"].(map[string]interface{}), fc.Args["jwksUri"].(*string), fc.Args["jwtBearerGrantAccessTokenLifespan"].(*string), fc.Args["logoUri"].(*string), fc.Args["metadata"].(map[string]interface{}), fc.Args["policyUri"].(*string), fc.Args["postLogoutRedirectUris"].([]string), fc.Args["redirectUris"].([]string), fc.Args["responseTypes"].([]string), fc.Args["scope"].(*string), fc.Args["sectorIdentifierUri"].(*string), fc.Args["subjectType"].(*string), fc.Args["tokenEndpointAuthMethod"].(*string), fc.Args["tokenEndpointAuthSigningAlgorithm"].(*string), fc.Args["tosUri"].(*string), fc.Args["userinfoSignedResponseAlgorithm"].(*string), fc.Args["loginBindings"].(*model.LoginBindingsInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.OAuth2Client); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/trace-shield/graph/model.OAuth2Client`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.OAuth2Client)
	fc.Result = res
	return ec.marshalNOAuth2Client2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2Client(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateOAuth2Client(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "allowedCorsOrigins":
				return ec.fieldContext_OAuth2Client_allowedCorsOrigins(ctx, field)
			case "audience":
				return ec.fieldContext_OAuth2Client_audience(ctx, field)
			case "authorizationCodeGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantAccessTokenLifespan(ctx, field)
			case "authorizationCodeGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantIdTokenLifespan(ctx, field)
			case "authorizationCodeGrantRefreshTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantRefreshTokenLifespan(ctx, field)
			case "backChannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_backChannelLogoutSessionRequired(ctx, field)
			case "backChannelLogoutUri":
				return ec.fieldContext_OAuth2Client_backChannelLogoutUri(ctx, field)
			case "clientCredentialsGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_clientCredentialsGrantAccessTokenLifespan(ctx, field)
			case "clientId":
				return ec.fieldContext_OAuth2Client_clientId(ctx, field)
			case "clientName":
				return ec.fieldContext_OAuth2Client_clientName(ctx, field)
			case "clientSecret":
				return ec.fieldContext_OAuth2Client_clientSecret(ctx, field)
			case "ClientSecretExpiresAt":
				return ec.fieldContext_OAuth2Client_ClientSecretExpiresAt(ctx, field)
			case "clientUri":
				return ec.fieldContext_OAuth2Client_clientUri(ctx, field)
			case "contacts":
				return ec.fieldContext_OAuth2Client_contacts(ctx, field)
			case "createdAt":
				return ec.fieldContext_OAuth2Client_createdAt(ctx, field)
			case "frontchannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutSessionRequired(ctx, field)
			case "frontchannelLogoutUri":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutUri(ctx, field)
			case "grantTypes":
				return ec.fieldContext_OAuth2Client_grantTypes(ctx, field)
			case "implicitGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantAccessTokenLifespan(ctx, field)
			case "implicitGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantIdTokenLifespan(ctx, field)
			case "jwks":
				return ec.fieldContext_OAuth2Client_jwks(ctx, field)
			case "jwksUri":
				return ec.fieldContext_OAuth2Client_jwksUri(ctx, field)
			case "jwtBearerGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_jwtBearerGrantAccessTokenLifespan(ctx, field)
			case "logoUri":
				return ec.fieldContext_OAuth2Client_logoUri(ctx, field)
			case "metadata":
				return ec.fieldContext_OAuth2Client_metadata(ctx, field)
			case "owner":
				return ec.fieldContext_OAuth2Client_owner(ctx, field)
			case "policyUri":
				return ec.fieldContext_OAuth2Client_policyUri(ctx, field)
			case "postLogoutRedirectUris":
				return ec.fieldContext_OAuth2Client_postLogoutRedirectUris(ctx, field)
			case "redirectUris":
				return ec.fieldContext_OAuth2Client_redirectUris(ctx, field)
			case "responseTypes":
				return ec.fieldContext_OAuth2Client_responseTypes(ctx, field)
			case "scope":
				return ec.fieldContext_OAuth2Client_scope(ctx, field)
			case "sectorIdentifierUri":
				return ec.fieldContext_OAuth2Client_sectorIdentifierUri(ctx, field)
			case "subjectType":
				return ec.fieldContext_OAuth2Client_subjectType(ctx, field)
			case "tokenEndpointAuthMethod":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthMethod(ctx, field)
			case "tokenEndpointAuthSigningAlgorithm":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthSigningAlgorithm(ctx, field)
			case "tosUri":
				return ec.fieldContext_OAuth2Client_tosUri(ctx, field)
			case "updatedAt":
				return ec.fieldContext_OAuth2Client_updatedAt(ctx, field)
			case "userinfoSignedResponseAlgorithm":
				return ec.fieldContext_OAuth2Client_userinfoSignedResponseAlgorithm(ctx, field)
			case "loginBindings":
				return ec.fieldContext_OAuth2Client_loginBindings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OAuth2Client", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateOAuth2Client_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteOAuth2Client(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteOAuth2Client(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteOAuth2Client(rctx, fc.Args["clientId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.OAuth2Client); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/trace-shield/graph/model.OAuth2Client`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.OAuth2Client)
	fc.Result = res
	return ec.marshalNOAuth2Client2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2Client(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteOAuth2Client(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "allowedCorsOrigins":
				return ec.fieldContext_OAuth2Client_allowedCorsOrigins(ctx, field)
			case "audience":
				return ec.fieldContext_OAuth2Client_audience(ctx, field)
			case "authorizationCodeGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantAccessTokenLifespan(ctx, field)
			case "authorizationCodeGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantIdTokenLifespan(ctx, field)
			case "authorizationCodeGrantRefreshTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantRefreshTokenLifespan(ctx, field)
			case "backChannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_backChannelLogoutSessionRequired(ctx, field)
			case "backChannelLogoutUri":
				return ec.fieldContext_OAuth2Client_backChannelLogoutUri(ctx, field)
			case "clientCredentialsGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_clientCredentialsGrantAccessTokenLifespan(ctx, field)
			case "clientId":
				return ec.fieldContext_OAuth2Client_clientId(ctx, field)
			case "clientName":
				return ec.fieldContext_OAuth2Client_clientName(ctx, field)
			case "clientSecret":
				return ec.fieldContext_OAuth2Client_clientSecret(ctx, field)
			case "ClientSecretExpiresAt":
				return ec.fieldContext_OAuth2Client_ClientSecretExpiresAt(ctx, field)
			case "clientUri":
				return ec.fieldContext_OAuth2Client_clientUri(ctx, field)
			case "contacts":
				return ec.fieldContext_OAuth2Client_contacts(ctx, field)
			case "createdAt":
				return ec.fieldContext_OAuth2Client_createdAt(ctx, field)
			case "frontchannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutSessionRequired(ctx, field)
			case "frontchannelLogoutUri":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutUri(ctx, field)
			case "grantTypes":
				return ec.fieldContext_OAuth2Client_grantTypes(ctx, field)
			case "implicitGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantAccessTokenLifespan(ctx, field)
			case "implicitGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantIdTokenLifespan(ctx, field)
			case "jwks":
				return ec.fieldContext_OAuth2Client_jwks(ctx, field)
			case "jwksUri":
				return ec.fieldContext_OAuth2Client_jwksUri(ctx, field)
			case "jwtBearerGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_jwtBearerGrantAccessTokenLifespan(ctx, field)
			case "logoUri":
				return ec.fieldContext_OAuth2Client_logoUri(ctx, field)
			case "metadata":
				return ec.fieldContext_OAuth2Client_metadata(ctx, field)
			case "owner":
				return ec.fieldContext_OAuth2Client_owner(ctx, field)
			case "policyUri":
				return ec.fieldContext_OAuth2Client_policyUri(ctx, field)
			case "postLogoutRedirectUris":
				return ec.fieldContext_OAuth2Client_postLogoutRedirectUris(ctx, field)
			case "redirectUris":
				return ec.fieldContext_OAuth2Client_redirectUris(ctx, field)
			case "responseTypes":
				return ec.fieldContext_OAuth2Client_responseTypes(ctx, field)
			case "scope":
				return ec.fieldContext_OAuth2Client_scope(ctx, field)
			case "sectorIdentifierUri":
				return ec.fieldContext_OAuth2Client_sectorIdentifierUri(ctx, field)
			case "subjectType":
				return ec.fieldContext_OAuth2Client_subjectType(ctx, field)
			case "tokenEndpointAuthMethod":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthMethod(ctx, field)
			case "tokenEndpointAuthSigningAlgorithm":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthSigningAlgorithm(ctx, field)
			case "tosUri":
				return ec.fieldContext_OAuth2Client_tosUri(ctx, field)
			case "updatedAt":
				return ec.fieldContext_OAuth2Client_updatedAt(ctx, field)
			case "userinfoSignedResponseAlgorithm":
				return ec.fieldContext_OAuth2Client_userinfoSignedResponseAlgorithm(ctx, field)
			case "loginBindings":
				return ec.fieldContext_OAuth2Client_loginBindings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OAuth2Client", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteOAuth2Client_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_acceptOAuth2ConsentRequest(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_acceptOAuth2ConsentRequest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AcceptOAuth2ConsentRequest(rctx, fc.Args["challenge"].(string), fc.Args["grantAccessTokenAudience"].([]string), fc.Args["grantScope"].([]string), fc.Args["remember"].(*bool), fc.Args["rememberFor"].(*int64))
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.OAuth2RedirectTo)
	fc.Result = res
	return ec.marshalNOAuth2RedirectTo2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2RedirectTo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_acceptOAuth2ConsentRequest(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "redirectTo":
				return ec.fieldContext_OAuth2RedirectTo_redirectTo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OAuth2RedirectTo", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_acceptOAuth2ConsentRequest_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_rejectOAuth2ConsentRequest(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_rejectOAuth2ConsentRequest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RejectOAuth2ConsentRequest(rctx, fc.Args["challenge"].(string))
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.OAuth2RedirectTo)
	fc.Result = res
	return ec.marshalNOAuth2RedirectTo2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2RedirectTo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_rejectOAuth2ConsentRequest(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "redirectTo":
				return ec.fieldContext_OAuth2RedirectTo_redirectTo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OAuth2RedirectTo", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_rejectOAuth2ConsentRequest_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_acceptOAuth2LoginRequest(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_acceptOAuth2LoginRequest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AcceptOAuth2LoginRequest(rctx, fc.Args["challenge"].(string), fc.Args["acr"].(*string), fc.Args["amr"].([]string), fc.Args["context"].(map[string]interface{}), fc.Args["remember"].(*bool), fc.Args["rememberFor"].(*int64), fc.Args["subject"].(string))
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.OAuth2RedirectTo)
	fc.Result = res
	return ec.marshalNOAuth2RedirectTo2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2RedirectTo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_acceptOAuth2LoginRequest(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "redirectTo":
				return ec.fieldContext_OAuth2RedirectTo_redirectTo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OAuth2RedirectTo", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_acceptOAuth2LoginRequest_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_rejectOAuth2LoginRequest(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_rejectOAuth2LoginRequest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RejectOAuth2LoginRequest(rctx, fc.Args["challenge"].(string))
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.OAuth2RedirectTo)
	fc.Result = res
	return ec.marshalNOAuth2RedirectTo2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2RedirectTo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_rejectOAuth2LoginRequest(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "redirectTo":
				return ec.fieldContext_OAuth2RedirectTo_redirectTo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OAuth2RedirectTo", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_rejectOAuth2LoginRequest_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createObservabilityTenant(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createObservabilityTenant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateObservabilityTenant(rctx, fc.Args["id"].(string), fc.Args["name"].(*string), fc.Args["admins"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["metricsReaders"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["metricsWriters"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["metricsDeleters"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["metricsRulesReaders"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["metricsRulesWriters"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["metricsRulesDeleters"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["metricsAlertsReaders"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["metricsAlertsWriters"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["logsReaders"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["logsWriters"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["logsDeleters"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["logsRulesReaders"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["logsRulesWriters"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["logsRulesDeleters"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["tracesReaders"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["tracesWriters"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["limits"].(*model.ObservabilityTenantLimitsInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ObservabilityTenant); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/trace-shield/graph/model.ObservabilityTenant`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenant)
	fc.Result = res
	return ec.marshalNObservabilityTenant2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenant(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createObservabilityTenant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ObservabilityTenant_id(ctx, field)
			case "name":
				return ec.fieldContext_ObservabilityTenant_name(ctx, field)
			case "admins":
				return ec.fieldContext_ObservabilityTenant_admins(ctx, field)
			case "metricsReaders":
				return ec.fieldContext_ObservabilityTenant_metricsReaders(ctx, field)
			case "metricsWriters":
				return ec.fieldContext_ObservabilityTenant_metricsWriters(ctx, field)
			case "metricsDeleters":
				return ec.fieldContext_ObservabilityTenant_metricsDeleters(ctx, field)
			case "metricsRulesReaders":
				return ec.fieldContext_ObservabilityTenant_metricsRulesReaders(ctx, field)
			case "metricsRulesWriters":
				return ec.fieldContext_ObservabilityTenant_metricsRulesWriters(ctx, field)
			case "metricsRulesDeleters":
				return ec.fieldContext_ObservabilityTenant_metricsRulesDeleters(ctx, field)
			case "metricsAlertsReaders":
				return ec.fieldContext_ObservabilityTenant_metricsAlertsReaders(ctx, field)
			case "metricsAlertsWriters":
				return ec.fieldContext_ObservabilityTenant_metricsAlertsWriters(ctx, field)
			case "logsReaders":
				return ec.fieldContext_ObservabilityTenant_logsReaders(ctx, field)
			case "logsWriters":
				return ec.fieldContext_ObservabilityTenant_logsWriters(ctx, field)
			case "logsDeleters":
				return ec.fieldContext_ObservabilityTenant_logsDeleters(ctx, field)
			case "logsRulesReaders":
				return ec.fieldContext_ObservabilityTenant_logsRulesReaders(ctx, field)
			case "logsRulesWriters":
				return ec.fieldContext_ObservabilityTenant_logsRulesWriters(ctx, field)
			case "logsRulesDeleters":
				return ec.fieldContext_ObservabilityTenant_logsRulesDeleters(ctx, field)
			case "tracesReaders":
				return ec.fieldContext_ObservabilityTenant_tracesReaders(ctx, field)
			case "tracesWriters":
				return ec.fieldContext_ObservabilityTenant_tracesWriters(ctx, field)
			case "limits":
				return ec.fieldContext_ObservabilityTenant_limits(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenant", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createObservabilityTenant_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateObservabilityTenant(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateObservabilityTenant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateObservabilityTenant(rctx, fc.Args["id"].(string), fc.Args["name"].(*string), fc.Args["admins"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["metricsReaders"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["metricsWriters"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["metricsDeleters"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["metricsRulesReaders"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["metricsRulesWriters"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["metricsRulesDeleters"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["metricsAlertsReaders"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["metricsAlertsWriters"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["logsReaders"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["logsWriters"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["logsDeleters"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["logsRulesReaders"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["logsRulesWriters"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["logsRulesDeleters"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["tracesReaders"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["tracesWriters"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["limits"].(*model.ObservabilityTenantLimitsInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ObservabilityTenant); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/trace-shield/graph/model.ObservabilityTenant`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenant)
	fc.Result = res
	return ec.marshalNObservabilityTenant2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenant(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateObservabilityTenant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ObservabilityTenant_id(ctx, field)
			case "name":
				return ec.fieldContext_ObservabilityTenant_name(ctx, field)
			case "admins":
				return ec.fieldContext_ObservabilityTenant_admins(ctx, field)
			case "metricsReaders":
				return ec.fieldContext_ObservabilityTenant_metricsReaders(ctx, field)
			case "metricsWriters":
				return ec.fieldContext_ObservabilityTenant_metricsWriters(ctx, field)
			case "metricsDeleters":
				return ec.fieldContext_ObservabilityTenant_metricsDeleters(ctx, field)
			case "metricsRulesReaders":
				return ec.fieldContext_ObservabilityTenant_metricsRulesReaders(ctx, field)
			case "metricsRulesWriters":
				return ec.fieldContext_ObservabilityTenant_metricsRulesWriters(ctx, field)
			case "metricsRulesDeleters":
				return ec.fieldContext_ObservabilityTenant_metricsRulesDeleters(ctx, field)
			case "metricsAlertsReaders":
				return ec.fieldContext_ObservabilityTenant_metricsAlertsReaders(ctx, field)
			case "metricsAlertsWriters":
				return ec.fieldContext_ObservabilityTenant_metricsAlertsWriters(ctx, field)
			case "logsReaders":
				return ec.fieldContext_ObservabilityTenant_logsReaders(ctx, field)
			case "logsWriters":
				return ec.fieldContext_ObservabilityTenant_logsWriters(ctx, field)
			case "logsDeleters":
				return ec.fieldContext_ObservabilityTenant_logsDeleters(ctx, field)
			case "logsRulesReaders":
				return ec.fieldContext_ObservabilityTenant_logsRulesReaders(ctx, field)
			case "logsRulesWriters":
				return ec.fieldContext_ObservabilityTenant_logsRulesWriters(ctx, field)
			case "logsRulesDeleters":
				return ec.fieldContext_ObservabilityTenant_logsRulesDeleters(ctx, field)
			case "tracesReaders":
				return ec.fieldContext_ObservabilityTenant_tracesReaders(ctx, field)
			case "tracesWriters":
				return ec.fieldContext_ObservabilityTenant_tracesWriters(ctx, field)
			case "limits":
				return ec.fieldContext_ObservabilityTenant_limits(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenant", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateObservabilityTenant_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteObservabilityTenant(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteObservabilityTenant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteObservabilityTenant(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ObservabilityTenant); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/trace-shield/graph/model.ObservabilityTenant`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenant)
	fc.Result = res
	return ec.marshalNObservabilityTenant2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenant(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteObservabilityTenant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ObservabilityTenant_id(ctx, field)
			case "name":
				return ec.fieldContext_ObservabilityTenant_name(ctx, field)
			case "admins":
				return ec.fieldContext_ObservabilityTenant_admins(ctx, field)
			case "metricsReaders":
				return ec.fieldContext_ObservabilityTenant_metricsReaders(ctx, field)
			case "metricsWriters":
				return ec.fieldContext_ObservabilityTenant_metricsWriters(ctx, field)
			case "metricsDeleters":
				return ec.fieldContext_ObservabilityTenant_metricsDeleters(ctx, field)
			case "metricsRulesReaders":
				return ec.fieldContext_ObservabilityTenant_metricsRulesReaders(ctx, field)
			case "metricsRulesWriters":
				return ec.fieldContext_ObservabilityTenant_metricsRulesWriters(ctx, field)
			case "metricsRulesDeleters":
				return ec.fieldContext_ObservabilityTenant_metricsRulesDeleters(ctx, field)
			case "metricsAlertsReaders":
				return ec.fieldContext_ObservabilityTenant_metricsAlertsReaders(ctx, field)
			case "metricsAlertsWriters":
				return ec.fieldContext_ObservabilityTenant_metricsAlertsWriters(ctx, field)
			case "logsReaders":
				return ec.fieldContext_ObservabilityTenant_logsReaders(ctx, field)
			case "logsWriters":
				return ec.fieldContext_ObservabilityTenant_logsWriters(ctx, field)
			case "logsDeleters":
				return ec.fieldContext_ObservabilityTenant_logsDeleters(ctx, field)
			case "logsRulesReaders":
				return ec.fieldContext_ObservabilityTenant_logsRulesReaders(ctx, field)
			case "logsRulesWriters":
				return ec.fieldContext_ObservabilityTenant_logsRulesWriters(ctx, field)
			case "logsRulesDeleters":
				return ec.fieldContext_ObservabilityTenant_logsRulesDeleters(ctx, field)
			case "tracesReaders":
				return ec.fieldContext_ObservabilityTenant_tracesReaders(ctx, field)
			case "tracesWriters":
				return ec.fieldContext_ObservabilityTenant_tracesWriters(ctx, field)
			case "limits":
				return ec.fieldContext_ObservabilityTenant_limits(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenant", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteObservabilityTenant_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_organization(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_organization(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().Organization(rctx, fc.Args["name"].(string), fc.Args["admins"].([]string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Organization); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/trace-shield/graph/model.Organization`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Organization)
	fc.Result = res
	return ec.marshalNOrganization2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOrganization(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_organization(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Organization_name(ctx, field)
			case "admins":
				return ec.fieldContext_Organization_admins(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Organization", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_organization_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Name_first(ctx context.Context, field graphql.CollectedField, obj *model.Name) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Name_first(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.First, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Name_first(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Name",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Name_last(ctx context.Context, field graphql.CollectedField, obj *model.Name) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Name_last(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Last, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Name_last(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Name",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_allowedCorsOrigins(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_allowedCorsOrigins(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AllowedCorsOrigins, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_allowedCorsOrigins(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_audience(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_audience(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Audience, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_audience(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_authorizationCodeGrantAccessTokenLifespan(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_authorizationCodeGrantAccessTokenLifespan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthorizationCodeGrantAccessTokenLifespan, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_authorizationCodeGrantAccessTokenLifespan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_authorizationCodeGrantIdTokenLifespan(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_authorizationCodeGrantIdTokenLifespan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthorizationCodeGrantIDTokenLifespan, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_authorizationCodeGrantIdTokenLifespan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_authorizationCodeGrantRefreshTokenLifespan(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_authorizationCodeGrantRefreshTokenLifespan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthorizationCodeGrantRefreshTokenLifespan, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_authorizationCodeGrantRefreshTokenLifespan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_backChannelLogoutSessionRequired(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_backChannelLogoutSessionRequired(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BackChannelLogoutSessionRequired, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_backChannelLogoutSessionRequired(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_backChannelLogoutUri(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_backChannelLogoutUri(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BackChannelLogoutURI, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_backChannelLogoutUri(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_clientCredentialsGrantAccessTokenLifespan(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_clientCredentialsGrantAccessTokenLifespan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientCredentialsGrantAccessTokenLifespan, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_clientCredentialsGrantAccessTokenLifespan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_clientId(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_clientId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientID, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_clientId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_clientName(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_clientName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientName, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_clientName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_clientSecret(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_clientSecret(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientSecret, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_clientSecret(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_ClientSecretExpiresAt(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_ClientSecretExpiresAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientSecretExpiresAt, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int64)
	fc.Result = res
	return ec.marshalOInt2ᚖint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_ClientSecretExpiresAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_clientUri(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_clientUri(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientURI, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_clientUri(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_contacts(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_contacts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Contacts, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_contacts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_frontchannelLogoutSessionRequired(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_frontchannelLogoutSessionRequired(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FrontchannelLogoutSessionRequired, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_frontchannelLogoutSessionRequired(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_frontchannelLogoutUri(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_frontchannelLogoutUri(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FrontchannelLogoutURI, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_frontchannelLogoutUri(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_grantTypes(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_grantTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GrantTypes, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_grantTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_implicitGrantAccessTokenLifespan(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_implicitGrantAccessTokenLifespan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImplicitGrantAccessTokenLifespan, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_implicitGrantAccessTokenLifespan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_implicitGrantIdTokenLifespan(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_implicitGrantIdTokenLifespan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImplicitGrantIDTokenLifespan, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_implicitGrantIdTokenLifespan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_jwks(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_jwks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Jwks, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_jwks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_jwksUri(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_jwksUri(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JwksURI, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_jwksUri(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_jwtBearerGrantAccessTokenLifespan(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_jwtBearerGrantAccessTokenLifespan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JwtBearerGrantAccessTokenLifespan, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_jwtBearerGrantAccessTokenLifespan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_logoUri(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_logoUri(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LogoURI, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_logoUri(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_metadata(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_metadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_metadata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_owner(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_owner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.OAuth2Client().Owner(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_owner(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_policyUri(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_policyUri(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PolicyURI, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_policyUri(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_postLogoutRedirectUris(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_postLogoutRedirectUris(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PostLogoutRedirectUris, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_postLogoutRedirectUris(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_redirectUris(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_redirectUris(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RedirectUris, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_redirectUris(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_responseTypes(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_responseTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResponseTypes, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_responseTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_scope(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_scope(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Scope, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_scope(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_sectorIdentifierUri(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_sectorIdentifierUri(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SectorIdentifierURI, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_sectorIdentifierUri(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_subjectType(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_subjectType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubjectType, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_subjectType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_tokenEndpointAuthMethod(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_tokenEndpointAuthMethod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TokenEndpointAuthMethod, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_tokenEndpointAuthMethod(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_tokenEndpointAuthSigningAlgorithm(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_tokenEndpointAuthSigningAlgorithm(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TokenEndpointAuthSigningAlgorithm, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_tokenEndpointAuthSigningAlgorithm(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_tosUri(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_tosUri(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TosURI, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_tosUri(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_userinfoSignedResponseAlgorithm(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_userinfoSignedResponseAlgorithm(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserinfoSignedResponseAlgorithm, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_userinfoSignedResponseAlgorithm(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_loginBindings(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_loginBindings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.OAuth2Client().LoginBindings(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.LoginBindings)
	fc.Result = res
	return ec.marshalOLoginBindings2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐLoginBindings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_loginBindings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_LoginBindings_users(ctx, field)
			case "groups":
				return ec.fieldContext_LoginBindings_groups(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoginBindings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2ConsentRequest_acr(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2ConsentRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2ConsentRequest_acr(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Acr, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2ConsentRequest_acr(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2ConsentRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2ConsentRequest_amr(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2ConsentRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2ConsentRequest_amr(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Amr, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2ConsentRequest_amr(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2ConsentRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2ConsentRequest_challenge(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2ConsentRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2ConsentRequest_challenge(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Challenge, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2ConsentRequest_challenge(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2ConsentRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2ConsentRequest_client(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2ConsentRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2ConsentRequest_client(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Client, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.OAuth2Client)
	fc.Result = res
	return ec.marshalNOAuth2Client2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2Client(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2ConsentRequest_client(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2ConsentRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "allowedCorsOrigins":
				return ec.fieldContext_OAuth2Client_allowedCorsOrigins(ctx, field)
			case "audience":
				return ec.fieldContext_OAuth2Client_audience(ctx, field)
			case "authorizationCodeGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantAccessTokenLifespan(ctx, field)
			case "authorizationCodeGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantIdTokenLifespan(ctx, field)
			case "authorizationCodeGrantRefreshTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantRefreshTokenLifespan(ctx, field)
			case "backChannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_backChannelLogoutSessionRequired(ctx, field)
			case "backChannelLogoutUri":
				return ec.fieldContext_OAuth2Client_backChannelLogoutUri(ctx, field)
			case "clientCredentialsGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_clientCredentialsGrantAccessTokenLifespan(ctx, field)
			case "clientId":
				return ec.fieldContext_OAuth2Client_clientId(ctx, field)
			case "clientName":
				return ec.fieldContext_OAuth2Client_clientName(ctx, field)
			case "clientSecret":
				return ec.fieldContext_OAuth2Client_clientSecret(ctx, field)
			case "ClientSecretExpiresAt":
				return ec.fieldContext_OAuth2Client_ClientSecretExpiresAt(ctx, field)
			case "clientUri":
				return ec.fieldContext_OAuth2Client_clientUri(ctx, field)
			case "contacts":
				return ec.fieldContext_OAuth2Client_contacts(ctx, field)
			case "createdAt":
				return ec.fieldContext_OAuth2Client_createdAt(ctx, field)
			case "frontchannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutSessionRequired(ctx, field)
			case "frontchannelLogoutUri":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutUri(ctx, field)
			case "grantTypes":
				return ec.fieldContext_OAuth2Client_grantTypes(ctx, field)
			case "implicitGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantAccessTokenLifespan(ctx, field)
			case "implicitGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantIdTokenLifespan(ctx, field)
			case "jwks":
				return ec.fieldContext_OAuth2Client_jwks(ctx, field)
			case "jwksUri":
				return ec.fieldContext_OAuth2Client_jwksUri(ctx, field)
			case "jwtBearerGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_jwtBearerGrantAccessTokenLifespan(ctx, field)
			case "logoUri":
				return ec.fieldContext_OAuth2Client_logoUri(ctx, field)
			case "metadata":
				return ec.fieldContext_OAuth2Client_metadata(ctx, field)
			case "owner":
				return ec.fieldContext_OAuth2Client_owner(ctx, field)
			case "policyUri":
				return ec.fieldContext_OAuth2Client_policyUri(ctx, field)
			case "postLogoutRedirectUris":
				return ec.fieldContext_OAuth2Client_postLogoutRedirectUris(ctx, field)
			case "redirectUris":
				return ec.fieldContext_OAuth2Client_redirectUris(ctx, field)
			case "responseTypes":
				return ec.fieldContext_OAuth2Client_responseTypes(ctx, field)
			case "scope":
				return ec.fieldContext_OAuth2Client_scope(ctx, field)
			case "sectorIdentifierUri":
				return ec.fieldContext_OAuth2Client_sectorIdentifierUri(ctx, field)
			case "subjectType":
				return ec.fieldContext_OAuth2Client_subjectType(ctx, field)
			case "tokenEndpointAuthMethod":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthMethod(ctx, field)
			case "tokenEndpointAuthSigningAlgorithm":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthSigningAlgorithm(ctx, field)
			case "tosUri":
				return ec.fieldContext_OAuth2Client_tosUri(ctx, field)
			case "updatedAt":
				return ec.fieldContext_OAuth2Client_updatedAt(ctx, field)
			case "userinfoSignedResponseAlgorithm":
				return ec.fieldContext_OAuth2Client_userinfoSignedResponseAlgorithm(ctx, field)
			case "loginBindings":
				return ec.fieldContext_OAuth2Client_loginBindings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OAuth2Client", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2ConsentRequest_context(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2ConsentRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2ConsentRequest_context(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Context, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2ConsentRequest_context(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2ConsentRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2ConsentRequest_loginChallenge(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2ConsentRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2ConsentRequest_loginChallenge(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LoginChallenge, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2ConsentRequest_loginChallenge(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2ConsentRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2ConsentRequest_loginSessionId(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2ConsentRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2ConsentRequest_loginSessionId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LoginSessionID, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2ConsentRequest_loginSessionId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2ConsentRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2ConsentRequest_oidcContext(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2ConsentRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2ConsentRequest_oidcContext(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OidcContext, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.OidcContext)
	fc.Result = res
	return ec.marshalOOidcContext2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOidcContext(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2ConsentRequest_oidcContext(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2ConsentRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "acrValues":
				return ec.fieldContext_OidcContext_acrValues(ctx, field)
			case "display":
				return ec.fieldContext_OidcContext_display(ctx, field)
			case "idTokenHintClaims":
				return ec.fieldContext_OidcContext_idTokenHintClaims(ctx, field)
			case "loginHint":
				return ec.fieldContext_OidcContext_loginHint(ctx, field)
			case "uiLocales":
				return ec.fieldContext_OidcContext_uiLocales(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OidcContext", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2ConsentRequest_requestUrl(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2ConsentRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2ConsentRequest_requestUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestURL, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2ConsentRequest_requestUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2ConsentRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2ConsentRequest_requestedAccessTokenAudience(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2ConsentRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2ConsentRequest_requestedAccessTokenAudience(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestedAccessTokenAudience, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2ConsentRequest_requestedAccessTokenAudience(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2ConsentRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2ConsentRequest_requestedScope(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2ConsentRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2ConsentRequest_requestedScope(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestedScope, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2ConsentRequest_requestedScope(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2ConsentRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2ConsentRequest_skip(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2ConsentRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2ConsentRequest_skip(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Skip, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2ConsentRequest_skip(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2ConsentRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2ConsentRequest_subject(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2ConsentRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2ConsentRequest_subject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Subject, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2ConsentRequest_subject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2ConsentRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2ConsentRequest_redirectTo(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2ConsentRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2ConsentRequest_redirectTo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RedirectTo, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2ConsentRequest_redirectTo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2ConsentRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2LoginRequest_challenge(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2LoginRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2LoginRequest_challenge(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Challenge, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2LoginRequest_challenge(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2LoginRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2LoginRequest_client(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2LoginRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2LoginRequest_client(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Client, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.OAuth2Client)
	fc.Result = res
	return ec.marshalNOAuth2Client2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2Client(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2LoginRequest_client(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2LoginRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "allowedCorsOrigins":
				return ec.fieldContext_OAuth2Client_allowedCorsOrigins(ctx, field)
			case "audience":
				return ec.fieldContext_OAuth2Client_audience(ctx, field)
			case "authorizationCodeGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantAccessTokenLifespan(ctx, field)
			case "authorizationCodeGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantIdTokenLifespan(ctx, field)
			case "authorizationCodeGrantRefreshTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantRefreshTokenLifespan(ctx, field)
			case "backChannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_backChannelLogoutSessionRequired(ctx, field)
			case "backChannelLogoutUri":
				return ec.fieldContext_OAuth2Client_backChannelLogoutUri(ctx, field)
			case "clientCredentialsGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_clientCredentialsGrantAccessTokenLifespan(ctx, field)
			case "clientId":
				return ec.fieldContext_OAuth2Client_clientId(ctx, field)
			case "clientName":
				return ec.fieldContext_OAuth2Client_clientName(ctx, field)
			case "clientSecret":
				return ec.fieldContext_OAuth2Client_clientSecret(ctx, field)
			case "ClientSecretExpiresAt":
				return ec.fieldContext_OAuth2Client_ClientSecretExpiresAt(ctx, field)
			case "clientUri":
				return ec.fieldContext_OAuth2Client_clientUri(ctx, field)
			case "contacts":
				return ec.fieldContext_OAuth2Client_contacts(ctx, field)
			case "createdAt":
				return ec.fieldContext_OAuth2Client_createdAt(ctx, field)
			case "frontchannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutSessionRequired(ctx, field)
			case "frontchannelLogoutUri":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutUri(ctx, field)
			case "grantTypes":
				return ec.fieldContext_OAuth2Client_grantTypes(ctx, field)
			case "implicitGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantAccessTokenLifespan(ctx, field)
			case "implicitGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantIdTokenLifespan(ctx, field)
			case "jwks":
				return ec.fieldContext_OAuth2Client_jwks(ctx, field)
			case "jwksUri":
				return ec.fieldContext_OAuth2Client_jwksUri(ctx, field)
			case "jwtBearerGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_jwtBearerGrantAccessTokenLifespan(ctx, field)
			case "logoUri":
				return ec.fieldContext_OAuth2Client_logoUri(ctx, field)
			case "metadata":
				return ec.fieldContext_OAuth2Client_metadata(ctx, field)
			case "owner":
				return ec.fieldContext_OAuth2Client_owner(ctx, field)
			case "policyUri":
				return ec.fieldContext_OAuth2Client_policyUri(ctx, field)
			case "postLogoutRedirectUris":
				return ec.fieldContext_OAuth2Client_postLogoutRedirectUris(ctx, field)
			case "redirectUris":
				return ec.fieldContext_OAuth2Client_redirectUris(ctx, field)
			case "responseTypes":
				return ec.fieldContext_OAuth2Client_responseTypes(ctx, field)
			case "scope":
				return ec.fieldContext_OAuth2Client_scope(ctx, field)
			case "sectorIdentifierUri":
				return ec.fieldContext_OAuth2Client_sectorIdentifierUri(ctx, field)
			case "subjectType":
				return ec.fieldContext_OAuth2Client_subjectType(ctx, field)
			case "tokenEndpointAuthMethod":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthMethod(ctx, field)
			case "tokenEndpointAuthSigningAlgorithm":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthSigningAlgorithm(ctx, field)
			case "tosUri":
				return ec.fieldContext_OAuth2Client_tosUri(ctx, field)
			case "updatedAt":
				return ec.fieldContext_OAuth2Client_updatedAt(ctx, field)
			case "userinfoSignedResponseAlgorithm":
				return ec.fieldContext_OAuth2Client_userinfoSignedResponseAlgorithm(ctx, field)
			case "loginBindings":
				return ec.fieldContext_OAuth2Client_loginBindings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OAuth2Client", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2LoginRequest_oidcContext(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2LoginRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2LoginRequest_oidcContext(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OidcContext, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.OidcContext)
	fc.Result = res
	return ec.marshalOOidcContext2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOidcContext(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2LoginRequest_oidcContext(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2LoginRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "acrValues":
				return ec.fieldContext_OidcContext_acrValues(ctx, field)
			case "display":
				return ec.fieldContext_OidcContext_display(ctx, field)
			case "idTokenHintClaims":
				return ec.fieldContext_OidcContext_idTokenHintClaims(ctx, field)
			case "loginHint":
				return ec.fieldContext_OidcContext_loginHint(ctx, field)
			case "uiLocales":
				return ec.fieldContext_OidcContext_uiLocales(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OidcContext", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2LoginRequest_requestUrl(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2LoginRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2LoginRequest_requestUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestURL, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2LoginRequest_requestUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2LoginRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2LoginRequest_requestedAccessTokenAudience(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2LoginRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2LoginRequest_requestedAccessTokenAudience(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestedAccessTokenAudience, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2LoginRequest_requestedAccessTokenAudience(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2LoginRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2LoginRequest_requestedScope(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2LoginRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2LoginRequest_requestedScope(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestedScope, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2LoginRequest_requestedScope(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2LoginRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2LoginRequest_sessionId(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2LoginRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2LoginRequest_sessionId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SessionID, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2LoginRequest_sessionId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2LoginRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2LoginRequest_skip(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2LoginRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2LoginRequest_skip(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Skip, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2LoginRequest_skip(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2LoginRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2LoginRequest_subject(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2LoginRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2LoginRequest_subject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Subject, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2LoginRequest_subject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2LoginRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2LoginRequest_redirectTo(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2LoginRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2LoginRequest_redirectTo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RedirectTo, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2LoginRequest_redirectTo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2LoginRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2RedirectTo_redirectTo(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2RedirectTo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2RedirectTo_redirectTo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RedirectTo, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2RedirectTo_redirectTo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2RedirectTo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_id(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_name(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_admins(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_admins(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenant().Admins(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenantPermissionBindings)
	fc.Result = res
	return ec.marshalOObservabilityTenantPermissionBindings2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_admins(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_users(ctx, field)
			case "groups":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_groups(ctx, field)
			case "oauth2Clients":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_oauth2Clients(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenantPermissionBindings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_metricsReaders(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_metricsReaders(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenant().MetricsReaders(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenantPermissionBindings)
	fc.Result = res
	return ec.marshalOObservabilityTenantPermissionBindings2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_metricsReaders(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_users(ctx, field)
			case "groups":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_groups(ctx, field)
			case "oauth2Clients":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_oauth2Clients(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenantPermissionBindings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_metricsWriters(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_metricsWriters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenant().MetricsWriters(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenantPermissionBindings)
	fc.Result = res
	return ec.marshalOObservabilityTenantPermissionBindings2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_metricsWriters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_users(ctx, field)
			case "groups":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_groups(ctx, field)
			case "oauth2Clients":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_oauth2Clients(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenantPermissionBindings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_metricsDeleters(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_metricsDeleters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenant().MetricsDeleters(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenantPermissionBindings)
	fc.Result = res
	return ec.marshalOObservabilityTenantPermissionBindings2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_metricsDeleters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_users(ctx, field)
			case "groups":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_groups(ctx, field)
			case "oauth2Clients":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_oauth2Clients(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenantPermissionBindings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_metricsRulesReaders(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_metricsRulesReaders(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenant().MetricsRulesReaders(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenantPermissionBindings)
	fc.Result = res
	return ec.marshalOObservabilityTenantPermissionBindings2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_metricsRulesReaders(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_users(ctx, field)
			case "groups":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_groups(ctx, field)
			case "oauth2Clients":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_oauth2Clients(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenantPermissionBindings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_metricsRulesWriters(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_metricsRulesWriters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenant().MetricsRulesWriters(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenantPermissionBindings)
	fc.Result = res
	return ec.marshalOObservabilityTenantPermissionBindings2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_metricsRulesWriters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_users(ctx, field)
			case "groups":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_groups(ctx, field)
			case "oauth2Clients":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_oauth2Clients(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenantPermissionBindings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_metricsRulesDeleters(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_metricsRulesDeleters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenant().MetricsRulesDeleters(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenantPermissionBindings)
	fc.Result = res
	return ec.marshalOObservabilityTenantPermissionBindings2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_metricsRulesDeleters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_users(ctx, field)
			case "groups":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_groups(ctx, field)
			case "oauth2Clients":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_oauth2Clients(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenantPermissionBindings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_metricsAlertsReaders(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_metricsAlertsReaders(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenant().MetricsAlertsReaders(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenantPermissionBindings)
	fc.Result = res
	return ec.marshalOObservabilityTenantPermissionBindings2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_metricsAlertsReaders(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_users(ctx, field)
			case "groups":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_groups(ctx, field)
			case "oauth2Clients":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_oauth2Clients(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenantPermissionBindings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_metricsAlertsWriters(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_metricsAlertsWriters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenant().MetricsAlertsWriters(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenantPermissionBindings)
	fc.Result = res
	return ec.marshalOObservabilityTenantPermissionBindings2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_metricsAlertsWriters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_users(ctx, field)
			case "groups":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_groups(ctx, field)
			case "oauth2Clients":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_oauth2Clients(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenantPermissionBindings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_logsReaders(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_logsReaders(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenant().LogsReaders(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenantPermissionBindings)
	fc.Result = res
	return ec.marshalOObservabilityTenantPermissionBindings2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_logsReaders(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_users(ctx, field)
			case "groups":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_groups(ctx, field)
			case "oauth2Clients":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_oauth2Clients(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenantPermissionBindings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_logsWriters(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_logsWriters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenant().LogsWriters(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenantPermissionBindings)
	fc.Result = res
	return ec.marshalOObservabilityTenantPermissionBindings2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_logsWriters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_users(ctx, field)
			case "groups":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_groups(ctx, field)
			case "oauth2Clients":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_oauth2Clients(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenantPermissionBindings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_logsDeleters(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_logsDeleters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenant().LogsDeleters(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenantPermissionBindings)
	fc.Result = res
	return ec.marshalOObservabilityTenantPermissionBindings2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_logsDeleters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_users(ctx, field)
			case "groups":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_groups(ctx, field)
			case "oauth2Clients":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_oauth2Clients(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenantPermissionBindings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_logsRulesReaders(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_logsRulesReaders(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenant().LogsRulesReaders(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenantPermissionBindings)
	fc.Result = res
	return ec.marshalOObservabilityTenantPermissionBindings2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_logsRulesReaders(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_users(ctx, field)
			case "groups":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_groups(ctx, field)
			case "oauth2Clients":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_oauth2Clients(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenantPermissionBindings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_logsRulesWriters(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_logsRulesWriters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenant().LogsRulesWriters(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenantPermissionBindings)
	fc.Result = res
	return ec.marshalOObservabilityTenantPermissionBindings2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_logsRulesWriters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_users(ctx, field)
			case "groups":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_groups(ctx, field)
			case "oauth2Clients":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_oauth2Clients(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenantPermissionBindings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_logsRulesDeleters(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_logsRulesDeleters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenant().LogsRulesDeleters(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenantPermissionBindings)
	fc.Result = res
	return ec.marshalOObservabilityTenantPermissionBindings2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_logsRulesDeleters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_users(ctx, field)
			case "groups":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_groups(ctx, field)
			case "oauth2Clients":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_oauth2Clients(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenantPermissionBindings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_tracesReaders(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_tracesReaders(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenant().TracesReaders(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenantPermissionBindings)
	fc.Result = res
	return ec.marshalOObservabilityTenantPermissionBindings2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_tracesReaders(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_users(ctx, field)
			case "groups":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_groups(ctx, field)
			case "oauth2Clients":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_oauth2Clients(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenantPermissionBindings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_tracesWriters(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_tracesWriters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenant().TracesWriters(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenantPermissionBindings)
	fc.Result = res
	return ec.marshalOObservabilityTenantPermissionBindings2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_tracesWriters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_users(ctx, field)
			case "groups":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_groups(ctx, field)
			case "oauth2Clients":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_oauth2Clients(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenantPermissionBindings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_limits(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_limits(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Limits, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenantLimits)
	fc.Result = res
	return ec.marshalOObservabilityTenantLimits2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantLimits(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_limits(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "mimir":
				return ec.fieldContext_ObservabilityTenantLimits_mimir(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenantLimits", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenantLimits_mimir(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenantLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenantLimits_mimir(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mimir, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1alpha1.MimirLimits)
	fc.Result = res
	return ec.marshalOMimirLimits2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐMimirLimits(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenantLimits_mimir(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenantLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "requestRate":
				return ec.fieldContext_MimirLimits_requestRate(ctx, field)
			case "requestBurstSize":
				return ec.fieldContext_MimirLimits_requestBurstSize(ctx, field)
			case "ingestionRate":
				return ec.fieldContext_MimirLimits_ingestionRate(ctx, field)
			case "ingestionBurstSize":
				return ec.fieldContext_MimirLimits_ingestionBurstSize(ctx, field)
			case "acceptHASamples":
				return ec.fieldContext_MimirLimits_acceptHASamples(ctx, field)
			case "haClusterLabel":
				return ec.fieldContext_MimirLimits_haClusterLabel(ctx, field)
			case "haReplicaLabel":
				return ec.fieldContext_MimirLimits_haReplicaLabel(ctx, field)
			case "haMaxClusters":
				return ec.fieldContext_MimirLimits_haMaxClusters(ctx, field)
			case "dropLabels":
				return ec.fieldContext_MimirLimits_dropLabels(ctx, field)
			case "maxLabelNameLength":
				return ec.fieldContext_MimirLimits_maxLabelNameLength(ctx, field)
			case "maxLabelValueLength":
				return ec.fieldContext_MimirLimits_maxLabelValueLength(ctx, field)
			case "maxLabelNamesPerSeries":
				return ec.fieldContext_MimirLimits_maxLabelNamesPerSeries(ctx, field)
			case "maxMetadataLength":
				return ec.fieldContext_MimirLimits_maxMetadataLength(ctx, field)
			case "creationGracePeriod":
				return ec.fieldContext_MimirLimits_creationGracePeriod(ctx, field)
			case "enforceMetadataMetricName":
				return ec.fieldContext_MimirLimits_enforceMetadataMetricName(ctx, field)
			case "ingestionTenantShardSize":
				return ec.fieldContext_MimirLimits_ingestionTenantShardSize(ctx, field)
			case "maxGlobalSeriesPerUser":
				return ec.fieldContext_MimirLimits_maxGlobalSeriesPerUser(ctx, field)
			case "maxGlobalSeriesPerMetric":
				return ec.fieldContext_MimirLimits_maxGlobalSeriesPerMetric(ctx, field)
			case "maxGlobalMetricsWithMetadataPerUser":
				return ec.fieldContext_MimirLimits_maxGlobalMetricsWithMetadataPerUser(ctx, field)
			case "maxGlobalMetadataPerMetric":
				return ec.fieldContext_MimirLimits_maxGlobalMetadataPerMetric(ctx, field)
			case "maxGlobalExemplarsPerUser":
				return ec.fieldContext_MimirLimits_maxGlobalExemplarsPerUser(ctx, field)
			case "nativeHistogramsIngestionEnabled":
				return ec.fieldContext_MimirLimits_nativeHistogramsIngestionEnabled(ctx, field)
			case "outOfOrderTimeWindow":
				return ec.fieldContext_MimirLimits_outOfOrderTimeWindow(ctx, field)
			case "outOfOrderBlocksExternalLabelEnabled":
				return ec.fieldContext_MimirLimits_outOfOrderBlocksExternalLabelEnabled(ctx, field)
			case "separateMetricsGroupLabel":
				return ec.fieldContext_MimirLimits_separateMetricsGroupLabel(ctx, field)
			case "maxChunksPerQuery":
				return ec.fieldContext_MimirLimits_maxChunksPerQuery(ctx, field)
			case "maxFetchedSeriesPerQuery":
				return ec.fieldContext_MimirLimits_maxFetchedSeriesPerQuery(ctx, field)
			case "maxFetchedChunkBytesPerQuery":
				return ec.fieldContext_MimirLimits_maxFetchedChunkBytesPerQuery(ctx, field)
			case "maxQueryLookback":
				return ec.fieldContext_MimirLimits_maxQueryLookback(ctx, field)
			case "maxPartialQueryLength":
				return ec.fieldContext_MimirLimits_maxPartialQueryLength(ctx, field)
			case "maxQueryParallelism":
				return ec.fieldContext_MimirLimits_maxQueryParallelism(ctx, field)
			case "maxLabelsQueryLength":
				return ec.fieldContext_MimirLimits_maxLabelsQueryLength(ctx, field)
			case "maxCacheFreshness":
				return ec.fieldContext_MimirLimits_maxCacheFreshness(ctx, field)
			case "maxQueriersPerTenant":
				return ec.fieldContext_MimirLimits_maxQueriersPerTenant(ctx, field)
			case "queryShardingTotalShards":
				return ec.fieldContext_MimirLimits_queryShardingTotalShards(ctx, field)
			case "queryShardingMaxShardedQueries":
				return ec.fieldContext_MimirLimits_queryShardingMaxShardedQueries(ctx, field)
			case "queryShardingMaxRegexpSizeBytes":
				return ec.fieldContext_MimirLimits_queryShardingMaxRegexpSizeBytes(ctx, field)
			case "splitInstantQueriesByInterval":
				return ec.fieldContext_MimirLimits_splitInstantQueriesByInterval(ctx, field)
			case "maxTotalQueryLength":
				return ec.fieldContext_MimirLimits_maxTotalQueryLength(ctx, field)
			case "resultsCacheTTL":
				return ec.fieldContext_MimirLimits_resultsCacheTTL(ctx, field)
			case "resultsCacheTTLForOutOfOrderTimeWindow":
				return ec.fieldContext_MimirLimits_resultsCacheTTLForOutOfOrderTimeWindow(ctx, field)
			case "maxQueryExpressionSizeBytes":
				return ec.fieldContext_MimirLimits_maxQueryExpressionSizeBytes(ctx, field)
			case "cardinalityAnalysisEnabled":
				return ec.fieldContext_MimirLimits_cardinalityAnalysisEnabled(ctx, field)
			case "labelNamesAndValuesResultsMaxSizeBytes":
				return ec.fieldContext_MimirLimits_labelNamesAndValuesResultsMaxSizeBytes(ctx, field)
			case "labelValuesMaxCardinalityLabelNamesPerRequest":
				return ec.fieldContext_MimirLimits_labelValuesMaxCardinalityLabelNamesPerRequest(ctx, field)
			case "rulerEvaluationDelay":
				return ec.fieldContext_MimirLimits_rulerEvaluationDelay(ctx, field)
			case "rulerTenantShardSize":
				return ec.fieldContext_MimirLimits_rulerTenantShardSize(ctx, field)
			case "rulerMaxRulesPerRuleGroup":
				return ec.fieldContext_MimirLimits_rulerMaxRulesPerRuleGroup(ctx, field)
			case "rulerMaxRuleGroupsPerTenant":
				return ec.fieldContext_MimirLimits_rulerMaxRuleGroupsPerTenant(ctx, field)
			case "rulerRecordingRulesEvaluationEnabled":
				return ec.fieldContext_MimirLimits_rulerRecordingRulesEvaluationEnabled(ctx, field)
			case "rulerAlertingRulesEvaluationEnabled":
				return ec.fieldContext_MimirLimits_rulerAlertingRulesEvaluationEnabled(ctx, field)
			case "storeGatewayTenantShardSize":
				return ec.fieldContext_MimirLimits_storeGatewayTenantShardSize(ctx, field)
			case "compactorBlocksRetentionPeriod":
				return ec.fieldContext_MimirLimits_compactorBlocksRetentionPeriod(ctx, field)
			case "compactorSplitAndMergeShards":
				return ec.fieldContext_MimirLimits_compactorSplitAndMergeShards(ctx, field)
			case "compactorSplitGroups":
				return ec.fieldContext_MimirLimits_compactorSplitGroups(ctx, field)
			case "compactorTenantShardSize":
				return ec.fieldContext_MimirLimits_compactorTenantShardSize(ctx, field)
			case "compactorPartialBlockDeletionDelay":
				return ec.fieldContext_MimirLimits_compactorPartialBlockDeletionDelay(ctx, field)
			case "compactorBlockUploadEnabled":
				return ec.fieldContext_MimirLimits_compactorBlockUploadEnabled(ctx, field)
			case "compactorBlockUploadValidationEnabled":
				return ec.fieldContext_MimirLimits_compactorBlockUploadValidationEnabled(ctx, field)
			case "compactorBlockUploadVerifyChunks":
				return ec.fieldContext_MimirLimits_compactorBlockUploadVerifyChunks(ctx, field)
			case "s3SSEType":
				return ec.fieldContext_MimirLimits_s3SSEType(ctx, field)
			case "s3SSEKMSKeyID":
				return ec.fieldContext_MimirLimits_s3SSEKMSKeyID(ctx, field)
			case "s3SSEKMSEncryptionContext":
				return ec.fieldContext_MimirLimits_s3SSEKMSEncryptionContext(ctx, field)
			case "alertmanagerReceiversBlockCIDRNetworks":
				return ec.fieldContext_MimirLimits_alertmanagerReceiversBlockCIDRNetworks(ctx, field)
			case "alertmanagerReceiversBlockPrivateAddresses":
				return ec.fieldContext_MimirLimits_alertmanagerReceiversBlockPrivateAddresses(ctx, field)
			case "notificationRateLimit":
				return ec.fieldContext_MimirLimits_notificationRateLimit(ctx, field)
			case "notificationRateLimitPerIntegration":
				return ec.fieldContext_MimirLimits_notificationRateLimitPerIntegration(ctx, field)
			case "alertmanagerMaxConfigSizeBytes":
				return ec.fieldContext_MimirLimits_alertmanagerMaxConfigSizeBytes(ctx, field)
			case "alertmanagerMaxTemplatesCount":
				return ec.fieldContext_MimirLimits_alertmanagerMaxTemplatesCount(ctx, field)
			case "alertmanagerMaxTemplateSizeBytes":
				return ec.fieldContext_MimirLimits_alertmanagerMaxTemplateSizeBytes(ctx, field)
			case "alertmanagerMaxDispatcherAggregationGroups":
				return ec.fieldContext_MimirLimits_alertmanagerMaxDispatcherAggregationGroups(ctx, field)
			case "alertmanagerMaxAlertsCount":
				return ec.fieldContext_MimirLimits_alertmanagerMaxAlertsCount(ctx, field)
			case "alertmanagerMaxAlertsSizeBytes":
				return ec.fieldContext_MimirLimits_alertmanagerMaxAlertsSizeBytes(ctx, field)
			case "forwardingEndpoint":
				return ec.fieldContext_MimirLimits_forwardingEndpoint(ctx, field)
			case "forwardingDropOlderThan":
				return ec.fieldContext_MimirLimits_forwardingDropOlderThan(ctx, field)
			case "forwardingRules":
				return ec.fieldContext_MimirLimits_forwardingRules(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MimirLimits", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenantPermissionBindings_users(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenantPermissionBindings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenantPermissionBindings_users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenantPermissionBindings().Users(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.User)
	fc.Result = res
	return ec.marshalOUser2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐUserᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenantPermissionBindings_users(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenantPermissionBindings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "recoveryLink":
				return ec.fieldContext_User_recoveryLink(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenantPermissionBindings_groups(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenantPermissionBindings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenantPermissionBindings_groups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenantPermissionBindings().Groups(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Group)
	fc.Result = res
	return ec.marshalOGroup2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐGroupᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenantPermissionBindings_groups(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenantPermissionBindings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Group_name(ctx, field)
			case "members":
				return ec.fieldContext_Group_members(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Group", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenantPermissionBindings_oauth2Clients(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenantPermissionBindings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenantPermissionBindings_oauth2Clients(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenantPermissionBindings().Oauth2Clients(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.OAuth2Client)
	fc.Result = res
	return ec.marshalOOAuth2Client2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2Clientᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenantPermissionBindings_oauth2Clients(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenantPermissionBindings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "allowedCorsOrigins":
				return ec.fieldContext_OAuth2Client_allowedCorsOrigins(ctx, field)
			case "audience":
				return ec.fieldContext_OAuth2Client_audience(ctx, field)
			case "authorizationCodeGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantAccessTokenLifespan(ctx, field)
			case "authorizationCodeGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantIdTokenLifespan(ctx, field)
			case "authorizationCodeGrantRefreshTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantRefreshTokenLifespan(ctx, field)
			case "backChannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_backChannelLogoutSessionRequired(ctx, field)
			case "backChannelLogoutUri":
				return ec.fieldContext_OAuth2Client_backChannelLogoutUri(ctx, field)
			case "clientCredentialsGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_clientCredentialsGrantAccessTokenLifespan(ctx, field)
			case "clientId":
				return ec.fieldContext_OAuth2Client_clientId(ctx, field)
			case "clientName":
				return ec.fieldContext_OAuth2Client_clientName(ctx, field)
			case "clientSecret":
				return ec.fieldContext_OAuth2Client_clientSecret(ctx, field)
			case "ClientSecretExpiresAt":
				return ec.fieldContext_OAuth2Client_ClientSecretExpiresAt(ctx, field)
			case "clientUri":
				return ec.fieldContext_OAuth2Client_clientUri(ctx, field)
			case "contacts":
				return ec.fieldContext_OAuth2Client_contacts(ctx, field)
			case "createdAt":
				return ec.fieldContext_OAuth2Client_createdAt(ctx, field)
			case "frontchannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutSessionRequired(ctx, field)
			case "frontchannelLogoutUri":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutUri(ctx, field)
			case "grantTypes":
				return ec.fieldContext_OAuth2Client_grantTypes(ctx, field)
			case "implicitGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantAccessTokenLifespan(ctx, field)
			case "implicitGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantIdTokenLifespan(ctx, field)
			case "jwks":
				return ec.fieldContext_OAuth2Client_jwks(ctx, field)
			case "jwksUri":
				return ec.fieldContext_OAuth2Client_jwksUri(ctx, field)
			case "jwtBearerGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_jwtBearerGrantAccessTokenLifespan(ctx, field)
			case "logoUri":
				return ec.fieldContext_OAuth2Client_logoUri(ctx, field)
			case "metadata":
				return ec.fieldContext_OAuth2Client_metadata(ctx, field)
			case "owner":
				return ec.fieldContext_OAuth2Client_owner(ctx, field)
			case "policyUri":
				return ec.fieldContext_OAuth2Client_policyUri(ctx, field)
			case "postLogoutRedirectUris":
				return ec.fieldContext_OAuth2Client_postLogoutRedirectUris(ctx, field)
			case "redirectUris":
				return ec.fieldContext_OAuth2Client_redirectUris(ctx, field)
			case "responseTypes":
				return ec.fieldContext_OAuth2Client_responseTypes(ctx, field)
			case "scope":
				return ec.fieldContext_OAuth2Client_scope(ctx, field)
			case "sectorIdentifierUri":
				return ec.fieldContext_OAuth2Client_sectorIdentifierUri(ctx, field)
			case "subjectType":
				return ec.fieldContext_OAuth2Client_subjectType(ctx, field)
			case "tokenEndpointAuthMethod":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthMethod(ctx, field)
			case "tokenEndpointAuthSigningAlgorithm":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthSigningAlgorithm(ctx, field)
			case "tosUri":
				return ec.fieldContext_OAuth2Client_tosUri(ctx, field)
			case "updatedAt":
				return ec.fieldContext_OAuth2Client_updatedAt(ctx, field)
			case "userinfoSignedResponseAlgorithm":
				return ec.fieldContext_OAuth2Client_userinfoSignedResponseAlgorithm(ctx, field)
			case "loginBindings":
				return ec.fieldContext_OAuth2Client_loginBindings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OAuth2Client", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OidcContext_acrValues(ctx context.Context, field graphql.CollectedField, obj *model.OidcContext) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OidcContext_acrValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AcrValues, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OidcContext_acrValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OidcContext",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OidcContext_display(ctx context.Context, field graphql.CollectedField, obj *model.OidcContext) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OidcContext_display(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Display, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OidcContext_display(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OidcContext",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OidcContext_idTokenHintClaims(ctx context.Context, field graphql.CollectedField, obj *model.OidcContext) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OidcContext_idTokenHintClaims(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IDTokenHintClaims, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OidcContext_idTokenHintClaims(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OidcContext",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OidcContext_loginHint(ctx context.Context, field graphql.CollectedField, obj *model.OidcContext) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OidcContext_loginHint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LoginHint, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OidcContext_loginHint(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OidcContext",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OidcContext_uiLocales(ctx context.Context, field graphql.CollectedField, obj *model.OidcContext) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OidcContext_uiLocales(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UILocales, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OidcContext_uiLocales(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OidcContext",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_name(ctx context.Context, field graphql.CollectedField, obj *model.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_admins(ctx context.Context, field graphql.CollectedField, obj *model.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_admins(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Organization().Admins(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.User)
	fc.Result = res
	return ec.marshalOUser2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐUserᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_admins(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "recoveryLink":
				return ec.fieldContext_User_recoveryLink(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_listUsers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_listUsers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListUsers(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/pluralsh/trace-shield/graph/model.User`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.User)
	fc.Result = res
	return ec.marshalNUser2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐUserᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_listUsers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "recoveryLink":
				return ec.fieldContext_User_recoveryLink(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetUser(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/trace-shield/graph/model.User`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	fc.Result = res
	return ec.marshalNUser2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "recoveryLink":
				return ec.fieldContext_User_recoveryLink(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_listGroups(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_listGroups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListGroups(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.Group); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/pluralsh/trace-shield/graph/model.Group`, tmp)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Group)
	fc.Result = res
	return ec.marshalOGroup2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐGroupᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_listGroups(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Group_name(ctx, field)
			case "members":
				return ec.fieldContext_Group_members(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Group", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_listOAuth2Clients(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_listOAuth2Clients(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListOAuth2Clients(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.OAuth2Client); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/pluralsh/trace-shield/graph/model.OAuth2Client`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.OAuth2Client)
	fc.Result = res
	return ec.marshalNOAuth2Client2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2Clientᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_listOAuth2Clients(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "allowedCorsOrigins":
				return ec.fieldContext_OAuth2Client_allowedCorsOrigins(ctx, field)
			case "audience":
				return ec.fieldContext_OAuth2Client_audience(ctx, field)
			case "authorizationCodeGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantAccessTokenLifespan(ctx, field)
			case "authorizationCodeGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantIdTokenLifespan(ctx, field)
			case "authorizationCodeGrantRefreshTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantRefreshTokenLifespan(ctx, field)
			case "backChannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_backChannelLogoutSessionRequired(ctx, field)
			case "backChannelLogoutUri":
				return ec.fieldContext_OAuth2Client_backChannelLogoutUri(ctx, field)
			case "clientCredentialsGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_clientCredentialsGrantAccessTokenLifespan(ctx, field)
			case "clientId":
				return ec.fieldContext_OAuth2Client_clientId(ctx, field)
			case "clientName":
				return ec.fieldContext_OAuth2Client_clientName(ctx, field)
			case "clientSecret":
				return ec.fieldContext_OAuth2Client_clientSecret(ctx, field)
			case "ClientSecretExpiresAt":
				return ec.fieldContext_OAuth2Client_ClientSecretExpiresAt(ctx, field)
			case "clientUri":
				return ec.fieldContext_OAuth2Client_clientUri(ctx, field)
			case "contacts":
				return ec.fieldContext_OAuth2Client_contacts(ctx, field)
			case "createdAt":
				return ec.fieldContext_OAuth2Client_createdAt(ctx, field)
			case "frontchannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutSessionRequired(ctx, field)
			case "frontchannelLogoutUri":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutUri(ctx, field)
			case "grantTypes":
				return ec.fieldContext_OAuth2Client_grantTypes(ctx, field)
			case "implicitGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantAccessTokenLifespan(ctx, field)
			case "implicitGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantIdTokenLifespan(ctx, field)
			case "jwks":
				return ec.fieldContext_OAuth2Client_jwks(ctx, field)
			case "jwksUri":
				return ec.fieldContext_OAuth2Client_jwksUri(ctx, field)
			case "jwtBearerGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_jwtBearerGrantAccessTokenLifespan(ctx, field)
			case "logoUri":
				return ec.fieldContext_OAuth2Client_logoUri(ctx, field)
			case "metadata":
				return ec.fieldContext_OAuth2Client_metadata(ctx, field)
			case "owner":
				return ec.fieldContext_OAuth2Client_owner(ctx, field)
			case "policyUri":
				return ec.fieldContext_OAuth2Client_policyUri(ctx, field)
			case "postLogoutRedirectUris":
				return ec.fieldContext_OAuth2Client_postLogoutRedirectUris(ctx, field)
			case "redirectUris":
				return ec.fieldContext_OAuth2Client_redirectUris(ctx, field)
			case "responseTypes":
				return ec.fieldContext_OAuth2Client_responseTypes(ctx, field)
			case "scope":
				return ec.fieldContext_OAuth2Client_scope(ctx, field)
			case "sectorIdentifierUri":
				return ec.fieldContext_OAuth2Client_sectorIdentifierUri(ctx, field)
			case "subjectType":
				return ec.fieldContext_OAuth2Client_subjectType(ctx, field)
			case "tokenEndpointAuthMethod":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthMethod(ctx, field)
			case "tokenEndpointAuthSigningAlgorithm":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthSigningAlgorithm(ctx, field)
			case "tosUri":
				return ec.fieldContext_OAuth2Client_tosUri(ctx, field)
			case "updatedAt":
				return ec.fieldContext_OAuth2Client_updatedAt(ctx, field)
			case "userinfoSignedResponseAlgorithm":
				return ec.fieldContext_OAuth2Client_userinfoSignedResponseAlgorithm(ctx, field)
			case "loginBindings":
				return ec.fieldContext_OAuth2Client_loginBindings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OAuth2Client", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getOAuth2Client(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getOAuth2Client(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetOAuth2Client(rctx, fc.Args["clientId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.OAuth2Client); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/trace-shield/graph/model.OAuth2Client`, tmp)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.OAuth2Client)
	fc.Result = res
	return ec.marshalOOAuth2Client2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2Client(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getOAuth2Client(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "allowedCorsOrigins":
				return ec.fieldContext_OAuth2Client_allowedCorsOrigins(ctx, field)
			case "audience":
				return ec.fieldContext_OAuth2Client_audience(ctx, field)
			case "authorizationCodeGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantAccessTokenLifespan(ctx, field)
			case "authorizationCodeGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantIdTokenLifespan(ctx, field)
			case "authorizationCodeGrantRefreshTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantRefreshTokenLifespan(ctx, field)
			case "backChannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_backChannelLogoutSessionRequired(ctx, field)
			case "backChannelLogoutUri":
				return ec.fieldContext_OAuth2Client_backChannelLogoutUri(ctx, field)
			case "clientCredentialsGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_clientCredentialsGrantAccessTokenLifespan(ctx, field)
			case "clientId":
				return ec.fieldContext_OAuth2Client_clientId(ctx, field)
			case "clientName":
				return ec.fieldContext_OAuth2Client_clientName(ctx, field)
			case "clientSecret":
				return ec.fieldContext_OAuth2Client_clientSecret(ctx, field)
			case "ClientSecretExpiresAt":
				return ec.fieldContext_OAuth2Client_ClientSecretExpiresAt(ctx, field)
			case "clientUri":
				return ec.fieldContext_OAuth2Client_clientUri(ctx, field)
			case "contacts":
				return ec.fieldContext_OAuth2Client_contacts(ctx, field)
			case "createdAt":
				return ec.fieldContext_OAuth2Client_createdAt(ctx, field)
			case "frontchannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutSessionRequired(ctx, field)
			case "frontchannelLogoutUri":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutUri(ctx, field)
			case "grantTypes":
				return ec.fieldContext_OAuth2Client_grantTypes(ctx, field)
			case "implicitGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantAccessTokenLifespan(ctx, field)
			case "implicitGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantIdTokenLifespan(ctx, field)
			case "jwks":
				return ec.fieldContext_OAuth2Client_jwks(ctx, field)
			case "jwksUri":
				return ec.fieldContext_OAuth2Client_jwksUri(ctx, field)
			case "jwtBearerGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_jwtBearerGrantAccessTokenLifespan(ctx, field)
			case "logoUri":
				return ec.fieldContext_OAuth2Client_logoUri(ctx, field)
			case "metadata":
				return ec.fieldContext_OAuth2Client_metadata(ctx, field)
			case "owner":
				return ec.fieldContext_OAuth2Client_owner(ctx, field)
			case "policyUri":
				return ec.fieldContext_OAuth2Client_policyUri(ctx, field)
			case "postLogoutRedirectUris":
				return ec.fieldContext_OAuth2Client_postLogoutRedirectUris(ctx, field)
			case "redirectUris":
				return ec.fieldContext_OAuth2Client_redirectUris(ctx, field)
			case "responseTypes":
				return ec.fieldContext_OAuth2Client_responseTypes(ctx, field)
			case "scope":
				return ec.fieldContext_OAuth2Client_scope(ctx, field)
			case "sectorIdentifierUri":
				return ec.fieldContext_OAuth2Client_sectorIdentifierUri(ctx, field)
			case "subjectType":
				return ec.fieldContext_OAuth2Client_subjectType(ctx, field)
			case "tokenEndpointAuthMethod":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthMethod(ctx, field)
			case "tokenEndpointAuthSigningAlgorithm":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthSigningAlgorithm(ctx, field)
			case "tosUri":
				return ec.fieldContext_OAuth2Client_tosUri(ctx, field)
			case "updatedAt":
				return ec.fieldContext_OAuth2Client_updatedAt(ctx, field)
			case "userinfoSignedResponseAlgorithm":
				return ec.fieldContext_OAuth2Client_userinfoSignedResponseAlgorithm(ctx, field)
			case "loginBindings":
				return ec.fieldContext_OAuth2Client_loginBindings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OAuth2Client", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getOAuth2Client_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_oauth2ConsentRequest(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_oauth2ConsentRequest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Oauth2ConsentRequest(rctx, fc.Args["challenge"].(string))
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.OAuth2ConsentRequest)
	fc.Result = res
	return ec.marshalOOAuth2ConsentRequest2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2ConsentRequest(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_oauth2ConsentRequest(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "acr":
				return ec.fieldContext_OAuth2ConsentRequest_acr(ctx, field)
			case "amr":
				return ec.fieldContext_OAuth2ConsentRequest_amr(ctx, field)
			case "challenge":
				return ec.fieldContext_OAuth2ConsentRequest_challenge(ctx, field)
			case "client":
				return ec.fieldContext_OAuth2ConsentRequest_client(ctx, field)
			case "context":
				return ec.fieldContext_OAuth2ConsentRequest_context(ctx, field)
			case "loginChallenge":
				return ec.fieldContext_OAuth2ConsentRequest_loginChallenge(ctx, field)
			case "loginSessionId":
				return ec.fieldContext_OAuth2ConsentRequest_loginSessionId(ctx, field)
			case "oidcContext":
				return ec.fieldContext_OAuth2ConsentRequest_oidcContext(ctx, field)
			case "requestUrl":
				return ec.fieldContext_OAuth2ConsentRequest_requestUrl(ctx, field)
			case "requestedAccessTokenAudience":
				return ec.fieldContext_OAuth2ConsentRequest_requestedAccessTokenAudience(ctx, field)
			case "requestedScope":
				return ec.fieldContext_OAuth2ConsentRequest_requestedScope(ctx, field)
			case "skip":
				return ec.fieldContext_OAuth2ConsentRequest_skip(ctx, field)
			case "subject":
				return ec.fieldContext_OAuth2ConsentRequest_subject(ctx, field)
			case "redirectTo":
				return ec.fieldContext_OAuth2ConsentRequest_redirectTo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OAuth2ConsentRequest", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_oauth2ConsentRequest_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_oauth2LoginRequest(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_oauth2LoginRequest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Oauth2LoginRequest(rctx, fc.Args["challenge"].(string))
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.OAuth2LoginRequest)
	fc.Result = res
	return ec.marshalOOAuth2LoginRequest2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2LoginRequest(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_oauth2LoginRequest(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "challenge":
				return ec.fieldContext_OAuth2LoginRequest_challenge(ctx, field)
			case "client":
				return ec.fieldContext_OAuth2LoginRequest_client(ctx, field)
			case "oidcContext":
				return ec.fieldContext_OAuth2LoginRequest_oidcContext(ctx, field)
			case "requestUrl":
				return ec.fieldContext_OAuth2LoginRequest_requestUrl(ctx, field)
			case "requestedAccessTokenAudience":
				return ec.fieldContext_OAuth2LoginRequest_requestedAccessTokenAudience(ctx, field)
			case "requestedScope":
				return ec.fieldContext_OAuth2LoginRequest_requestedScope(ctx, field)
			case "sessionId":
				return ec.fieldContext_OAuth2LoginRequest_sessionId(ctx, field)
			case "skip":
				return ec.fieldContext_OAuth2LoginRequest_skip(ctx, field)
			case "subject":
				return ec.fieldContext_OAuth2LoginRequest_subject(ctx, field)
			case "redirectTo":
				return ec.fieldContext_OAuth2LoginRequest_redirectTo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OAuth2LoginRequest", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_oauth2LoginRequest_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_listObservabilityTenants(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_listObservabilityTenants(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListObservabilityTenants(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.ObservabilityTenant); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/pluralsh/trace-shield/graph/model.ObservabilityTenant`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ObservabilityTenant)
	fc.Result = res
	return ec.marshalNObservabilityTenant2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_listObservabilityTenants(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ObservabilityTenant_id(ctx, field)
			case "name":
				return ec.fieldContext_ObservabilityTenant_name(ctx, field)
			case "admins":
				return ec.fieldContext_ObservabilityTenant_admins(ctx, field)
			case "metricsReaders":
				return ec.fieldContext_ObservabilityTenant_metricsReaders(ctx, field)
			case "metricsWriters":
				return ec.fieldContext_ObservabilityTenant_metricsWriters(ctx, field)
			case "metricsDeleters":
				return ec.fieldContext_ObservabilityTenant_metricsDeleters(ctx, field)
			case "metricsRulesReaders":
				return ec.fieldContext_ObservabilityTenant_metricsRulesReaders(ctx, field)
			case "metricsRulesWriters":
				return ec.fieldContext_ObservabilityTenant_metricsRulesWriters(ctx, field)
			case "metricsRulesDeleters":
				return ec.fieldContext_ObservabilityTenant_metricsRulesDeleters(ctx, field)
			case "metricsAlertsReaders":
				return ec.fieldContext_ObservabilityTenant_metricsAlertsReaders(ctx, field)
			case "metricsAlertsWriters":
				return ec.fieldContext_ObservabilityTenant_metricsAlertsWriters(ctx, field)
			case "logsReaders":
				return ec.fieldContext_ObservabilityTenant_logsReaders(ctx, field)
			case "logsWriters":
				return ec.fieldContext_ObservabilityTenant_logsWriters(ctx, field)
			case "logsDeleters":
				return ec.fieldContext_ObservabilityTenant_logsDeleters(ctx, field)
			case "logsRulesReaders":
				return ec.fieldContext_ObservabilityTenant_logsRulesReaders(ctx, field)
			case "logsRulesWriters":
				return ec.fieldContext_ObservabilityTenant_logsRulesWriters(ctx, field)
			case "logsRulesDeleters":
				return ec.fieldContext_ObservabilityTenant_logsRulesDeleters(ctx, field)
			case "tracesReaders":
				return ec.fieldContext_ObservabilityTenant_tracesReaders(ctx, field)
			case "tracesWriters":
				return ec.fieldContext_ObservabilityTenant_tracesWriters(ctx, field)
			case "limits":
				return ec.fieldContext_ObservabilityTenant_limits(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenant", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getObservabilityTenant(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getObservabilityTenant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetObservabilityTenant(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ObservabilityTenant); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/trace-shield/graph/model.ObservabilityTenant`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenant)
	fc.Result = res
	return ec.marshalNObservabilityTenant2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenant(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getObservabilityTenant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ObservabilityTenant_id(ctx, field)
			case "name":
				return ec.fieldContext_ObservabilityTenant_name(ctx, field)
			case "admins":
				return ec.fieldContext_ObservabilityTenant_admins(ctx, field)
			case "metricsReaders":
				return ec.fieldContext_ObservabilityTenant_metricsReaders(ctx, field)
			case "metricsWriters":
				return ec.fieldContext_ObservabilityTenant_metricsWriters(ctx, field)
			case "metricsDeleters":
				return ec.fieldContext_ObservabilityTenant_metricsDeleters(ctx, field)
			case "metricsRulesReaders":
				return ec.fieldContext_ObservabilityTenant_metricsRulesReaders(ctx, field)
			case "metricsRulesWriters":
				return ec.fieldContext_ObservabilityTenant_metricsRulesWriters(ctx, field)
			case "metricsRulesDeleters":
				return ec.fieldContext_ObservabilityTenant_metricsRulesDeleters(ctx, field)
			case "metricsAlertsReaders":
				return ec.fieldContext_ObservabilityTenant_metricsAlertsReaders(ctx, field)
			case "metricsAlertsWriters":
				return ec.fieldContext_ObservabilityTenant_metricsAlertsWriters(ctx, field)
			case "logsReaders":
				return ec.fieldContext_ObservabilityTenant_logsReaders(ctx, field)
			case "logsWriters":
				return ec.fieldContext_ObservabilityTenant_logsWriters(ctx, field)
			case "logsDeleters":
				return ec.fieldContext_ObservabilityTenant_logsDeleters(ctx, field)
			case "logsRulesReaders":
				return ec.fieldContext_ObservabilityTenant_logsRulesReaders(ctx, field)
			case "logsRulesWriters":
				return ec.fieldContext_ObservabilityTenant_logsRulesWriters(ctx, field)
			case "logsRulesDeleters":
				return ec.fieldContext_ObservabilityTenant_logsRulesDeleters(ctx, field)
			case "tracesReaders":
				return ec.fieldContext_ObservabilityTenant_tracesReaders(ctx, field)
			case "tracesWriters":
				return ec.fieldContext_ObservabilityTenant_tracesWriters(ctx, field)
			case "limits":
				return ec.fieldContext_ObservabilityTenant_limits(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenant", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getObservabilityTenant_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_listOrganizations(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_listOrganizations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListOrganizations(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.Organization); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/pluralsh/trace-shield/graph/model.Organization`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Organization)
	fc.Result = res
	return ec.marshalNOrganization2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOrganizationᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_listOrganizations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Organization_name(ctx, field)
			case "admins":
				return ec.fieldContext_Organization_admins(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Organization", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_organization(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_organization(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Organization(rctx, fc.Args["name"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Organization); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/trace-shield/graph/model.Organization`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Organization)
	fc.Result = res
	return ec.marshalNOrganization2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOrganization(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_organization(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Organization_name(ctx, field)
			case "admins":
				return ec.fieldContext_Organization_admins(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Organization", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_organization_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TempoLimits_requestRate(ctx context.Context, field graphql.CollectedField, obj *model.TempoLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TempoLimits_requestRate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestRate, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2ᚖfloat64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TempoLimits_requestRate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TempoLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_name(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Name)
	fc.Result = res
	return ec.marshalOName2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐName(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "first":
				return ec.fieldContext_Name_first(ctx, field)
			case "last":
				return ec.fieldContext_Name_last(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Name", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_email(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_email(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_groups(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_groups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().Groups(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Group)
	fc.Result = res
	return ec.marshalOGroup2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐGroupᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_groups(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Group_name(ctx, field)
			case "members":
				return ec.fieldContext_Group_members(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Group", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_recoveryLink(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_recoveryLink(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RecoveryLink, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_recoveryLink(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAcceptOAuth2ConsentRequestSession(ctx context.Context, obj interface{}) (model.AcceptOAuth2ConsentRequestSession, error) {
	var it model.AcceptOAuth2ConsentRequestSession
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"accessToken", "idToken"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "accessToken":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accessToken"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.AccessToken = data
		case "idToken":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idToken"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDToken = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAdmin(ctx context.Context, obj interface{}) (model.Admin, error) {
	var it model.Admin
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLoginBindingsInput(ctx context.Context, obj interface{}) (model.LoginBindingsInput, error) {
	var it model.LoginBindingsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"users", "groups"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "users":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("users"))
			data, err := ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Users = data
		case "groups":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("groups"))
			data, err := ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Groups = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMimirLimitsInput(ctx context.Context, obj interface{}) (v1alpha1.MimirLimitsInput, error) {
	var it v1alpha1.MimirLimitsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"requestRate", "requestBurstSize", "ingestionRate", "ingestionBurstSize", "acceptHASamples", "haClusterLabel", "haReplicaLabel", "haMaxClusters", "dropLabels", "maxLabelNameLength", "maxLabelValueLength", "maxLabelNamesPerSeries", "maxMetadataLength", "creationGracePeriod", "enforceMetadataMetricName", "ingestionTenantShardSize", "maxGlobalSeriesPerUser", "maxGlobalSeriesPerMetric", "maxGlobalMetricsWithMetadataPerUser", "maxGlobalMetadataPerMetric", "maxGlobalExemplarsPerUser", "nativeHistogramsIngestionEnabled", "outOfOrderTimeWindow", "outOfOrderBlocksExternalLabelEnabled", "separateMetricsGroupLabel", "maxChunksPerQuery", "maxFetchedSeriesPerQuery", "maxFetchedChunkBytesPerQuery", "maxQueryLookback", "maxPartialQueryLength", "maxQueryParallelism", "maxLabelsQueryLength", "maxCacheFreshness", "maxQueriersPerTenant", "queryShardingTotalShards", "queryShardingMaxShardedQueries", "queryShardingMaxRegexpSizeBytes", "splitInstantQueriesByInterval", "maxTotalQueryLength", "resultsCacheTTL", "resultsCacheTTLForOutOfOrderTimeWindow", "maxQueryExpressionSizeBytes", "cardinalityAnalysisEnabled", "labelNamesAndValuesResultsMaxSizeBytes", "labelValuesMaxCardinalityLabelNamesPerRequest", "rulerEvaluationDelay", "rulerTenantShardSize", "rulerMaxRulesPerRuleGroup", "rulerMaxRuleGroupsPerTenant", "rulerRecordingRulesEvaluationEnabled", "rulerAlertingRulesEvaluationEnabled", "storeGatewayTenantShardSize", "compactorBlocksRetentionPeriod", "compactorSplitAndMergeShards", "compactorSplitGroups", "compactorTenantShardSize", "compactorPartialBlockDeletionDelay", "compactorBlockUploadEnabled", "compactorBlockUploadValidationEnabled", "compactorBlockUploadVerifyChunks", "s3SSEType", "s3SSEKMSKeyID", "s3SSEKMSEncryptionContext", "alertmanagerReceiversBlockCIDRNetworks", "alertmanagerReceiversBlockPrivateAddresses", "notificationRateLimit", "notificationRateLimitPerIntegration", "alertmanagerMaxConfigSizeBytes", "alertmanagerMaxTemplatesCount", "alertmanagerMaxTemplateSizeBytes", "alertmanagerMaxDispatcherAggregationGroups", "alertmanagerMaxAlertsCount", "alertmanagerMaxAlertsSizeBytes", "forwardingEndpoint", "forwardingDropOlderThan", "forwardingRules"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "requestRate":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requestRate"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.RequestRate = data
		case "requestBurstSize":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requestBurstSize"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.RequestBurstSize = data
		case "ingestionRate":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ingestionRate"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.IngestionRate = data
		case "ingestionBurstSize":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ingestionBurstSize"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IngestionBurstSize = data
		case "acceptHASamples":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("acceptHASamples"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AcceptHASamples = data
		case "haClusterLabel":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("haClusterLabel"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.HAClusterLabel = data
		case "haReplicaLabel":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("haReplicaLabel"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.HAReplicaLabel = data
		case "haMaxClusters":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("haMaxClusters"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.HAMaxClusters = data
		case "dropLabels":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dropLabels"))
			data, err := ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DropLabels = data
		case "maxLabelNameLength":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxLabelNameLength"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxLabelNameLength = data
		case "maxLabelValueLength":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxLabelValueLength"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxLabelValueLength = data
		case "maxLabelNamesPerSeries":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxLabelNamesPerSeries"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxLabelNamesPerSeries = data
		case "maxMetadataLength":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxMetadataLength"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxMetadataLength = data
		case "creationGracePeriod":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("creationGracePeriod"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreationGracePeriod = data
		case "enforceMetadataMetricName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("enforceMetadataMetricName"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.EnforceMetadataMetricName = data
		case "ingestionTenantShardSize":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ingestionTenantShardSize"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IngestionTenantShardSize = data
		case "maxGlobalSeriesPerUser":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxGlobalSeriesPerUser"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxGlobalSeriesPerUser = data
		case "maxGlobalSeriesPerMetric":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxGlobalSeriesPerMetric"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxGlobalSeriesPerMetric = data
		case "maxGlobalMetricsWithMetadataPerUser":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxGlobalMetricsWithMetadataPerUser"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxGlobalMetricsWithMetadataPerUser = data
		case "maxGlobalMetadataPerMetric":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxGlobalMetadataPerMetric"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxGlobalMetadataPerMetric = data
		case "maxGlobalExemplarsPerUser":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxGlobalExemplarsPerUser"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxGlobalExemplarsPerUser = data
		case "nativeHistogramsIngestionEnabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nativeHistogramsIngestionEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.NativeHistogramsIngestionEnabled = data
		case "outOfOrderTimeWindow":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("outOfOrderTimeWindow"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.OutOfOrderTimeWindow = data
		case "outOfOrderBlocksExternalLabelEnabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("outOfOrderBlocksExternalLabelEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.OutOfOrderBlocksExternalLabelEnabled = data
		case "separateMetricsGroupLabel":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("separateMetricsGroupLabel"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SeparateMetricsGroupLabel = data
		case "maxChunksPerQuery":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxChunksPerQuery"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxChunksPerQuery = data
		case "maxFetchedSeriesPerQuery":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxFetchedSeriesPerQuery"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxFetchedSeriesPerQuery = data
		case "maxFetchedChunkBytesPerQuery":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxFetchedChunkBytesPerQuery"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxFetchedChunkBytesPerQuery = data
		case "maxQueryLookback":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxQueryLookback"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxQueryLookback = data
		case "maxPartialQueryLength":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxPartialQueryLength"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxPartialQueryLength = data
		case "maxQueryParallelism":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxQueryParallelism"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxQueryParallelism = data
		case "maxLabelsQueryLength":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxLabelsQueryLength"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxLabelsQueryLength = data
		case "maxCacheFreshness":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxCacheFreshness"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxCacheFreshness = data
		case "maxQueriersPerTenant":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxQueriersPerTenant"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxQueriersPerTenant = data
		case "queryShardingTotalShards":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("queryShardingTotalShards"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.QueryShardingTotalShards = data
		case "queryShardingMaxShardedQueries":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("queryShardingMaxShardedQueries"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.QueryShardingMaxShardedQueries = data
		case "queryShardingMaxRegexpSizeBytes":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("queryShardingMaxRegexpSizeBytes"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.QueryShardingMaxRegexpSizeBytes = data
		case "splitInstantQueriesByInterval":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("splitInstantQueriesByInterval"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.SplitInstantQueriesByInterval = data
		case "maxTotalQueryLength":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxTotalQueryLength"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxTotalQueryLength = data
		case "resultsCacheTTL":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resultsCacheTTL"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.ResultsCacheTTL = data
		case "resultsCacheTTLForOutOfOrderTimeWindow":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resultsCacheTTLForOutOfOrderTimeWindow"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.ResultsCacheTTLForOutOfOrderTimeWindow = data
		case "maxQueryExpressionSizeBytes":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxQueryExpressionSizeBytes"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxQueryExpressionSizeBytes = data
		case "cardinalityAnalysisEnabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardinalityAnalysisEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardinalityAnalysisEnabled = data
		case "labelNamesAndValuesResultsMaxSizeBytes":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labelNamesAndValuesResultsMaxSizeBytes"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.LabelNamesAndValuesResultsMaxSizeBytes = data
		case "labelValuesMaxCardinalityLabelNamesPerRequest":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labelValuesMaxCardinalityLabelNamesPerRequest"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.LabelValuesMaxCardinalityLabelNamesPerRequest = data
		case "rulerEvaluationDelay":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rulerEvaluationDelay"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.RulerEvaluationDelay = data
		case "rulerTenantShardSize":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rulerTenantShardSize"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.RulerTenantShardSize = data
		case "rulerMaxRulesPerRuleGroup":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rulerMaxRulesPerRuleGroup"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.RulerMaxRulesPerRuleGroup = data
		case "rulerMaxRuleGroupsPerTenant":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rulerMaxRuleGroupsPerTenant"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.RulerMaxRuleGroupsPerTenant = data
		case "rulerRecordingRulesEvaluationEnabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rulerRecordingRulesEvaluationEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.RulerRecordingRulesEvaluationEnabled = data
		case "rulerAlertingRulesEvaluationEnabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rulerAlertingRulesEvaluationEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.RulerAlertingRulesEvaluationEnabled = data
		case "storeGatewayTenantShardSize":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("storeGatewayTenantShardSize"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.StoreGatewayTenantShardSize = data
		case "compactorBlocksRetentionPeriod":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("compactorBlocksRetentionPeriod"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.CompactorBlocksRetentionPeriod = data
		case "compactorSplitAndMergeShards":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("compactorSplitAndMergeShards"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.CompactorSplitAndMergeShards = data
		case "compactorSplitGroups":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("compactorSplitGroups"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.CompactorSplitGroups = data
		case "compactorTenantShardSize":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("compactorTenantShardSize"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.CompactorTenantShardSize = data
		case "compactorPartialBlockDeletionDelay":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("compactorPartialBlockDeletionDelay"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.CompactorPartialBlockDeletionDelay = data
		case "compactorBlockUploadEnabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("compactorBlockUploadEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CompactorBlockUploadEnabled = data
		case "compactorBlockUploadValidationEnabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("compactorBlockUploadValidationEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CompactorBlockUploadValidationEnabled = data
		case "compactorBlockUploadVerifyChunks":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("compactorBlockUploadVerifyChunks"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CompactorBlockUploadVerifyChunks = data
		case "s3SSEType":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("s3SSEType"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.S3SSEType = data
		case "s3SSEKMSKeyID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("s3SSEKMSKeyID"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.S3SSEKMSKeyID = data
		case "s3SSEKMSEncryptionContext":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("s3SSEKMSEncryptionContext"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.S3SSEKMSEncryptionContext = data
		case "alertmanagerReceiversBlockCIDRNetworks":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alertmanagerReceiversBlockCIDRNetworks"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.AlertmanagerReceiversBlockCIDRNetworks = data
		case "alertmanagerReceiversBlockPrivateAddresses":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alertmanagerReceiversBlockPrivateAddresses"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AlertmanagerReceiversBlockPrivateAddresses = data
		case "notificationRateLimit":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("notificationRateLimit"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.NotificationRateLimit = data
		case "notificationRateLimitPerIntegration":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("notificationRateLimitPerIntegration"))
			data, err := ec.unmarshalOFloatMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.NotificationRateLimitPerIntegration = data
		case "alertmanagerMaxConfigSizeBytes":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alertmanagerMaxConfigSizeBytes"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.AlertmanagerMaxConfigSizeBytes = data
		case "alertmanagerMaxTemplatesCount":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alertmanagerMaxTemplatesCount"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.AlertmanagerMaxTemplatesCount = data
		case "alertmanagerMaxTemplateSizeBytes":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alertmanagerMaxTemplateSizeBytes"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.AlertmanagerMaxTemplateSizeBytes = data
		case "alertmanagerMaxDispatcherAggregationGroups":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alertmanagerMaxDispatcherAggregationGroups"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.AlertmanagerMaxDispatcherAggregationGroups = data
		case "alertmanagerMaxAlertsCount":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alertmanagerMaxAlertsCount"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.AlertmanagerMaxAlertsCount = data
		case "alertmanagerMaxAlertsSizeBytes":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alertmanagerMaxAlertsSizeBytes"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.AlertmanagerMaxAlertsSizeBytes = data
		case "forwardingEndpoint":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("forwardingEndpoint"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ForwardingEndpoint = data
		case "forwardingDropOlderThan":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("forwardingDropOlderThan"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.ForwardingDropOlderThan = data
		case "forwardingRules":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("forwardingRules"))
			data, err := ec.unmarshalOForwardingRuleMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.ForwardingRules = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNameInput(ctx context.Context, obj interface{}) (model.NameInput, error) {
	var it model.NameInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"first", "last"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "first":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.First = data
		case "last":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Last = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputObservabilityTenantLimitsInput(ctx context.Context, obj interface{}) (model.ObservabilityTenantLimitsInput, error) {
	var it model.ObservabilityTenantLimitsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"mimir"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "mimir":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mimir"))
			data, err := ec.unmarshalOMimirLimitsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐMimirLimitsInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Mimir = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputObservabilityTenantPermissionBindingsInput(ctx context.Context, obj interface{}) (model.ObservabilityTenantPermissionBindingsInput, error) {
	var it model.ObservabilityTenantPermissionBindingsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"users", "groups", "oauth2Clients"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "users":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("users"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Users = data
		case "groups":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("groups"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Groups = data
		case "oauth2Clients":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("oauth2Clients"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Oauth2Clients = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var forwardingRuleImplementors = []string{"ForwardingRule"}

func (ec *executionContext) _ForwardingRule(ctx context.Context, sel ast.SelectionSet, obj *v1alpha1.ForwardingRule) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, forwardingRuleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ForwardingRule")
		case "ingest":
			out.Values[i] = ec._ForwardingRule_ingest(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var groupImplementors = []string{"Group"}

func (ec *executionContext) _Group(ctx context.Context, sel ast.SelectionSet, obj *model.Group) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Group")
		case "name":
			out.Values[i] = ec._Group_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "members":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Group_members(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var loginBindingsImplementors = []string{"LoginBindings"}

func (ec *executionContext) _LoginBindings(ctx context.Context, sel ast.SelectionSet, obj *model.LoginBindings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, loginBindingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LoginBindings")
		case "users":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LoginBindings_users(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "groups":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LoginBindings_groups(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var lokiLimitsImplementors = []string{"LokiLimits"}

func (ec *executionContext) _LokiLimits(ctx context.Context, sel ast.SelectionSet, obj *model.LokiLimits) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, lokiLimitsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LokiLimits")
		case "requestRate":
			out.Values[i] = ec._LokiLimits_requestRate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mimirLimitsImplementors = []string{"MimirLimits"}

func (ec *executionContext) _MimirLimits(ctx context.Context, sel ast.SelectionSet, obj *v1alpha1.MimirLimits) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mimirLimitsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MimirLimits")
		case "requestRate":
			out.Values[i] = ec._MimirLimits_requestRate(ctx, field, obj)
		case "requestBurstSize":
			out.Values[i] = ec._MimirLimits_requestBurstSize(ctx, field, obj)
		case "ingestionRate":
			out.Values[i] = ec._MimirLimits_ingestionRate(ctx, field, obj)
		case "ingestionBurstSize":
			out.Values[i] = ec._MimirLimits_ingestionBurstSize(ctx, field, obj)
		case "acceptHASamples":
			out.Values[i] = ec._MimirLimits_acceptHASamples(ctx, field, obj)
		case "haClusterLabel":
			out.Values[i] = ec._MimirLimits_haClusterLabel(ctx, field, obj)
		case "haReplicaLabel":
			out.Values[i] = ec._MimirLimits_haReplicaLabel(ctx, field, obj)
		case "haMaxClusters":
			out.Values[i] = ec._MimirLimits_haMaxClusters(ctx, field, obj)
		case "dropLabels":
			out.Values[i] = ec._MimirLimits_dropLabels(ctx, field, obj)
		case "maxLabelNameLength":
			out.Values[i] = ec._MimirLimits_maxLabelNameLength(ctx, field, obj)
		case "maxLabelValueLength":
			out.Values[i] = ec._MimirLimits_maxLabelValueLength(ctx, field, obj)
		case "maxLabelNamesPerSeries":
			out.Values[i] = ec._MimirLimits_maxLabelNamesPerSeries(ctx, field, obj)
		case "maxMetadataLength":
			out.Values[i] = ec._MimirLimits_maxMetadataLength(ctx, field, obj)
		case "creationGracePeriod":
			out.Values[i] = ec._MimirLimits_creationGracePeriod(ctx, field, obj)
		case "enforceMetadataMetricName":
			out.Values[i] = ec._MimirLimits_enforceMetadataMetricName(ctx, field, obj)
		case "ingestionTenantShardSize":
			out.Values[i] = ec._MimirLimits_ingestionTenantShardSize(ctx, field, obj)
		case "maxGlobalSeriesPerUser":
			out.Values[i] = ec._MimirLimits_maxGlobalSeriesPerUser(ctx, field, obj)
		case "maxGlobalSeriesPerMetric":
			out.Values[i] = ec._MimirLimits_maxGlobalSeriesPerMetric(ctx, field, obj)
		case "maxGlobalMetricsWithMetadataPerUser":
			out.Values[i] = ec._MimirLimits_maxGlobalMetricsWithMetadataPerUser(ctx, field, obj)
		case "maxGlobalMetadataPerMetric":
			out.Values[i] = ec._MimirLimits_maxGlobalMetadataPerMetric(ctx, field, obj)
		case "maxGlobalExemplarsPerUser":
			out.Values[i] = ec._MimirLimits_maxGlobalExemplarsPerUser(ctx, field, obj)
		case "nativeHistogramsIngestionEnabled":
			out.Values[i] = ec._MimirLimits_nativeHistogramsIngestionEnabled(ctx, field, obj)
		case "outOfOrderTimeWindow":
			out.Values[i] = ec._MimirLimits_outOfOrderTimeWindow(ctx, field, obj)
		case "outOfOrderBlocksExternalLabelEnabled":
			out.Values[i] = ec._MimirLimits_outOfOrderBlocksExternalLabelEnabled(ctx, field, obj)
		case "separateMetricsGroupLabel":
			out.Values[i] = ec._MimirLimits_separateMetricsGroupLabel(ctx, field, obj)
		case "maxChunksPerQuery":
			out.Values[i] = ec._MimirLimits_maxChunksPerQuery(ctx, field, obj)
		case "maxFetchedSeriesPerQuery":
			out.Values[i] = ec._MimirLimits_maxFetchedSeriesPerQuery(ctx, field, obj)
		case "maxFetchedChunkBytesPerQuery":
			out.Values[i] = ec._MimirLimits_maxFetchedChunkBytesPerQuery(ctx, field, obj)
		case "maxQueryLookback":
			out.Values[i] = ec._MimirLimits_maxQueryLookback(ctx, field, obj)
		case "maxPartialQueryLength":
			out.Values[i] = ec._MimirLimits_maxPartialQueryLength(ctx, field, obj)
		case "maxQueryParallelism":
			out.Values[i] = ec._MimirLimits_maxQueryParallelism(ctx, field, obj)
		case "maxLabelsQueryLength":
			out.Values[i] = ec._MimirLimits_maxLabelsQueryLength(ctx, field, obj)
		case "maxCacheFreshness":
			out.Values[i] = ec._MimirLimits_maxCacheFreshness(ctx, field, obj)
		case "maxQueriersPerTenant":
			out.Values[i] = ec._MimirLimits_maxQueriersPerTenant(ctx, field, obj)
		case "queryShardingTotalShards":
			out.Values[i] = ec._MimirLimits_queryShardingTotalShards(ctx, field, obj)
		case "queryShardingMaxShardedQueries":
			out.Values[i] = ec._MimirLimits_queryShardingMaxShardedQueries(ctx, field, obj)
		case "queryShardingMaxRegexpSizeBytes":
			out.Values[i] = ec._MimirLimits_queryShardingMaxRegexpSizeBytes(ctx, field, obj)
		case "splitInstantQueriesByInterval":
			out.Values[i] = ec._MimirLimits_splitInstantQueriesByInterval(ctx, field, obj)
		case "maxTotalQueryLength":
			out.Values[i] = ec._MimirLimits_maxTotalQueryLength(ctx, field, obj)
		case "resultsCacheTTL":
			out.Values[i] = ec._MimirLimits_resultsCacheTTL(ctx, field, obj)
		case "resultsCacheTTLForOutOfOrderTimeWindow":
			out.Values[i] = ec._MimirLimits_resultsCacheTTLForOutOfOrderTimeWindow(ctx, field, obj)
		case "maxQueryExpressionSizeBytes":
			out.Values[i] = ec._MimirLimits_maxQueryExpressionSizeBytes(ctx, field, obj)
		case "cardinalityAnalysisEnabled":
			out.Values[i] = ec._MimirLimits_cardinalityAnalysisEnabled(ctx, field, obj)
		case "labelNamesAndValuesResultsMaxSizeBytes":
			out.Values[i] = ec._MimirLimits_labelNamesAndValuesResultsMaxSizeBytes(ctx, field, obj)
		case "labelValuesMaxCardinalityLabelNamesPerRequest":
			out.Values[i] = ec._MimirLimits_labelValuesMaxCardinalityLabelNamesPerRequest(ctx, field, obj)
		case "rulerEvaluationDelay":
			out.Values[i] = ec._MimirLimits_rulerEvaluationDelay(ctx, field, obj)
		case "rulerTenantShardSize":
			out.Values[i] = ec._MimirLimits_rulerTenantShardSize(ctx, field, obj)
		case "rulerMaxRulesPerRuleGroup":
			out.Values[i] = ec._MimirLimits_rulerMaxRulesPerRuleGroup(ctx, field, obj)
		case "rulerMaxRuleGroupsPerTenant":
			out.Values[i] = ec._MimirLimits_rulerMaxRuleGroupsPerTenant(ctx, field, obj)
		case "rulerRecordingRulesEvaluationEnabled":
			out.Values[i] = ec._MimirLimits_rulerRecordingRulesEvaluationEnabled(ctx, field, obj)
		case "rulerAlertingRulesEvaluationEnabled":
			out.Values[i] = ec._MimirLimits_rulerAlertingRulesEvaluationEnabled(ctx, field, obj)
		case "storeGatewayTenantShardSize":
			out.Values[i] = ec._MimirLimits_storeGatewayTenantShardSize(ctx, field, obj)
		case "compactorBlocksRetentionPeriod":
			out.Values[i] = ec._MimirLimits_compactorBlocksRetentionPeriod(ctx, field, obj)
		case "compactorSplitAndMergeShards":
			out.Values[i] = ec._MimirLimits_compactorSplitAndMergeShards(ctx, field, obj)
		case "compactorSplitGroups":
			out.Values[i] = ec._MimirLimits_compactorSplitGroups(ctx, field, obj)
		case "compactorTenantShardSize":
			out.Values[i] = ec._MimirLimits_compactorTenantShardSize(ctx, field, obj)
		case "compactorPartialBlockDeletionDelay":
			out.Values[i] = ec._MimirLimits_compactorPartialBlockDeletionDelay(ctx, field, obj)
		case "compactorBlockUploadEnabled":
			out.Values[i] = ec._MimirLimits_compactorBlockUploadEnabled(ctx, field, obj)
		case "compactorBlockUploadValidationEnabled":
			out.Values[i] = ec._MimirLimits_compactorBlockUploadValidationEnabled(ctx, field, obj)
		case "compactorBlockUploadVerifyChunks":
			out.Values[i] = ec._MimirLimits_compactorBlockUploadVerifyChunks(ctx, field, obj)
		case "s3SSEType":
			out.Values[i] = ec._MimirLimits_s3SSEType(ctx, field, obj)
		case "s3SSEKMSKeyID":
			out.Values[i] = ec._MimirLimits_s3SSEKMSKeyID(ctx, field, obj)
		case "s3SSEKMSEncryptionContext":
			out.Values[i] = ec._MimirLimits_s3SSEKMSEncryptionContext(ctx, field, obj)
		case "alertmanagerReceiversBlockCIDRNetworks":
			out.Values[i] = ec._MimirLimits_alertmanagerReceiversBlockCIDRNetworks(ctx, field, obj)
		case "alertmanagerReceiversBlockPrivateAddresses":
			out.Values[i] = ec._MimirLimits_alertmanagerReceiversBlockPrivateAddresses(ctx, field, obj)
		case "notificationRateLimit":
			out.Values[i] = ec._MimirLimits_notificationRateLimit(ctx, field, obj)
		case "notificationRateLimitPerIntegration":
			out.Values[i] = ec._MimirLimits_notificationRateLimitPerIntegration(ctx, field, obj)
		case "alertmanagerMaxConfigSizeBytes":
			out.Values[i] = ec._MimirLimits_alertmanagerMaxConfigSizeBytes(ctx, field, obj)
		case "alertmanagerMaxTemplatesCount":
			out.Values[i] = ec._MimirLimits_alertmanagerMaxTemplatesCount(ctx, field, obj)
		case "alertmanagerMaxTemplateSizeBytes":
			out.Values[i] = ec._MimirLimits_alertmanagerMaxTemplateSizeBytes(ctx, field, obj)
		case "alertmanagerMaxDispatcherAggregationGroups":
			out.Values[i] = ec._MimirLimits_alertmanagerMaxDispatcherAggregationGroups(ctx, field, obj)
		case "alertmanagerMaxAlertsCount":
			out.Values[i] = ec._MimirLimits_alertmanagerMaxAlertsCount(ctx, field, obj)
		case "alertmanagerMaxAlertsSizeBytes":
			out.Values[i] = ec._MimirLimits_alertmanagerMaxAlertsSizeBytes(ctx, field, obj)
		case "forwardingEndpoint":
			out.Values[i] = ec._MimirLimits_forwardingEndpoint(ctx, field, obj)
		case "forwardingDropOlderThan":
			out.Values[i] = ec._MimirLimits_forwardingDropOlderThan(ctx, field, obj)
		case "forwardingRules":
			out.Values[i] = ec._MimirLimits_forwardingRules(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createUser(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteUser(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "group":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_group(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteGroup":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteGroup(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createOAuth2Client":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createOAuth2Client(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateOAuth2Client":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateOAuth2Client(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteOAuth2Client":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteOAuth2Client(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "acceptOAuth2ConsentRequest":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_acceptOAuth2ConsentRequest(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rejectOAuth2ConsentRequest":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_rejectOAuth2ConsentRequest(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "acceptOAuth2LoginRequest":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_acceptOAuth2LoginRequest(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rejectOAuth2LoginRequest":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_rejectOAuth2LoginRequest(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createObservabilityTenant":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createObservabilityTenant(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateObservabilityTenant":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateObservabilityTenant(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteObservabilityTenant":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteObservabilityTenant(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "organization":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_organization(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var nameImplementors = []string{"Name"}

func (ec *executionContext) _Name(ctx context.Context, sel ast.SelectionSet, obj *model.Name) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, nameImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Name")
		case "first":
			out.Values[i] = ec._Name_first(ctx, field, obj)
		case "last":
			out.Values[i] = ec._Name_last(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var oAuth2ClientImplementors = []string{"OAuth2Client"}

func (ec *executionContext) _OAuth2Client(ctx context.Context, sel ast.SelectionSet, obj *model.OAuth2Client) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oAuth2ClientImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OAuth2Client")
		case "allowedCorsOrigins":
			out.Values[i] = ec._OAuth2Client_allowedCorsOrigins(ctx, field, obj)
		case "audience":
			out.Values[i] = ec._OAuth2Client_audience(ctx, field, obj)
		case "authorizationCodeGrantAccessTokenLifespan":
			out.Values[i] = ec._OAuth2Client_authorizationCodeGrantAccessTokenLifespan(ctx, field, obj)
		case "authorizationCodeGrantIdTokenLifespan":
			out.Values[i] = ec._OAuth2Client_authorizationCodeGrantIdTokenLifespan(ctx, field, obj)
		case "authorizationCodeGrantRefreshTokenLifespan":
			out.Values[i] = ec._OAuth2Client_authorizationCodeGrantRefreshTokenLifespan(ctx, field, obj)
		case "backChannelLogoutSessionRequired":
			out.Values[i] = ec._OAuth2Client_backChannelLogoutSessionRequired(ctx, field, obj)
		case "backChannelLogoutUri":
			out.Values[i] = ec._OAuth2Client_backChannelLogoutUri(ctx, field, obj)
		case "clientCredentialsGrantAccessTokenLifespan":
			out.Values[i] = ec._OAuth2Client_clientCredentialsGrantAccessTokenLifespan(ctx, field, obj)
		case "clientId":
			out.Values[i] = ec._OAuth2Client_clientId(ctx, field, obj)
		case "clientName":
			out.Values[i] = ec._OAuth2Client_clientName(ctx, field, obj)
		case "clientSecret":
			out.Values[i] = ec._OAuth2Client_clientSecret(ctx, field, obj)
		case "ClientSecretExpiresAt":
			out.Values[i] = ec._OAuth2Client_ClientSecretExpiresAt(ctx, field, obj)
		case "clientUri":
			out.Values[i] = ec._OAuth2Client_clientUri(ctx, field, obj)
		case "contacts":
			out.Values[i] = ec._OAuth2Client_contacts(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._OAuth2Client_createdAt(ctx, field, obj)
		case "frontchannelLogoutSessionRequired":
			out.Values[i] = ec._OAuth2Client_frontchannelLogoutSessionRequired(ctx, field, obj)
		case "frontchannelLogoutUri":
			out.Values[i] = ec._OAuth2Client_frontchannelLogoutUri(ctx, field, obj)
		case "grantTypes":
			out.Values[i] = ec._OAuth2Client_grantTypes(ctx, field, obj)
		case "implicitGrantAccessTokenLifespan":
			out.Values[i] = ec._OAuth2Client_implicitGrantAccessTokenLifespan(ctx, field, obj)
		case "implicitGrantIdTokenLifespan":
			out.Values[i] = ec._OAuth2Client_implicitGrantIdTokenLifespan(ctx, field, obj)
		case "jwks":
			out.Values[i] = ec._OAuth2Client_jwks(ctx, field, obj)
		case "jwksUri":
			out.Values[i] = ec._OAuth2Client_jwksUri(ctx, field, obj)
		case "jwtBearerGrantAccessTokenLifespan":
			out.Values[i] = ec._OAuth2Client_jwtBearerGrantAccessTokenLifespan(ctx, field, obj)
		case "logoUri":
			out.Values[i] = ec._OAuth2Client_logoUri(ctx, field, obj)
		case "metadata":
			out.Values[i] = ec._OAuth2Client_metadata(ctx, field, obj)
		case "owner":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._OAuth2Client_owner(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "policyUri":
			out.Values[i] = ec._OAuth2Client_policyUri(ctx, field, obj)
		case "postLogoutRedirectUris":
			out.Values[i] = ec._OAuth2Client_postLogoutRedirectUris(ctx, field, obj)
		case "redirectUris":
			out.Values[i] = ec._OAuth2Client_redirectUris(ctx, field, obj)
		case "responseTypes":
			out.Values[i] = ec._OAuth2Client_responseTypes(ctx, field, obj)
		case "scope":
			out.Values[i] = ec._OAuth2Client_scope(ctx, field, obj)
		case "sectorIdentifierUri":
			out.Values[i] = ec._OAuth2Client_sectorIdentifierUri(ctx, field, obj)
		case "subjectType":
			out.Values[i] = ec._OAuth2Client_subjectType(ctx, field, obj)
		case "tokenEndpointAuthMethod":
			out.Values[i] = ec._OAuth2Client_tokenEndpointAuthMethod(ctx, field, obj)
		case "tokenEndpointAuthSigningAlgorithm":
			out.Values[i] = ec._OAuth2Client_tokenEndpointAuthSigningAlgorithm(ctx, field, obj)
		case "tosUri":
			out.Values[i] = ec._OAuth2Client_tosUri(ctx, field, obj)
		case "updatedAt":
			out.Values[i] = ec._OAuth2Client_updatedAt(ctx, field, obj)
		case "userinfoSignedResponseAlgorithm":
			out.Values[i] = ec._OAuth2Client_userinfoSignedResponseAlgorithm(ctx, field, obj)
		case "loginBindings":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._OAuth2Client_loginBindings(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var oAuth2ConsentRequestImplementors = []string{"OAuth2ConsentRequest"}

func (ec *executionContext) _OAuth2ConsentRequest(ctx context.Context, sel ast.SelectionSet, obj *model.OAuth2ConsentRequest) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oAuth2ConsentRequestImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OAuth2ConsentRequest")
		case "acr":
			out.Values[i] = ec._OAuth2ConsentRequest_acr(ctx, field, obj)
		case "amr":
			out.Values[i] = ec._OAuth2ConsentRequest_amr(ctx, field, obj)
		case "challenge":
			out.Values[i] = ec._OAuth2ConsentRequest_challenge(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "client":
			out.Values[i] = ec._OAuth2ConsentRequest_client(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "context":
			out.Values[i] = ec._OAuth2ConsentRequest_context(ctx, field, obj)
		case "loginChallenge":
			out.Values[i] = ec._OAuth2ConsentRequest_loginChallenge(ctx, field, obj)
		case "loginSessionId":
			out.Values[i] = ec._OAuth2ConsentRequest_loginSessionId(ctx, field, obj)
		case "oidcContext":
			out.Values[i] = ec._OAuth2ConsentRequest_oidcContext(ctx, field, obj)
		case "requestUrl":
			out.Values[i] = ec._OAuth2ConsentRequest_requestUrl(ctx, field, obj)
		case "requestedAccessTokenAudience":
			out.Values[i] = ec._OAuth2ConsentRequest_requestedAccessTokenAudience(ctx, field, obj)
		case "requestedScope":
			out.Values[i] = ec._OAuth2ConsentRequest_requestedScope(ctx, field, obj)
		case "skip":
			out.Values[i] = ec._OAuth2ConsentRequest_skip(ctx, field, obj)
		case "subject":
			out.Values[i] = ec._OAuth2ConsentRequest_subject(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "redirectTo":
			out.Values[i] = ec._OAuth2ConsentRequest_redirectTo(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var oAuth2LoginRequestImplementors = []string{"OAuth2LoginRequest"}

func (ec *executionContext) _OAuth2LoginRequest(ctx context.Context, sel ast.SelectionSet, obj *model.OAuth2LoginRequest) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oAuth2LoginRequestImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OAuth2LoginRequest")
		case "challenge":
			out.Values[i] = ec._OAuth2LoginRequest_challenge(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "client":
			out.Values[i] = ec._OAuth2LoginRequest_client(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "oidcContext":
			out.Values[i] = ec._OAuth2LoginRequest_oidcContext(ctx, field, obj)
		case "requestUrl":
			out.Values[i] = ec._OAuth2LoginRequest_requestUrl(ctx, field, obj)
		case "requestedAccessTokenAudience":
			out.Values[i] = ec._OAuth2LoginRequest_requestedAccessTokenAudience(ctx, field, obj)
		case "requestedScope":
			out.Values[i] = ec._OAuth2LoginRequest_requestedScope(ctx, field, obj)
		case "sessionId":
			out.Values[i] = ec._OAuth2LoginRequest_sessionId(ctx, field, obj)
		case "skip":
			out.Values[i] = ec._OAuth2LoginRequest_skip(ctx, field, obj)
		case "subject":
			out.Values[i] = ec._OAuth2LoginRequest_subject(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "redirectTo":
			out.Values[i] = ec._OAuth2LoginRequest_redirectTo(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var oAuth2RedirectToImplementors = []string{"OAuth2RedirectTo"}

func (ec *executionContext) _OAuth2RedirectTo(ctx context.Context, sel ast.SelectionSet, obj *model.OAuth2RedirectTo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oAuth2RedirectToImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OAuth2RedirectTo")
		case "redirectTo":
			out.Values[i] = ec._OAuth2RedirectTo_redirectTo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var observabilityTenantImplementors = []string{"ObservabilityTenant"}

func (ec *executionContext) _ObservabilityTenant(ctx context.Context, sel ast.SelectionSet, obj *model.ObservabilityTenant) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, observabilityTenantImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ObservabilityTenant")
		case "id":
			out.Values[i] = ec._ObservabilityTenant_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._ObservabilityTenant_name(ctx, field, obj)
		case "admins":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenant_admins(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "metricsReaders":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenant_metricsReaders(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "metricsWriters":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenant_metricsWriters(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "metricsDeleters":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenant_metricsDeleters(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "metricsRulesReaders":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenant_metricsRulesReaders(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "metricsRulesWriters":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenant_metricsRulesWriters(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "metricsRulesDeleters":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenant_metricsRulesDeleters(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "metricsAlertsReaders":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenant_metricsAlertsReaders(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "metricsAlertsWriters":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenant_metricsAlertsWriters(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "logsReaders":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenant_logsReaders(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "logsWriters":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenant_logsWriters(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "logsDeleters":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenant_logsDeleters(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "logsRulesReaders":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenant_logsRulesReaders(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "logsRulesWriters":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenant_logsRulesWriters(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "logsRulesDeleters":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenant_logsRulesDeleters(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "tracesReaders":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenant_tracesReaders(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "tracesWriters":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenant_tracesWriters(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "limits":
			out.Values[i] = ec._ObservabilityTenant_limits(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var observabilityTenantLimitsImplementors = []string{"ObservabilityTenantLimits"}

func (ec *executionContext) _ObservabilityTenantLimits(ctx context.Context, sel ast.SelectionSet, obj *model.ObservabilityTenantLimits) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, observabilityTenantLimitsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ObservabilityTenantLimits")
		case "mimir":
			out.Values[i] = ec._ObservabilityTenantLimits_mimir(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var observabilityTenantPermissionBindingsImplementors = []string{"ObservabilityTenantPermissionBindings"}

func (ec *executionContext) _ObservabilityTenantPermissionBindings(ctx context.Context, sel ast.SelectionSet, obj *model.ObservabilityTenantPermissionBindings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, observabilityTenantPermissionBindingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ObservabilityTenantPermissionBindings")
		case "users":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenantPermissionBindings_users(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "groups":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenantPermissionBindings_groups(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "oauth2Clients":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenantPermissionBindings_oauth2Clients(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var oidcContextImplementors = []string{"OidcContext"}

func (ec *executionContext) _OidcContext(ctx context.Context, sel ast.SelectionSet, obj *model.OidcContext) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oidcContextImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OidcContext")
		case "acrValues":
			out.Values[i] = ec._OidcContext_acrValues(ctx, field, obj)
		case "display":
			out.Values[i] = ec._OidcContext_display(ctx, field, obj)
		case "idTokenHintClaims":
			out.Values[i] = ec._OidcContext_idTokenHintClaims(ctx, field, obj)
		case "loginHint":
			out.Values[i] = ec._OidcContext_loginHint(ctx, field, obj)
		case "uiLocales":
			out.Values[i] = ec._OidcContext_uiLocales(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var organizationImplementors = []string{"Organization"}

func (ec *executionContext) _Organization(ctx context.Context, sel ast.SelectionSet, obj *model.Organization) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, organizationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Organization")
		case "name":
			out.Values[i] = ec._Organization_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "admins":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Organization_admins(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "listUsers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listUsers(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getUser":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getUser(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "listGroups":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listGroups(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "listOAuth2Clients":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listOAuth2Clients(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getOAuth2Client":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getOAuth2Client(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "oauth2ConsentRequest":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_oauth2ConsentRequest(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "oauth2LoginRequest":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_oauth2LoginRequest(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "listObservabilityTenants":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listObservabilityTenants(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getObservabilityTenant":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getObservabilityTenant(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "listOrganizations":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listOrganizations(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "organization":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_organization(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var tempoLimitsImplementors = []string{"TempoLimits"}

func (ec *executionContext) _TempoLimits(ctx context.Context, sel ast.SelectionSet, obj *model.TempoLimits) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tempoLimitsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TempoLimits")
		case "requestRate":
			out.Values[i] = ec._TempoLimits_requestRate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userImplementors = []string{"User"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *model.User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":
			out.Values[i] = ec._User_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._User_name(ctx, field, obj)
		case "email":
			out.Values[i] = ec._User_email(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "groups":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_groups(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "recoveryLink":
			out.Values[i] = ec._User_recoveryLink(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNGroup2githubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐGroup(ctx context.Context, sel ast.SelectionSet, v model.Group) graphql.Marshaler {
	return ec._Group(ctx, sel, &v)
}

func (ec *executionContext) marshalNGroup2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐGroup(ctx context.Context, sel ast.SelectionSet, v *model.Group) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Group(ctx, sel, v)
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNOAuth2Client2githubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2Client(ctx context.Context, sel ast.SelectionSet, v model.OAuth2Client) graphql.Marshaler {
	return ec._OAuth2Client(ctx, sel, &v)
}

func (ec *executionContext) marshalNOAuth2Client2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2Clientᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.OAuth2Client) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOAuth2Client2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2Client(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNOAuth2Client2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2Client(ctx context.Context, sel ast.SelectionSet, v *model.OAuth2Client) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OAuth2Client(ctx, sel, v)
}

func (ec *executionContext) marshalNOAuth2RedirectTo2githubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2RedirectTo(ctx context.Context, sel ast.SelectionSet, v model.OAuth2RedirectTo) graphql.Marshaler {
	return ec._OAuth2RedirectTo(ctx, sel, &v)
}

func (ec *executionContext) marshalNOAuth2RedirectTo2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2RedirectTo(ctx context.Context, sel ast.SelectionSet, v *model.OAuth2RedirectTo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OAuth2RedirectTo(ctx, sel, v)
}

func (ec *executionContext) marshalNObservabilityTenant2githubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenant(ctx context.Context, sel ast.SelectionSet, v model.ObservabilityTenant) graphql.Marshaler {
	return ec._ObservabilityTenant(ctx, sel, &v)
}

func (ec *executionContext) marshalNObservabilityTenant2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.ObservabilityTenant) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNObservabilityTenant2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenant(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNObservabilityTenant2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenant(ctx context.Context, sel ast.SelectionSet, v *model.ObservabilityTenant) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ObservabilityTenant(ctx, sel, v)
}

func (ec *executionContext) marshalNOrganization2githubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOrganization(ctx context.Context, sel ast.SelectionSet, v model.Organization) graphql.Marshaler {
	return ec._Organization(ctx, sel, &v)
}

func (ec *executionContext) marshalNOrganization2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOrganizationᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Organization) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOrganization2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOrganization(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNOrganization2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOrganization(ctx context.Context, sel ast.SelectionSet, v *model.Organization) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Organization(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUser2githubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐUser(ctx context.Context, sel ast.SelectionSet, v model.User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalNUser2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐUserᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.User) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUser2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUser2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐUser(ctx context.Context, sel ast.SelectionSet, v *model.User) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx context.Context, v interface{}) (*v1.Duration, error) {
	if v == nil {
		return nil, nil
	}
	res, err := custom.UnmarshalDuration(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx context.Context, sel ast.SelectionSet, v *v1.Duration) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := custom.MarshalDuration(*v)
	return res
}

func (ec *executionContext) unmarshalOFloat2ᚖfloat64(ctx context.Context, v interface{}) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalFloat(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2ᚖfloat64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalFloat(*v)
	return res
}

func (ec *executionContext) unmarshalOFloatMap2map(ctx context.Context, v interface{}) (map[string]*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := custom.UnmarshalFloatMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloatMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]*float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := custom.MarshalFloatMap(v)
	return res
}

func (ec *executionContext) unmarshalOForwardingRuleMap2map(ctx context.Context, v interface{}) (map[string]*v1alpha1.ForwardingRule, error) {
	if v == nil {
		return nil, nil
	}
	res, err := custom.UnmarshalForwardingRuleMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOForwardingRuleMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]*v1alpha1.ForwardingRule) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := custom.MarshalForwardingRuleMap(v)
	return res
}

func (ec *executionContext) marshalOGroup2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐGroupᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Group) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGroup2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐGroup(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOID2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOID2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2ᚖint64(ctx context.Context, v interface{}) (*int64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt64(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint64(ctx context.Context, sel ast.SelectionSet, v *int64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt64(*v)
	return res
}

func (ec *executionContext) marshalOLoginBindings2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐLoginBindings(ctx context.Context, sel ast.SelectionSet, v *model.LoginBindings) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LoginBindings(ctx, sel, v)
}

func (ec *executionContext) unmarshalOLoginBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐLoginBindingsInput(ctx context.Context, v interface{}) (*model.LoginBindingsInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLoginBindingsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOMap2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]interface{}) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalMap(v)
	return res
}

func (ec *executionContext) marshalOMimirLimits2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐMimirLimits(ctx context.Context, sel ast.SelectionSet, v *v1alpha1.MimirLimits) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MimirLimits(ctx, sel, v)
}

func (ec *executionContext) unmarshalOMimirLimitsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐMimirLimitsInput(ctx context.Context, v interface{}) (*v1alpha1.MimirLimitsInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputMimirLimitsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOName2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐName(ctx context.Context, sel ast.SelectionSet, v *model.Name) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Name(ctx, sel, v)
}

func (ec *executionContext) unmarshalONameInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐNameInput(ctx context.Context, v interface{}) (*model.NameInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNameInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOAuth2Client2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2Clientᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.OAuth2Client) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOAuth2Client2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2Client(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOOAuth2Client2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2Client(ctx context.Context, sel ast.SelectionSet, v *model.OAuth2Client) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._OAuth2Client(ctx, sel, v)
}

func (ec *executionContext) marshalOOAuth2ConsentRequest2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2ConsentRequest(ctx context.Context, sel ast.SelectionSet, v *model.OAuth2ConsentRequest) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._OAuth2ConsentRequest(ctx, sel, v)
}

func (ec *executionContext) marshalOOAuth2LoginRequest2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2LoginRequest(ctx context.Context, sel ast.SelectionSet, v *model.OAuth2LoginRequest) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._OAuth2LoginRequest(ctx, sel, v)
}

func (ec *executionContext) marshalOObservabilityTenantLimits2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantLimits(ctx context.Context, sel ast.SelectionSet, v *model.ObservabilityTenantLimits) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ObservabilityTenantLimits(ctx, sel, v)
}

func (ec *executionContext) unmarshalOObservabilityTenantLimitsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantLimitsInput(ctx context.Context, v interface{}) (*model.ObservabilityTenantLimitsInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputObservabilityTenantLimitsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOObservabilityTenantPermissionBindings2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindings(ctx context.Context, sel ast.SelectionSet, v *model.ObservabilityTenantPermissionBindings) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ObservabilityTenantPermissionBindings(ctx, sel, v)
}

func (ec *executionContext) unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx context.Context, v interface{}) (*model.ObservabilityTenantPermissionBindingsInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputObservabilityTenantPermissionBindingsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOidcContext2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOidcContext(ctx context.Context, sel ast.SelectionSet, v *model.OidcContext) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._OidcContext(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚕᚖstring(ctx context.Context, v interface{}) ([]*string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOString2ᚖstring(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕᚖstring(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOString2ᚖstring(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOTime2ᚖtimeᚐTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2ᚖtimeᚐTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) marshalOUser2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐUserᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUser2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
