// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/pluralsh/trace-shield-controller/api/observability/v1alpha1"
	"github.com/pluralsh/trace-shield/graph/custom"
	"github.com/pluralsh/trace-shield/graph/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
	"k8s.io/apimachinery/pkg/apis/meta/v1"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	BlockedQuery() BlockedQueryResolver
	Group() GroupResolver
	LoginBindings() LoginBindingsResolver
	MatchPolicyAttribute() MatchPolicyAttributeResolver
	Mutation() MutationResolver
	OAuth2Client() OAuth2ClientResolver
	ObservabilityTenant() ObservabilityTenantResolver
	ObservabilityTenantPermissionBindings() ObservabilityTenantPermissionBindingsResolver
	Organization() OrganizationResolver
	Query() QueryResolver
	RelabelConfig() RelabelConfigResolver
	User() UserResolver
	LokiLimitsInput() LokiLimitsInputResolver
	MimirLimitsInput() MimirLimitsInputResolver
	TempoLimitsInput() TempoLimitsInputResolver
}

type DirectiveRoot struct {
	CheckPermissions func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	IsAuthenticated  func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
}

type ComplexityRoot struct {
	BlockedQuery struct {
		Hash    func(childComplexity int) int
		Pattern func(childComplexity int) int
		Regex   func(childComplexity int) int
		Types   func(childComplexity int) int
	}

	DimensionMappings struct {
		Join        func(childComplexity int) int
		Name        func(childComplexity int) int
		SourceLabel func(childComplexity int) int
	}

	FilterPolicy struct {
		Exclude func(childComplexity int) int
		Include func(childComplexity int) int
	}

	Group struct {
		Members func(childComplexity int) int
		Name    func(childComplexity int) int
	}

	LoginBindings struct {
		Groups func(childComplexity int) int
		Users  func(childComplexity int) int
	}

	LokiLimits struct {
		BlockedQueries                       func(childComplexity int) int
		CardinalityLimit                     func(childComplexity int) int
		CreationGracePeriod                  func(childComplexity int) int
		DeletionMode                         func(childComplexity int) int
		EnforceMetricName                    func(childComplexity int) int
		IncrementDuplicateTimestamp          func(childComplexity int) int
		IndexGatewayShardSize                func(childComplexity int) int
		IngestionBurstSizeMB                 func(childComplexity int) int
		IngestionRateMB                      func(childComplexity int) int
		IngestionRateStrategy                func(childComplexity int) int
		MaxCacheFreshness                    func(childComplexity int) int
		MaxChunksPerQuery                    func(childComplexity int) int
		MaxConcurrentTailRequests            func(childComplexity int) int
		MaxEntriesLimitPerQuery              func(childComplexity int) int
		MaxGlobalStreamsPerUser              func(childComplexity int) int
		MaxLabelNameLength                   func(childComplexity int) int
		MaxLabelNamesPerSeries               func(childComplexity int) int
		MaxLabelValueLength                  func(childComplexity int) int
		MaxLineSize                          func(childComplexity int) int
		MaxLineSizeTruncate                  func(childComplexity int) int
		MaxLocalStreamsPerUser               func(childComplexity int) int
		MaxQuerierBytesRead                  func(childComplexity int) int
		MaxQueriersPerTenant                 func(childComplexity int) int
		MaxQueryBytesRead                    func(childComplexity int) int
		MaxQueryLength                       func(childComplexity int) int
		MaxQueryLookback                     func(childComplexity int) int
		MaxQueryParallelism                  func(childComplexity int) int
		MaxQueryRange                        func(childComplexity int) int
		MaxQuerySeries                       func(childComplexity int) int
		MaxStatsCacheFreshness               func(childComplexity int) int
		MaxStreamsMatchersPerQuery           func(childComplexity int) int
		MinShardingLookback                  func(childComplexity int) int
		PerStreamRateLimit                   func(childComplexity int) int
		PerStreamRateLimitBurst              func(childComplexity int) int
		QueryReadyIndexNumDays               func(childComplexity int) int
		QuerySplitDuration                   func(childComplexity int) int
		QueryTimeout                         func(childComplexity int) int
		RejectOldSamples                     func(childComplexity int) int
		RejectOldSamplesMaxAge               func(childComplexity int) int
		RequiredLabels                       func(childComplexity int) int
		RequiredNumberLabels                 func(childComplexity int) int
		RetentionPeriod                      func(childComplexity int) int
		RulerAlertManagerConfig              func(childComplexity int) int
		RulerEvaluationDelay                 func(childComplexity int) int
		RulerMaxRuleGroupsPerTenant          func(childComplexity int) int
		RulerMaxRulesPerRuleGroup            func(childComplexity int) int
		RulerRemoteEvaluationMaxResponseSize func(childComplexity int) int
		RulerRemoteEvaluationTimeout         func(childComplexity int) int
		RulerRemoteWriteDisabled             func(childComplexity int) int
		RulerTenantShardSize                 func(childComplexity int) int
		ShardStreams                         func(childComplexity int) int
		StreamRetention                      func(childComplexity int) int
		TSDBMaxBytesPerShard                 func(childComplexity int) int
		TSDBMaxQueryParallelism              func(childComplexity int) int
		UnorderedWrites                      func(childComplexity int) int
		VolumeEnabled                        func(childComplexity int) int
		VolumeMaxSeries                      func(childComplexity int) int
	}

	MatchPolicyAttribute struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	MimirLimits struct {
		AcceptHASamples                               func(childComplexity int) int
		ActiveSeriesCustomTrackersConfig              func(childComplexity int) int
		AlertmanagerMaxAlertsCount                    func(childComplexity int) int
		AlertmanagerMaxAlertsSizeBytes                func(childComplexity int) int
		AlertmanagerMaxConfigSizeBytes                func(childComplexity int) int
		AlertmanagerMaxDispatcherAggregationGroups    func(childComplexity int) int
		AlertmanagerMaxTemplateSizeBytes              func(childComplexity int) int
		AlertmanagerMaxTemplatesCount                 func(childComplexity int) int
		AlertmanagerReceiversBlockCIDRNetworks        func(childComplexity int) int
		AlertmanagerReceiversBlockPrivateAddresses    func(childComplexity int) int
		CardinalityAnalysisEnabled                    func(childComplexity int) int
		CompactorBlockUploadEnabled                   func(childComplexity int) int
		CompactorBlockUploadMaxBlockSizeBytes         func(childComplexity int) int
		CompactorBlockUploadValidationEnabled         func(childComplexity int) int
		CompactorBlockUploadVerifyChunks              func(childComplexity int) int
		CompactorBlocksRetentionPeriod                func(childComplexity int) int
		CompactorPartialBlockDeletionDelay            func(childComplexity int) int
		CompactorSplitAndMergeShards                  func(childComplexity int) int
		CompactorSplitGroups                          func(childComplexity int) int
		CompactorTenantShardSize                      func(childComplexity int) int
		CreationGracePeriod                           func(childComplexity int) int
		DropLabels                                    func(childComplexity int) int
		EnforceMetadataMetricName                     func(childComplexity int) int
		HAClusterLabel                                func(childComplexity int) int
		HAMaxClusters                                 func(childComplexity int) int
		HAReplicaLabel                                func(childComplexity int) int
		IngestionBurstSize                            func(childComplexity int) int
		IngestionRate                                 func(childComplexity int) int
		IngestionTenantShardSize                      func(childComplexity int) int
		LabelNamesAndValuesResultsMaxSizeBytes        func(childComplexity int) int
		LabelValuesMaxCardinalityLabelNamesPerRequest func(childComplexity int) int
		MaxCacheFreshness                             func(childComplexity int) int
		MaxChunksPerQuery                             func(childComplexity int) int
		MaxFetchedChunkBytesPerQuery                  func(childComplexity int) int
		MaxFetchedSeriesPerQuery                      func(childComplexity int) int
		MaxGlobalExemplarsPerUser                     func(childComplexity int) int
		MaxGlobalMetadataPerMetric                    func(childComplexity int) int
		MaxGlobalMetricsWithMetadataPerUser           func(childComplexity int) int
		MaxGlobalSeriesPerMetric                      func(childComplexity int) int
		MaxGlobalSeriesPerUser                        func(childComplexity int) int
		MaxLabelNameLength                            func(childComplexity int) int
		MaxLabelNamesPerSeries                        func(childComplexity int) int
		MaxLabelValueLength                           func(childComplexity int) int
		MaxLabelsQueryLength                          func(childComplexity int) int
		MaxMetadataLength                             func(childComplexity int) int
		MaxNativeHistogramBuckets                     func(childComplexity int) int
		MaxPartialQueryLength                         func(childComplexity int) int
		MaxQueriersPerTenant                          func(childComplexity int) int
		MaxQueryExpressionSizeBytes                   func(childComplexity int) int
		MaxQueryLookback                              func(childComplexity int) int
		MaxQueryParallelism                           func(childComplexity int) int
		MaxTotalQueryLength                           func(childComplexity int) int
		MetricRelabelConfigs                          func(childComplexity int) int
		NativeHistogramsIngestionEnabled              func(childComplexity int) int
		NotificationRateLimit                         func(childComplexity int) int
		NotificationRateLimitPerIntegration           func(childComplexity int) int
		OutOfOrderBlocksExternalLabelEnabled          func(childComplexity int) int
		OutOfOrderTimeWindow                          func(childComplexity int) int
		QueryIngestersWithin                          func(childComplexity int) int
		QueryShardingMaxRegexpSizeBytes               func(childComplexity int) int
		QueryShardingMaxShardedQueries                func(childComplexity int) int
		QueryShardingTotalShards                      func(childComplexity int) int
		RequestBurstSize                              func(childComplexity int) int
		RequestRate                                   func(childComplexity int) int
		ResultsCacheForUnalignedQueryEnabled          func(childComplexity int) int
		ResultsCacheTTL                               func(childComplexity int) int
		ResultsCacheTTLForCardinalityQuery            func(childComplexity int) int
		ResultsCacheTTLForLabelsQuery                 func(childComplexity int) int
		ResultsCacheTTLForOutOfOrderTimeWindow        func(childComplexity int) int
		RulerAlertingRulesEvaluationEnabled           func(childComplexity int) int
		RulerEvaluationDelay                          func(childComplexity int) int
		RulerMaxRuleGroupsPerTenant                   func(childComplexity int) int
		RulerMaxRulesPerRuleGroup                     func(childComplexity int) int
		RulerRecordingRulesEvaluationEnabled          func(childComplexity int) int
		RulerSyncRulesOnChangesEnabled                func(childComplexity int) int
		RulerTenantShardSize                          func(childComplexity int) int
		S3SSEKMSEncryptionContext                     func(childComplexity int) int
		S3SSEKMSKeyID                                 func(childComplexity int) int
		S3SSEType                                     func(childComplexity int) int
		SeparateMetricsGroupLabel                     func(childComplexity int) int
		SplitInstantQueriesByInterval                 func(childComplexity int) int
		StoreGatewayTenantShardSize                   func(childComplexity int) int
	}

	Mutation struct {
		AcceptOAuth2ConsentRequest func(childComplexity int, challenge string, grantAccessTokenAudience []string, grantScope []string, remember *bool, rememberFor *int64) int
		AcceptOAuth2LoginRequest   func(childComplexity int, challenge string, acr *string, amr []string, context map[string]interface{}, remember *bool, rememberFor *int64, subject string) int
		CreateOAuth2Client         func(childComplexity int, allowedCorsOrigins []string, audience []string, authorizationCodeGrantAccessTokenLifespan *string, authorizationCodeGrantIDTokenLifespan *string, authorizationCodeGrantRefreshTokenLifespan *string, backChannelLogoutSessionRequired *bool, backChannelLogoutURI *string, clientCredentialsGrantAccessTokenLifespan *string, clientName *string, clientSecret *string, clientSecretExpiresAt *int64, clientURI *string, contacts []string, frontchannelLogoutSessionRequired *bool, frontchannelLogoutURI *string, grantTypes []string, implicitGrantAccessTokenLifespan *string, implicitGrantIDTokenLifespan *string, jwks map[string]interface{}, jwksURI *string, jwtBearerGrantAccessTokenLifespan *string, logoURI *string, metadata map[string]interface{}, policyURI *string, postLogoutRedirectUris []string, redirectUris []string, responseTypes []string, scope *string, sectorIdentifierURI *string, subjectType *string, tokenEndpointAuthMethod *string, tokenEndpointAuthSigningAlgorithm *string, tosURI *string, userinfoSignedResponseAlgorithm *string, loginBindings *model.LoginBindingsInput) int
		CreateObservabilityTenant  func(childComplexity int, id string, name *string, admins *model.ObservabilityTenantPermissionBindingsInput, metricsReaders *model.ObservabilityTenantPermissionBindingsInput, metricsWriters *model.ObservabilityTenantPermissionBindingsInput, metricsDeleters *model.ObservabilityTenantPermissionBindingsInput, metricsRulesReaders *model.ObservabilityTenantPermissionBindingsInput, metricsRulesWriters *model.ObservabilityTenantPermissionBindingsInput, metricsRulesDeleters *model.ObservabilityTenantPermissionBindingsInput, metricsAlertsReaders *model.ObservabilityTenantPermissionBindingsInput, metricsAlertsWriters *model.ObservabilityTenantPermissionBindingsInput, logsReaders *model.ObservabilityTenantPermissionBindingsInput, logsWriters *model.ObservabilityTenantPermissionBindingsInput, logsDeleters *model.ObservabilityTenantPermissionBindingsInput, logsRulesReaders *model.ObservabilityTenantPermissionBindingsInput, logsRulesWriters *model.ObservabilityTenantPermissionBindingsInput, logsRulesDeleters *model.ObservabilityTenantPermissionBindingsInput, tracesReaders *model.ObservabilityTenantPermissionBindingsInput, tracesWriters *model.ObservabilityTenantPermissionBindingsInput, limits *model.ObservabilityTenantLimitsInput) int
		CreateUser                 func(childComplexity int, email string, name *model.NameInput) int
		DeleteGroup                func(childComplexity int, name string) int
		DeleteOAuth2Client         func(childComplexity int, clientID string) int
		DeleteObservabilityTenant  func(childComplexity int, id string) int
		DeleteUser                 func(childComplexity int, id string) int
		Group                      func(childComplexity int, name string, members []*model.UserInput) int
		Organization               func(childComplexity int, admins []*model.UserInput) int
		RejectOAuth2ConsentRequest func(childComplexity int, challenge string) int
		RejectOAuth2LoginRequest   func(childComplexity int, challenge string) int
		UpdateOAuth2Client         func(childComplexity int, allowedCorsOrigins []string, audience []string, authorizationCodeGrantAccessTokenLifespan *string, authorizationCodeGrantIDTokenLifespan *string, authorizationCodeGrantRefreshTokenLifespan *string, backChannelLogoutSessionRequired *bool, backChannelLogoutURI *string, clientCredentialsGrantAccessTokenLifespan *string, clientID string, clientName *string, clientSecret *string, clientSecretExpiresAt *int64, clientURI *string, contacts []string, frontchannelLogoutSessionRequired *bool, frontchannelLogoutURI *string, grantTypes []string, implicitGrantAccessTokenLifespan *string, implicitGrantIDTokenLifespan *string, jwks map[string]interface{}, jwksURI *string, jwtBearerGrantAccessTokenLifespan *string, logoURI *string, metadata map[string]interface{}, policyURI *string, postLogoutRedirectUris []string, redirectUris []string, responseTypes []string, scope *string, sectorIdentifierURI *string, subjectType *string, tokenEndpointAuthMethod *string, tokenEndpointAuthSigningAlgorithm *string, tosURI *string, userinfoSignedResponseAlgorithm *string, loginBindings *model.LoginBindingsInput) int
		UpdateObservabilityTenant  func(childComplexity int, id string, name *string, admins *model.ObservabilityTenantPermissionBindingsInput, metricsReaders *model.ObservabilityTenantPermissionBindingsInput, metricsWriters *model.ObservabilityTenantPermissionBindingsInput, metricsDeleters *model.ObservabilityTenantPermissionBindingsInput, metricsRulesReaders *model.ObservabilityTenantPermissionBindingsInput, metricsRulesWriters *model.ObservabilityTenantPermissionBindingsInput, metricsRulesDeleters *model.ObservabilityTenantPermissionBindingsInput, metricsAlertsReaders *model.ObservabilityTenantPermissionBindingsInput, metricsAlertsWriters *model.ObservabilityTenantPermissionBindingsInput, logsReaders *model.ObservabilityTenantPermissionBindingsInput, logsWriters *model.ObservabilityTenantPermissionBindingsInput, logsDeleters *model.ObservabilityTenantPermissionBindingsInput, logsRulesReaders *model.ObservabilityTenantPermissionBindingsInput, logsRulesWriters *model.ObservabilityTenantPermissionBindingsInput, logsRulesDeleters *model.ObservabilityTenantPermissionBindingsInput, tracesReaders *model.ObservabilityTenantPermissionBindingsInput, tracesWriters *model.ObservabilityTenantPermissionBindingsInput, limits *model.ObservabilityTenantLimitsInput) int
	}

	Name struct {
		First func(childComplexity int) int
		Last  func(childComplexity int) int
	}

	NotifierBasicAuth struct {
		Password func(childComplexity int) int
		Username func(childComplexity int) int
	}

	NotifierConfig struct {
		BasicAuth  func(childComplexity int) int
		HeaderAuth func(childComplexity int) int
		TLS        func(childComplexity int) int
	}

	NotifierHeaderAuth struct {
		Credentials     func(childComplexity int) int
		CredentialsFile func(childComplexity int) int
		Type            func(childComplexity int) int
	}

	NotifierTLSClientConfig struct {
		CAPath             func(childComplexity int) int
		CertPath           func(childComplexity int) int
		CipherSuites       func(childComplexity int) int
		InsecureSkipVerify func(childComplexity int) int
		KeyPath            func(childComplexity int) int
		MinVersion         func(childComplexity int) int
		ServerName         func(childComplexity int) int
	}

	OAuth2Client struct {
		AllowedCorsOrigins                         func(childComplexity int) int
		Audience                                   func(childComplexity int) int
		AuthorizationCodeGrantAccessTokenLifespan  func(childComplexity int) int
		AuthorizationCodeGrantIDTokenLifespan      func(childComplexity int) int
		AuthorizationCodeGrantRefreshTokenLifespan func(childComplexity int) int
		BackChannelLogoutSessionRequired           func(childComplexity int) int
		BackChannelLogoutURI                       func(childComplexity int) int
		ClientCredentialsGrantAccessTokenLifespan  func(childComplexity int) int
		ClientID                                   func(childComplexity int) int
		ClientName                                 func(childComplexity int) int
		ClientSecret                               func(childComplexity int) int
		ClientSecretExpiresAt                      func(childComplexity int) int
		ClientURI                                  func(childComplexity int) int
		Contacts                                   func(childComplexity int) int
		CreatedAt                                  func(childComplexity int) int
		FrontchannelLogoutSessionRequired          func(childComplexity int) int
		FrontchannelLogoutURI                      func(childComplexity int) int
		GrantTypes                                 func(childComplexity int) int
		ImplicitGrantAccessTokenLifespan           func(childComplexity int) int
		ImplicitGrantIDTokenLifespan               func(childComplexity int) int
		Jwks                                       func(childComplexity int) int
		JwksURI                                    func(childComplexity int) int
		JwtBearerGrantAccessTokenLifespan          func(childComplexity int) int
		LoginBindings                              func(childComplexity int) int
		LogoURI                                    func(childComplexity int) int
		Metadata                                   func(childComplexity int) int
		Owner                                      func(childComplexity int) int
		PolicyURI                                  func(childComplexity int) int
		PostLogoutRedirectUris                     func(childComplexity int) int
		RedirectUris                               func(childComplexity int) int
		ResponseTypes                              func(childComplexity int) int
		Scope                                      func(childComplexity int) int
		SectorIdentifierURI                        func(childComplexity int) int
		SubjectType                                func(childComplexity int) int
		TokenEndpointAuthMethod                    func(childComplexity int) int
		TokenEndpointAuthSigningAlgorithm          func(childComplexity int) int
		TosURI                                     func(childComplexity int) int
		UpdatedAt                                  func(childComplexity int) int
		UserinfoSignedResponseAlgorithm            func(childComplexity int) int
	}

	OAuth2ConsentRequest struct {
		Acr                          func(childComplexity int) int
		Amr                          func(childComplexity int) int
		Challenge                    func(childComplexity int) int
		Client                       func(childComplexity int) int
		Context                      func(childComplexity int) int
		LoginChallenge               func(childComplexity int) int
		LoginSessionID               func(childComplexity int) int
		OidcContext                  func(childComplexity int) int
		RedirectTo                   func(childComplexity int) int
		RequestURL                   func(childComplexity int) int
		RequestedAccessTokenAudience func(childComplexity int) int
		RequestedScope               func(childComplexity int) int
		Skip                         func(childComplexity int) int
		Subject                      func(childComplexity int) int
	}

	OAuth2LoginRequest struct {
		Challenge                    func(childComplexity int) int
		Client                       func(childComplexity int) int
		OidcContext                  func(childComplexity int) int
		RedirectTo                   func(childComplexity int) int
		RequestURL                   func(childComplexity int) int
		RequestedAccessTokenAudience func(childComplexity int) int
		RequestedScope               func(childComplexity int) int
		SessionID                    func(childComplexity int) int
		Skip                         func(childComplexity int) int
		Subject                      func(childComplexity int) int
	}

	OAuth2RedirectTo struct {
		RedirectTo func(childComplexity int) int
	}

	ObservabilityTenant struct {
		Admins               func(childComplexity int) int
		DisplayName          func(childComplexity int) int
		ID                   func(childComplexity int) int
		Limits               func(childComplexity int) int
		LogsDeleters         func(childComplexity int) int
		LogsReaders          func(childComplexity int) int
		LogsRulesDeleters    func(childComplexity int) int
		LogsRulesReaders     func(childComplexity int) int
		LogsRulesWriters     func(childComplexity int) int
		LogsWriters          func(childComplexity int) int
		MetricsAlertsReaders func(childComplexity int) int
		MetricsAlertsWriters func(childComplexity int) int
		MetricsDeleters      func(childComplexity int) int
		MetricsReaders       func(childComplexity int) int
		MetricsRulesDeleters func(childComplexity int) int
		MetricsRulesReaders  func(childComplexity int) int
		MetricsRulesWriters  func(childComplexity int) int
		MetricsWriters       func(childComplexity int) int
		TracesReaders        func(childComplexity int) int
		TracesWriters        func(childComplexity int) int
	}

	ObservabilityTenantLimits struct {
		Loki  func(childComplexity int) int
		Mimir func(childComplexity int) int
		Tempo func(childComplexity int) int
	}

	ObservabilityTenantPermissionBindings struct {
		Groups        func(childComplexity int) int
		Oauth2Clients func(childComplexity int) int
		Users         func(childComplexity int) int
	}

	OidcContext struct {
		AcrValues         func(childComplexity int) int
		Display           func(childComplexity int) int
		IDTokenHintClaims func(childComplexity int) int
		LoginHint         func(childComplexity int) int
		UILocales         func(childComplexity int) int
	}

	Organization struct {
		Admins func(childComplexity int) int
	}

	PolicyMatch struct {
		Attributes func(childComplexity int) int
		MatchType  func(childComplexity int) int
	}

	Query struct {
		GetOAuth2Client          func(childComplexity int, clientID string) int
		GetObservabilityTenant   func(childComplexity int, id string) int
		GetUser                  func(childComplexity int, id *string, email *string) int
		ListGroups               func(childComplexity int) int
		ListOAuth2Clients        func(childComplexity int) int
		ListObservabilityTenants func(childComplexity int) int
		ListUsers                func(childComplexity int) int
		Oauth2ConsentRequest     func(childComplexity int, challenge string) int
		Oauth2LoginRequest       func(childComplexity int, challenge string) int
		Organization             func(childComplexity int) int
	}

	RelabelConfig struct {
		Action       func(childComplexity int) int
		Modulus      func(childComplexity int) int
		Regex        func(childComplexity int) int
		Replacement  func(childComplexity int) int
		Separator    func(childComplexity int) int
		SourceLabels func(childComplexity int) int
		TargetLabel  func(childComplexity int) int
	}

	RulerAlertManagerConfig struct {
		AlertRelabelConfigs         func(childComplexity int) int
		AlertmanagerDiscovery       func(childComplexity int) int
		AlertmanagerRefreshInterval func(childComplexity int) int
		AlertmanagerURL             func(childComplexity int) int
		AlertmanangerEnableV2API    func(childComplexity int) int
		NotificationQueueCapacity   func(childComplexity int) int
		NotificationTimeout         func(childComplexity int) int
		Notifier                    func(childComplexity int) int
	}

	ShardstreamsConfig struct {
		DesiredRate    func(childComplexity int) int
		Enabled        func(childComplexity int) int
		LoggingEnabled func(childComplexity int) int
	}

	StreamRetention struct {
		Period   func(childComplexity int) int
		Priority func(childComplexity int) int
		Selector func(childComplexity int) int
	}

	TempoLimits struct {
		BlockRetention                                                 func(childComplexity int) int
		Forwarders                                                     func(childComplexity int) int
		IngestionBurstSizeBytes                                        func(childComplexity int) int
		IngestionRateLimitBytes                                        func(childComplexity int) int
		IngestionRateStrategy                                          func(childComplexity int) int
		MaxBlocksPerTagValuesQuery                                     func(childComplexity int) int
		MaxBytesPerTagValuesQuery                                      func(childComplexity int) int
		MaxBytesPerTrace                                               func(childComplexity int) int
		MaxGlobalTracesPerUser                                         func(childComplexity int) int
		MaxLocalTracesPerUser                                          func(childComplexity int) int
		MaxSearchDuration                                              func(childComplexity int) int
		MetricsGeneratorCollectionInterval                             func(childComplexity int) int
		MetricsGeneratorDisableCollection                              func(childComplexity int) int
		MetricsGeneratorForwarderQueueSize                             func(childComplexity int) int
		MetricsGeneratorForwarderWorkers                               func(childComplexity int) int
		MetricsGeneratorMaxActiveSeries                                func(childComplexity int) int
		MetricsGeneratorProcessorLocalBlocksCompleteBlockTimeout       func(childComplexity int) int
		MetricsGeneratorProcessorLocalBlocksFlushCheckPeriod           func(childComplexity int) int
		MetricsGeneratorProcessorLocalBlocksMaxBlockBytes              func(childComplexity int) int
		MetricsGeneratorProcessorLocalBlocksMaxBlockDuration           func(childComplexity int) int
		MetricsGeneratorProcessorLocalBlocksMaxLiveTraces              func(childComplexity int) int
		MetricsGeneratorProcessorLocalBlocksTraceIdlePeriod            func(childComplexity int) int
		MetricsGeneratorProcessorServiceGraphsDimensions               func(childComplexity int) int
		MetricsGeneratorProcessorServiceGraphsEnableClientServerPrefix func(childComplexity int) int
		MetricsGeneratorProcessorServiceGraphsHistogramBuckets         func(childComplexity int) int
		MetricsGeneratorProcessorServiceGraphsPeerAttributes           func(childComplexity int) int
		MetricsGeneratorProcessorSpanMetricsDimensionMappings          func(childComplexity int) int
		MetricsGeneratorProcessorSpanMetricsDimensions                 func(childComplexity int) int
		MetricsGeneratorProcessorSpanMetricsEnableTargetInfo           func(childComplexity int) int
		MetricsGeneratorProcessorSpanMetricsFilterPolicies             func(childComplexity int) int
		MetricsGeneratorProcessorSpanMetricsHistogramBuckets           func(childComplexity int) int
		MetricsGeneratorProcessorSpanMetricsIntrinsicDimensions        func(childComplexity int) int
		MetricsGeneratorProcessors                                     func(childComplexity int) int
		MetricsGeneratorRingSize                                       func(childComplexity int) int
	}

	User struct {
		Email        func(childComplexity int) int
		Groups       func(childComplexity int) int
		ID           func(childComplexity int) int
		Name         func(childComplexity int) int
		RecoveryLink func(childComplexity int) int
	}
}

type BlockedQueryResolver interface {
	Types(ctx context.Context, obj *v1alpha1.BlockedQuery) ([]model.BlockedQueryType, error)
}
type GroupResolver interface {
	Members(ctx context.Context, obj *model.Group) ([]*model.User, error)
}
type LoginBindingsResolver interface {
	Users(ctx context.Context, obj *model.LoginBindings) ([]*model.User, error)
	Groups(ctx context.Context, obj *model.LoginBindings) ([]*model.Group, error)
}
type MatchPolicyAttributeResolver interface {
	Value(ctx context.Context, obj *v1alpha1.MatchPolicyAttribute) (map[string]interface{}, error)
}
type MutationResolver interface {
	CreateUser(ctx context.Context, email string, name *model.NameInput) (*model.User, error)
	DeleteUser(ctx context.Context, id string) (*model.User, error)
	Group(ctx context.Context, name string, members []*model.UserInput) (*model.Group, error)
	DeleteGroup(ctx context.Context, name string) (*model.Group, error)
	CreateOAuth2Client(ctx context.Context, allowedCorsOrigins []string, audience []string, authorizationCodeGrantAccessTokenLifespan *string, authorizationCodeGrantIDTokenLifespan *string, authorizationCodeGrantRefreshTokenLifespan *string, backChannelLogoutSessionRequired *bool, backChannelLogoutURI *string, clientCredentialsGrantAccessTokenLifespan *string, clientName *string, clientSecret *string, clientSecretExpiresAt *int64, clientURI *string, contacts []string, frontchannelLogoutSessionRequired *bool, frontchannelLogoutURI *string, grantTypes []string, implicitGrantAccessTokenLifespan *string, implicitGrantIDTokenLifespan *string, jwks map[string]interface{}, jwksURI *string, jwtBearerGrantAccessTokenLifespan *string, logoURI *string, metadata map[string]interface{}, policyURI *string, postLogoutRedirectUris []string, redirectUris []string, responseTypes []string, scope *string, sectorIdentifierURI *string, subjectType *string, tokenEndpointAuthMethod *string, tokenEndpointAuthSigningAlgorithm *string, tosURI *string, userinfoSignedResponseAlgorithm *string, loginBindings *model.LoginBindingsInput) (*model.OAuth2Client, error)
	UpdateOAuth2Client(ctx context.Context, allowedCorsOrigins []string, audience []string, authorizationCodeGrantAccessTokenLifespan *string, authorizationCodeGrantIDTokenLifespan *string, authorizationCodeGrantRefreshTokenLifespan *string, backChannelLogoutSessionRequired *bool, backChannelLogoutURI *string, clientCredentialsGrantAccessTokenLifespan *string, clientID string, clientName *string, clientSecret *string, clientSecretExpiresAt *int64, clientURI *string, contacts []string, frontchannelLogoutSessionRequired *bool, frontchannelLogoutURI *string, grantTypes []string, implicitGrantAccessTokenLifespan *string, implicitGrantIDTokenLifespan *string, jwks map[string]interface{}, jwksURI *string, jwtBearerGrantAccessTokenLifespan *string, logoURI *string, metadata map[string]interface{}, policyURI *string, postLogoutRedirectUris []string, redirectUris []string, responseTypes []string, scope *string, sectorIdentifierURI *string, subjectType *string, tokenEndpointAuthMethod *string, tokenEndpointAuthSigningAlgorithm *string, tosURI *string, userinfoSignedResponseAlgorithm *string, loginBindings *model.LoginBindingsInput) (*model.OAuth2Client, error)
	DeleteOAuth2Client(ctx context.Context, clientID string) (*model.OAuth2Client, error)
	AcceptOAuth2ConsentRequest(ctx context.Context, challenge string, grantAccessTokenAudience []string, grantScope []string, remember *bool, rememberFor *int64) (*model.OAuth2RedirectTo, error)
	RejectOAuth2ConsentRequest(ctx context.Context, challenge string) (*model.OAuth2RedirectTo, error)
	AcceptOAuth2LoginRequest(ctx context.Context, challenge string, acr *string, amr []string, context map[string]interface{}, remember *bool, rememberFor *int64, subject string) (*model.OAuth2RedirectTo, error)
	RejectOAuth2LoginRequest(ctx context.Context, challenge string) (*model.OAuth2RedirectTo, error)
	CreateObservabilityTenant(ctx context.Context, id string, name *string, admins *model.ObservabilityTenantPermissionBindingsInput, metricsReaders *model.ObservabilityTenantPermissionBindingsInput, metricsWriters *model.ObservabilityTenantPermissionBindingsInput, metricsDeleters *model.ObservabilityTenantPermissionBindingsInput, metricsRulesReaders *model.ObservabilityTenantPermissionBindingsInput, metricsRulesWriters *model.ObservabilityTenantPermissionBindingsInput, metricsRulesDeleters *model.ObservabilityTenantPermissionBindingsInput, metricsAlertsReaders *model.ObservabilityTenantPermissionBindingsInput, metricsAlertsWriters *model.ObservabilityTenantPermissionBindingsInput, logsReaders *model.ObservabilityTenantPermissionBindingsInput, logsWriters *model.ObservabilityTenantPermissionBindingsInput, logsDeleters *model.ObservabilityTenantPermissionBindingsInput, logsRulesReaders *model.ObservabilityTenantPermissionBindingsInput, logsRulesWriters *model.ObservabilityTenantPermissionBindingsInput, logsRulesDeleters *model.ObservabilityTenantPermissionBindingsInput, tracesReaders *model.ObservabilityTenantPermissionBindingsInput, tracesWriters *model.ObservabilityTenantPermissionBindingsInput, limits *model.ObservabilityTenantLimitsInput) (*model.ObservabilityTenant, error)
	UpdateObservabilityTenant(ctx context.Context, id string, name *string, admins *model.ObservabilityTenantPermissionBindingsInput, metricsReaders *model.ObservabilityTenantPermissionBindingsInput, metricsWriters *model.ObservabilityTenantPermissionBindingsInput, metricsDeleters *model.ObservabilityTenantPermissionBindingsInput, metricsRulesReaders *model.ObservabilityTenantPermissionBindingsInput, metricsRulesWriters *model.ObservabilityTenantPermissionBindingsInput, metricsRulesDeleters *model.ObservabilityTenantPermissionBindingsInput, metricsAlertsReaders *model.ObservabilityTenantPermissionBindingsInput, metricsAlertsWriters *model.ObservabilityTenantPermissionBindingsInput, logsReaders *model.ObservabilityTenantPermissionBindingsInput, logsWriters *model.ObservabilityTenantPermissionBindingsInput, logsDeleters *model.ObservabilityTenantPermissionBindingsInput, logsRulesReaders *model.ObservabilityTenantPermissionBindingsInput, logsRulesWriters *model.ObservabilityTenantPermissionBindingsInput, logsRulesDeleters *model.ObservabilityTenantPermissionBindingsInput, tracesReaders *model.ObservabilityTenantPermissionBindingsInput, tracesWriters *model.ObservabilityTenantPermissionBindingsInput, limits *model.ObservabilityTenantLimitsInput) (*model.ObservabilityTenant, error)
	DeleteObservabilityTenant(ctx context.Context, id string) (*model.ObservabilityTenant, error)
	Organization(ctx context.Context, admins []*model.UserInput) (*model.Organization, error)
}
type OAuth2ClientResolver interface {
	Owner(ctx context.Context, obj *model.OAuth2Client) (*string, error)

	LoginBindings(ctx context.Context, obj *model.OAuth2Client) (*model.LoginBindings, error)
}
type ObservabilityTenantResolver interface {
	Admins(ctx context.Context, obj *model.ObservabilityTenant) (*model.ObservabilityTenantPermissionBindings, error)
	MetricsReaders(ctx context.Context, obj *model.ObservabilityTenant) (*model.ObservabilityTenantPermissionBindings, error)
	MetricsWriters(ctx context.Context, obj *model.ObservabilityTenant) (*model.ObservabilityTenantPermissionBindings, error)
	MetricsDeleters(ctx context.Context, obj *model.ObservabilityTenant) (*model.ObservabilityTenantPermissionBindings, error)
	MetricsRulesReaders(ctx context.Context, obj *model.ObservabilityTenant) (*model.ObservabilityTenantPermissionBindings, error)
	MetricsRulesWriters(ctx context.Context, obj *model.ObservabilityTenant) (*model.ObservabilityTenantPermissionBindings, error)
	MetricsRulesDeleters(ctx context.Context, obj *model.ObservabilityTenant) (*model.ObservabilityTenantPermissionBindings, error)
	MetricsAlertsReaders(ctx context.Context, obj *model.ObservabilityTenant) (*model.ObservabilityTenantPermissionBindings, error)
	MetricsAlertsWriters(ctx context.Context, obj *model.ObservabilityTenant) (*model.ObservabilityTenantPermissionBindings, error)
	LogsReaders(ctx context.Context, obj *model.ObservabilityTenant) (*model.ObservabilityTenantPermissionBindings, error)
	LogsWriters(ctx context.Context, obj *model.ObservabilityTenant) (*model.ObservabilityTenantPermissionBindings, error)
	LogsDeleters(ctx context.Context, obj *model.ObservabilityTenant) (*model.ObservabilityTenantPermissionBindings, error)
	LogsRulesReaders(ctx context.Context, obj *model.ObservabilityTenant) (*model.ObservabilityTenantPermissionBindings, error)
	LogsRulesWriters(ctx context.Context, obj *model.ObservabilityTenant) (*model.ObservabilityTenantPermissionBindings, error)
	LogsRulesDeleters(ctx context.Context, obj *model.ObservabilityTenant) (*model.ObservabilityTenantPermissionBindings, error)
	TracesReaders(ctx context.Context, obj *model.ObservabilityTenant) (*model.ObservabilityTenantPermissionBindings, error)
	TracesWriters(ctx context.Context, obj *model.ObservabilityTenant) (*model.ObservabilityTenantPermissionBindings, error)
}
type ObservabilityTenantPermissionBindingsResolver interface {
	Users(ctx context.Context, obj *model.ObservabilityTenantPermissionBindings) ([]*model.User, error)
	Groups(ctx context.Context, obj *model.ObservabilityTenantPermissionBindings) ([]*model.Group, error)
	Oauth2Clients(ctx context.Context, obj *model.ObservabilityTenantPermissionBindings) ([]*model.OAuth2Client, error)
}
type OrganizationResolver interface {
	Admins(ctx context.Context, obj *model.Organization) ([]*model.User, error)
}
type QueryResolver interface {
	ListUsers(ctx context.Context) ([]*model.User, error)
	GetUser(ctx context.Context, id *string, email *string) (*model.User, error)
	ListGroups(ctx context.Context) ([]*model.Group, error)
	ListOAuth2Clients(ctx context.Context) ([]*model.OAuth2Client, error)
	GetOAuth2Client(ctx context.Context, clientID string) (*model.OAuth2Client, error)
	Oauth2ConsentRequest(ctx context.Context, challenge string) (*model.OAuth2ConsentRequest, error)
	Oauth2LoginRequest(ctx context.Context, challenge string) (*model.OAuth2LoginRequest, error)
	ListObservabilityTenants(ctx context.Context) ([]*model.ObservabilityTenant, error)
	GetObservabilityTenant(ctx context.Context, id string) (*model.ObservabilityTenant, error)
	Organization(ctx context.Context) (*model.Organization, error)
}
type RelabelConfigResolver interface {
	SourceLabels(ctx context.Context, obj *v1alpha1.RelabelConfig) ([]*string, error)

	Action(ctx context.Context, obj *v1alpha1.RelabelConfig) (*model.RelabelAction, error)
}
type UserResolver interface {
	Groups(ctx context.Context, obj *model.User) ([]*model.Group, error)
}

type LokiLimitsInputResolver interface {
	RulerAlertManagerConfig(ctx context.Context, obj *v1alpha1.LokiLimitsInput, data *model.RulerAlertManagerConfigInput) error

	StreamRetention(ctx context.Context, obj *v1alpha1.LokiLimitsInput, data []*model.StreamRetentionInput) error
	ShardStreams(ctx context.Context, obj *v1alpha1.LokiLimitsInput, data *model.ShardstreamsConfigInput) error
	BlockedQueries(ctx context.Context, obj *v1alpha1.LokiLimitsInput, data []*model.BlockedQueryInput) error
}
type MimirLimitsInputResolver interface {
	MetricRelabelConfigs(ctx context.Context, obj *v1alpha1.MimirLimitsInput, data []*model.RelabelConfigInput) error
}
type TempoLimitsInputResolver interface {
	MetricsGeneratorProcessorSpanMetricsFilterPolicies(ctx context.Context, obj *v1alpha1.TempoLimitsInput, data []*model.FilterPolicyInput) error
	MetricsGeneratorProcessorSpanMetricsDimensionMappings(ctx context.Context, obj *v1alpha1.TempoLimitsInput, data []*model.DimensionMappingsInput) error
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "BlockedQuery.hash":
		if e.complexity.BlockedQuery.Hash == nil {
			break
		}

		return e.complexity.BlockedQuery.Hash(childComplexity), true

	case "BlockedQuery.pattern":
		if e.complexity.BlockedQuery.Pattern == nil {
			break
		}

		return e.complexity.BlockedQuery.Pattern(childComplexity), true

	case "BlockedQuery.regex":
		if e.complexity.BlockedQuery.Regex == nil {
			break
		}

		return e.complexity.BlockedQuery.Regex(childComplexity), true

	case "BlockedQuery.types":
		if e.complexity.BlockedQuery.Types == nil {
			break
		}

		return e.complexity.BlockedQuery.Types(childComplexity), true

	case "DimensionMappings.join":
		if e.complexity.DimensionMappings.Join == nil {
			break
		}

		return e.complexity.DimensionMappings.Join(childComplexity), true

	case "DimensionMappings.name":
		if e.complexity.DimensionMappings.Name == nil {
			break
		}

		return e.complexity.DimensionMappings.Name(childComplexity), true

	case "DimensionMappings.sourceLabel":
		if e.complexity.DimensionMappings.SourceLabel == nil {
			break
		}

		return e.complexity.DimensionMappings.SourceLabel(childComplexity), true

	case "FilterPolicy.exclude":
		if e.complexity.FilterPolicy.Exclude == nil {
			break
		}

		return e.complexity.FilterPolicy.Exclude(childComplexity), true

	case "FilterPolicy.include":
		if e.complexity.FilterPolicy.Include == nil {
			break
		}

		return e.complexity.FilterPolicy.Include(childComplexity), true

	case "Group.members":
		if e.complexity.Group.Members == nil {
			break
		}

		return e.complexity.Group.Members(childComplexity), true

	case "Group.name":
		if e.complexity.Group.Name == nil {
			break
		}

		return e.complexity.Group.Name(childComplexity), true

	case "LoginBindings.groups":
		if e.complexity.LoginBindings.Groups == nil {
			break
		}

		return e.complexity.LoginBindings.Groups(childComplexity), true

	case "LoginBindings.users":
		if e.complexity.LoginBindings.Users == nil {
			break
		}

		return e.complexity.LoginBindings.Users(childComplexity), true

	case "LokiLimits.blockedQueries":
		if e.complexity.LokiLimits.BlockedQueries == nil {
			break
		}

		return e.complexity.LokiLimits.BlockedQueries(childComplexity), true

	case "LokiLimits.cardinalityLimit":
		if e.complexity.LokiLimits.CardinalityLimit == nil {
			break
		}

		return e.complexity.LokiLimits.CardinalityLimit(childComplexity), true

	case "LokiLimits.creationGracePeriod":
		if e.complexity.LokiLimits.CreationGracePeriod == nil {
			break
		}

		return e.complexity.LokiLimits.CreationGracePeriod(childComplexity), true

	case "LokiLimits.deletionMode":
		if e.complexity.LokiLimits.DeletionMode == nil {
			break
		}

		return e.complexity.LokiLimits.DeletionMode(childComplexity), true

	case "LokiLimits.enforceMetricName":
		if e.complexity.LokiLimits.EnforceMetricName == nil {
			break
		}

		return e.complexity.LokiLimits.EnforceMetricName(childComplexity), true

	case "LokiLimits.incrementDuplicateTimestamp":
		if e.complexity.LokiLimits.IncrementDuplicateTimestamp == nil {
			break
		}

		return e.complexity.LokiLimits.IncrementDuplicateTimestamp(childComplexity), true

	case "LokiLimits.indexGatewayShardSize":
		if e.complexity.LokiLimits.IndexGatewayShardSize == nil {
			break
		}

		return e.complexity.LokiLimits.IndexGatewayShardSize(childComplexity), true

	case "LokiLimits.ingestionBurstSizeMB":
		if e.complexity.LokiLimits.IngestionBurstSizeMB == nil {
			break
		}

		return e.complexity.LokiLimits.IngestionBurstSizeMB(childComplexity), true

	case "LokiLimits.ingestionRateMB":
		if e.complexity.LokiLimits.IngestionRateMB == nil {
			break
		}

		return e.complexity.LokiLimits.IngestionRateMB(childComplexity), true

	case "LokiLimits.ingestionRateStrategy":
		if e.complexity.LokiLimits.IngestionRateStrategy == nil {
			break
		}

		return e.complexity.LokiLimits.IngestionRateStrategy(childComplexity), true

	case "LokiLimits.maxCacheFreshness":
		if e.complexity.LokiLimits.MaxCacheFreshness == nil {
			break
		}

		return e.complexity.LokiLimits.MaxCacheFreshness(childComplexity), true

	case "LokiLimits.maxChunksPerQuery":
		if e.complexity.LokiLimits.MaxChunksPerQuery == nil {
			break
		}

		return e.complexity.LokiLimits.MaxChunksPerQuery(childComplexity), true

	case "LokiLimits.maxConcurrentTailRequests":
		if e.complexity.LokiLimits.MaxConcurrentTailRequests == nil {
			break
		}

		return e.complexity.LokiLimits.MaxConcurrentTailRequests(childComplexity), true

	case "LokiLimits.maxEntriesLimitPerQuery":
		if e.complexity.LokiLimits.MaxEntriesLimitPerQuery == nil {
			break
		}

		return e.complexity.LokiLimits.MaxEntriesLimitPerQuery(childComplexity), true

	case "LokiLimits.maxGlobalStreamsPerUser":
		if e.complexity.LokiLimits.MaxGlobalStreamsPerUser == nil {
			break
		}

		return e.complexity.LokiLimits.MaxGlobalStreamsPerUser(childComplexity), true

	case "LokiLimits.maxLabelNameLength":
		if e.complexity.LokiLimits.MaxLabelNameLength == nil {
			break
		}

		return e.complexity.LokiLimits.MaxLabelNameLength(childComplexity), true

	case "LokiLimits.maxLabelNamesPerSeries":
		if e.complexity.LokiLimits.MaxLabelNamesPerSeries == nil {
			break
		}

		return e.complexity.LokiLimits.MaxLabelNamesPerSeries(childComplexity), true

	case "LokiLimits.maxLabelValueLength":
		if e.complexity.LokiLimits.MaxLabelValueLength == nil {
			break
		}

		return e.complexity.LokiLimits.MaxLabelValueLength(childComplexity), true

	case "LokiLimits.maxLineSize":
		if e.complexity.LokiLimits.MaxLineSize == nil {
			break
		}

		return e.complexity.LokiLimits.MaxLineSize(childComplexity), true

	case "LokiLimits.maxLineSizeTruncate":
		if e.complexity.LokiLimits.MaxLineSizeTruncate == nil {
			break
		}

		return e.complexity.LokiLimits.MaxLineSizeTruncate(childComplexity), true

	case "LokiLimits.maxLocalStreamsPerUser":
		if e.complexity.LokiLimits.MaxLocalStreamsPerUser == nil {
			break
		}

		return e.complexity.LokiLimits.MaxLocalStreamsPerUser(childComplexity), true

	case "LokiLimits.maxQuerierBytesRead":
		if e.complexity.LokiLimits.MaxQuerierBytesRead == nil {
			break
		}

		return e.complexity.LokiLimits.MaxQuerierBytesRead(childComplexity), true

	case "LokiLimits.maxQueriersPerTenant":
		if e.complexity.LokiLimits.MaxQueriersPerTenant == nil {
			break
		}

		return e.complexity.LokiLimits.MaxQueriersPerTenant(childComplexity), true

	case "LokiLimits.maxQueryBytesRead":
		if e.complexity.LokiLimits.MaxQueryBytesRead == nil {
			break
		}

		return e.complexity.LokiLimits.MaxQueryBytesRead(childComplexity), true

	case "LokiLimits.maxQueryLength":
		if e.complexity.LokiLimits.MaxQueryLength == nil {
			break
		}

		return e.complexity.LokiLimits.MaxQueryLength(childComplexity), true

	case "LokiLimits.maxQueryLookback":
		if e.complexity.LokiLimits.MaxQueryLookback == nil {
			break
		}

		return e.complexity.LokiLimits.MaxQueryLookback(childComplexity), true

	case "LokiLimits.maxQueryParallelism":
		if e.complexity.LokiLimits.MaxQueryParallelism == nil {
			break
		}

		return e.complexity.LokiLimits.MaxQueryParallelism(childComplexity), true

	case "LokiLimits.maxQueryRange":
		if e.complexity.LokiLimits.MaxQueryRange == nil {
			break
		}

		return e.complexity.LokiLimits.MaxQueryRange(childComplexity), true

	case "LokiLimits.maxQuerySeries":
		if e.complexity.LokiLimits.MaxQuerySeries == nil {
			break
		}

		return e.complexity.LokiLimits.MaxQuerySeries(childComplexity), true

	case "LokiLimits.maxStatsCacheFreshness":
		if e.complexity.LokiLimits.MaxStatsCacheFreshness == nil {
			break
		}

		return e.complexity.LokiLimits.MaxStatsCacheFreshness(childComplexity), true

	case "LokiLimits.maxStreamsMatchersPerQuery":
		if e.complexity.LokiLimits.MaxStreamsMatchersPerQuery == nil {
			break
		}

		return e.complexity.LokiLimits.MaxStreamsMatchersPerQuery(childComplexity), true

	case "LokiLimits.minShardingLookback":
		if e.complexity.LokiLimits.MinShardingLookback == nil {
			break
		}

		return e.complexity.LokiLimits.MinShardingLookback(childComplexity), true

	case "LokiLimits.perStreamRateLimit":
		if e.complexity.LokiLimits.PerStreamRateLimit == nil {
			break
		}

		return e.complexity.LokiLimits.PerStreamRateLimit(childComplexity), true

	case "LokiLimits.perStreamRateLimitBurst":
		if e.complexity.LokiLimits.PerStreamRateLimitBurst == nil {
			break
		}

		return e.complexity.LokiLimits.PerStreamRateLimitBurst(childComplexity), true

	case "LokiLimits.queryReadyIndexNumDays":
		if e.complexity.LokiLimits.QueryReadyIndexNumDays == nil {
			break
		}

		return e.complexity.LokiLimits.QueryReadyIndexNumDays(childComplexity), true

	case "LokiLimits.querySplitDuration":
		if e.complexity.LokiLimits.QuerySplitDuration == nil {
			break
		}

		return e.complexity.LokiLimits.QuerySplitDuration(childComplexity), true

	case "LokiLimits.queryTimeout":
		if e.complexity.LokiLimits.QueryTimeout == nil {
			break
		}

		return e.complexity.LokiLimits.QueryTimeout(childComplexity), true

	case "LokiLimits.rejectOldSamples":
		if e.complexity.LokiLimits.RejectOldSamples == nil {
			break
		}

		return e.complexity.LokiLimits.RejectOldSamples(childComplexity), true

	case "LokiLimits.rejectOldSamplesMaxAge":
		if e.complexity.LokiLimits.RejectOldSamplesMaxAge == nil {
			break
		}

		return e.complexity.LokiLimits.RejectOldSamplesMaxAge(childComplexity), true

	case "LokiLimits.requiredLabels":
		if e.complexity.LokiLimits.RequiredLabels == nil {
			break
		}

		return e.complexity.LokiLimits.RequiredLabels(childComplexity), true

	case "LokiLimits.requiredNumberLabels":
		if e.complexity.LokiLimits.RequiredNumberLabels == nil {
			break
		}

		return e.complexity.LokiLimits.RequiredNumberLabels(childComplexity), true

	case "LokiLimits.retentionPeriod":
		if e.complexity.LokiLimits.RetentionPeriod == nil {
			break
		}

		return e.complexity.LokiLimits.RetentionPeriod(childComplexity), true

	case "LokiLimits.rulerAlertManagerConfig":
		if e.complexity.LokiLimits.RulerAlertManagerConfig == nil {
			break
		}

		return e.complexity.LokiLimits.RulerAlertManagerConfig(childComplexity), true

	case "LokiLimits.rulerEvaluationDelay":
		if e.complexity.LokiLimits.RulerEvaluationDelay == nil {
			break
		}

		return e.complexity.LokiLimits.RulerEvaluationDelay(childComplexity), true

	case "LokiLimits.rulerMaxRuleGroupsPerTenant":
		if e.complexity.LokiLimits.RulerMaxRuleGroupsPerTenant == nil {
			break
		}

		return e.complexity.LokiLimits.RulerMaxRuleGroupsPerTenant(childComplexity), true

	case "LokiLimits.rulerMaxRulesPerRuleGroup":
		if e.complexity.LokiLimits.RulerMaxRulesPerRuleGroup == nil {
			break
		}

		return e.complexity.LokiLimits.RulerMaxRulesPerRuleGroup(childComplexity), true

	case "LokiLimits.rulerRemoteEvaluationMaxResponseSize":
		if e.complexity.LokiLimits.RulerRemoteEvaluationMaxResponseSize == nil {
			break
		}

		return e.complexity.LokiLimits.RulerRemoteEvaluationMaxResponseSize(childComplexity), true

	case "LokiLimits.rulerRemoteEvaluationTimeout":
		if e.complexity.LokiLimits.RulerRemoteEvaluationTimeout == nil {
			break
		}

		return e.complexity.LokiLimits.RulerRemoteEvaluationTimeout(childComplexity), true

	case "LokiLimits.rulerRemoteWriteDisabled":
		if e.complexity.LokiLimits.RulerRemoteWriteDisabled == nil {
			break
		}

		return e.complexity.LokiLimits.RulerRemoteWriteDisabled(childComplexity), true

	case "LokiLimits.rulerTenantShardSize":
		if e.complexity.LokiLimits.RulerTenantShardSize == nil {
			break
		}

		return e.complexity.LokiLimits.RulerTenantShardSize(childComplexity), true

	case "LokiLimits.shardStreams":
		if e.complexity.LokiLimits.ShardStreams == nil {
			break
		}

		return e.complexity.LokiLimits.ShardStreams(childComplexity), true

	case "LokiLimits.streamRetention":
		if e.complexity.LokiLimits.StreamRetention == nil {
			break
		}

		return e.complexity.LokiLimits.StreamRetention(childComplexity), true

	case "LokiLimits.tsdbMaxBytesPerShard":
		if e.complexity.LokiLimits.TSDBMaxBytesPerShard == nil {
			break
		}

		return e.complexity.LokiLimits.TSDBMaxBytesPerShard(childComplexity), true

	case "LokiLimits.tsdbMaxQueryParallelism":
		if e.complexity.LokiLimits.TSDBMaxQueryParallelism == nil {
			break
		}

		return e.complexity.LokiLimits.TSDBMaxQueryParallelism(childComplexity), true

	case "LokiLimits.unorderedWrites":
		if e.complexity.LokiLimits.UnorderedWrites == nil {
			break
		}

		return e.complexity.LokiLimits.UnorderedWrites(childComplexity), true

	case "LokiLimits.volumeEnabled":
		if e.complexity.LokiLimits.VolumeEnabled == nil {
			break
		}

		return e.complexity.LokiLimits.VolumeEnabled(childComplexity), true

	case "LokiLimits.volumeMaxSeries":
		if e.complexity.LokiLimits.VolumeMaxSeries == nil {
			break
		}

		return e.complexity.LokiLimits.VolumeMaxSeries(childComplexity), true

	case "MatchPolicyAttribute.key":
		if e.complexity.MatchPolicyAttribute.Key == nil {
			break
		}

		return e.complexity.MatchPolicyAttribute.Key(childComplexity), true

	case "MatchPolicyAttribute.value":
		if e.complexity.MatchPolicyAttribute.Value == nil {
			break
		}

		return e.complexity.MatchPolicyAttribute.Value(childComplexity), true

	case "MimirLimits.acceptHASamples":
		if e.complexity.MimirLimits.AcceptHASamples == nil {
			break
		}

		return e.complexity.MimirLimits.AcceptHASamples(childComplexity), true

	case "MimirLimits.activeSeriesCustomTrackersConfig":
		if e.complexity.MimirLimits.ActiveSeriesCustomTrackersConfig == nil {
			break
		}

		return e.complexity.MimirLimits.ActiveSeriesCustomTrackersConfig(childComplexity), true

	case "MimirLimits.alertmanagerMaxAlertsCount":
		if e.complexity.MimirLimits.AlertmanagerMaxAlertsCount == nil {
			break
		}

		return e.complexity.MimirLimits.AlertmanagerMaxAlertsCount(childComplexity), true

	case "MimirLimits.alertmanagerMaxAlertsSizeBytes":
		if e.complexity.MimirLimits.AlertmanagerMaxAlertsSizeBytes == nil {
			break
		}

		return e.complexity.MimirLimits.AlertmanagerMaxAlertsSizeBytes(childComplexity), true

	case "MimirLimits.alertmanagerMaxConfigSizeBytes":
		if e.complexity.MimirLimits.AlertmanagerMaxConfigSizeBytes == nil {
			break
		}

		return e.complexity.MimirLimits.AlertmanagerMaxConfigSizeBytes(childComplexity), true

	case "MimirLimits.alertmanagerMaxDispatcherAggregationGroups":
		if e.complexity.MimirLimits.AlertmanagerMaxDispatcherAggregationGroups == nil {
			break
		}

		return e.complexity.MimirLimits.AlertmanagerMaxDispatcherAggregationGroups(childComplexity), true

	case "MimirLimits.alertmanagerMaxTemplateSizeBytes":
		if e.complexity.MimirLimits.AlertmanagerMaxTemplateSizeBytes == nil {
			break
		}

		return e.complexity.MimirLimits.AlertmanagerMaxTemplateSizeBytes(childComplexity), true

	case "MimirLimits.alertmanagerMaxTemplatesCount":
		if e.complexity.MimirLimits.AlertmanagerMaxTemplatesCount == nil {
			break
		}

		return e.complexity.MimirLimits.AlertmanagerMaxTemplatesCount(childComplexity), true

	case "MimirLimits.alertmanagerReceiversBlockCIDRNetworks":
		if e.complexity.MimirLimits.AlertmanagerReceiversBlockCIDRNetworks == nil {
			break
		}

		return e.complexity.MimirLimits.AlertmanagerReceiversBlockCIDRNetworks(childComplexity), true

	case "MimirLimits.alertmanagerReceiversBlockPrivateAddresses":
		if e.complexity.MimirLimits.AlertmanagerReceiversBlockPrivateAddresses == nil {
			break
		}

		return e.complexity.MimirLimits.AlertmanagerReceiversBlockPrivateAddresses(childComplexity), true

	case "MimirLimits.cardinalityAnalysisEnabled":
		if e.complexity.MimirLimits.CardinalityAnalysisEnabled == nil {
			break
		}

		return e.complexity.MimirLimits.CardinalityAnalysisEnabled(childComplexity), true

	case "MimirLimits.compactorBlockUploadEnabled":
		if e.complexity.MimirLimits.CompactorBlockUploadEnabled == nil {
			break
		}

		return e.complexity.MimirLimits.CompactorBlockUploadEnabled(childComplexity), true

	case "MimirLimits.compactorBlockUploadMaxBlockSizeBytes":
		if e.complexity.MimirLimits.CompactorBlockUploadMaxBlockSizeBytes == nil {
			break
		}

		return e.complexity.MimirLimits.CompactorBlockUploadMaxBlockSizeBytes(childComplexity), true

	case "MimirLimits.compactorBlockUploadValidationEnabled":
		if e.complexity.MimirLimits.CompactorBlockUploadValidationEnabled == nil {
			break
		}

		return e.complexity.MimirLimits.CompactorBlockUploadValidationEnabled(childComplexity), true

	case "MimirLimits.compactorBlockUploadVerifyChunks":
		if e.complexity.MimirLimits.CompactorBlockUploadVerifyChunks == nil {
			break
		}

		return e.complexity.MimirLimits.CompactorBlockUploadVerifyChunks(childComplexity), true

	case "MimirLimits.compactorBlocksRetentionPeriod":
		if e.complexity.MimirLimits.CompactorBlocksRetentionPeriod == nil {
			break
		}

		return e.complexity.MimirLimits.CompactorBlocksRetentionPeriod(childComplexity), true

	case "MimirLimits.compactorPartialBlockDeletionDelay":
		if e.complexity.MimirLimits.CompactorPartialBlockDeletionDelay == nil {
			break
		}

		return e.complexity.MimirLimits.CompactorPartialBlockDeletionDelay(childComplexity), true

	case "MimirLimits.compactorSplitAndMergeShards":
		if e.complexity.MimirLimits.CompactorSplitAndMergeShards == nil {
			break
		}

		return e.complexity.MimirLimits.CompactorSplitAndMergeShards(childComplexity), true

	case "MimirLimits.compactorSplitGroups":
		if e.complexity.MimirLimits.CompactorSplitGroups == nil {
			break
		}

		return e.complexity.MimirLimits.CompactorSplitGroups(childComplexity), true

	case "MimirLimits.compactorTenantShardSize":
		if e.complexity.MimirLimits.CompactorTenantShardSize == nil {
			break
		}

		return e.complexity.MimirLimits.CompactorTenantShardSize(childComplexity), true

	case "MimirLimits.creationGracePeriod":
		if e.complexity.MimirLimits.CreationGracePeriod == nil {
			break
		}

		return e.complexity.MimirLimits.CreationGracePeriod(childComplexity), true

	case "MimirLimits.dropLabels":
		if e.complexity.MimirLimits.DropLabels == nil {
			break
		}

		return e.complexity.MimirLimits.DropLabels(childComplexity), true

	case "MimirLimits.enforceMetadataMetricName":
		if e.complexity.MimirLimits.EnforceMetadataMetricName == nil {
			break
		}

		return e.complexity.MimirLimits.EnforceMetadataMetricName(childComplexity), true

	case "MimirLimits.haClusterLabel":
		if e.complexity.MimirLimits.HAClusterLabel == nil {
			break
		}

		return e.complexity.MimirLimits.HAClusterLabel(childComplexity), true

	case "MimirLimits.haMaxClusters":
		if e.complexity.MimirLimits.HAMaxClusters == nil {
			break
		}

		return e.complexity.MimirLimits.HAMaxClusters(childComplexity), true

	case "MimirLimits.haReplicaLabel":
		if e.complexity.MimirLimits.HAReplicaLabel == nil {
			break
		}

		return e.complexity.MimirLimits.HAReplicaLabel(childComplexity), true

	case "MimirLimits.ingestionBurstSize":
		if e.complexity.MimirLimits.IngestionBurstSize == nil {
			break
		}

		return e.complexity.MimirLimits.IngestionBurstSize(childComplexity), true

	case "MimirLimits.ingestionRate":
		if e.complexity.MimirLimits.IngestionRate == nil {
			break
		}

		return e.complexity.MimirLimits.IngestionRate(childComplexity), true

	case "MimirLimits.ingestionTenantShardSize":
		if e.complexity.MimirLimits.IngestionTenantShardSize == nil {
			break
		}

		return e.complexity.MimirLimits.IngestionTenantShardSize(childComplexity), true

	case "MimirLimits.labelNamesAndValuesResultsMaxSizeBytes":
		if e.complexity.MimirLimits.LabelNamesAndValuesResultsMaxSizeBytes == nil {
			break
		}

		return e.complexity.MimirLimits.LabelNamesAndValuesResultsMaxSizeBytes(childComplexity), true

	case "MimirLimits.labelValuesMaxCardinalityLabelNamesPerRequest":
		if e.complexity.MimirLimits.LabelValuesMaxCardinalityLabelNamesPerRequest == nil {
			break
		}

		return e.complexity.MimirLimits.LabelValuesMaxCardinalityLabelNamesPerRequest(childComplexity), true

	case "MimirLimits.maxCacheFreshness":
		if e.complexity.MimirLimits.MaxCacheFreshness == nil {
			break
		}

		return e.complexity.MimirLimits.MaxCacheFreshness(childComplexity), true

	case "MimirLimits.maxChunksPerQuery":
		if e.complexity.MimirLimits.MaxChunksPerQuery == nil {
			break
		}

		return e.complexity.MimirLimits.MaxChunksPerQuery(childComplexity), true

	case "MimirLimits.maxFetchedChunkBytesPerQuery":
		if e.complexity.MimirLimits.MaxFetchedChunkBytesPerQuery == nil {
			break
		}

		return e.complexity.MimirLimits.MaxFetchedChunkBytesPerQuery(childComplexity), true

	case "MimirLimits.maxFetchedSeriesPerQuery":
		if e.complexity.MimirLimits.MaxFetchedSeriesPerQuery == nil {
			break
		}

		return e.complexity.MimirLimits.MaxFetchedSeriesPerQuery(childComplexity), true

	case "MimirLimits.maxGlobalExemplarsPerUser":
		if e.complexity.MimirLimits.MaxGlobalExemplarsPerUser == nil {
			break
		}

		return e.complexity.MimirLimits.MaxGlobalExemplarsPerUser(childComplexity), true

	case "MimirLimits.maxGlobalMetadataPerMetric":
		if e.complexity.MimirLimits.MaxGlobalMetadataPerMetric == nil {
			break
		}

		return e.complexity.MimirLimits.MaxGlobalMetadataPerMetric(childComplexity), true

	case "MimirLimits.maxGlobalMetricsWithMetadataPerUser":
		if e.complexity.MimirLimits.MaxGlobalMetricsWithMetadataPerUser == nil {
			break
		}

		return e.complexity.MimirLimits.MaxGlobalMetricsWithMetadataPerUser(childComplexity), true

	case "MimirLimits.maxGlobalSeriesPerMetric":
		if e.complexity.MimirLimits.MaxGlobalSeriesPerMetric == nil {
			break
		}

		return e.complexity.MimirLimits.MaxGlobalSeriesPerMetric(childComplexity), true

	case "MimirLimits.maxGlobalSeriesPerUser":
		if e.complexity.MimirLimits.MaxGlobalSeriesPerUser == nil {
			break
		}

		return e.complexity.MimirLimits.MaxGlobalSeriesPerUser(childComplexity), true

	case "MimirLimits.maxLabelNameLength":
		if e.complexity.MimirLimits.MaxLabelNameLength == nil {
			break
		}

		return e.complexity.MimirLimits.MaxLabelNameLength(childComplexity), true

	case "MimirLimits.maxLabelNamesPerSeries":
		if e.complexity.MimirLimits.MaxLabelNamesPerSeries == nil {
			break
		}

		return e.complexity.MimirLimits.MaxLabelNamesPerSeries(childComplexity), true

	case "MimirLimits.maxLabelValueLength":
		if e.complexity.MimirLimits.MaxLabelValueLength == nil {
			break
		}

		return e.complexity.MimirLimits.MaxLabelValueLength(childComplexity), true

	case "MimirLimits.maxLabelsQueryLength":
		if e.complexity.MimirLimits.MaxLabelsQueryLength == nil {
			break
		}

		return e.complexity.MimirLimits.MaxLabelsQueryLength(childComplexity), true

	case "MimirLimits.maxMetadataLength":
		if e.complexity.MimirLimits.MaxMetadataLength == nil {
			break
		}

		return e.complexity.MimirLimits.MaxMetadataLength(childComplexity), true

	case "MimirLimits.maxNativeHistogramBuckets":
		if e.complexity.MimirLimits.MaxNativeHistogramBuckets == nil {
			break
		}

		return e.complexity.MimirLimits.MaxNativeHistogramBuckets(childComplexity), true

	case "MimirLimits.maxPartialQueryLength":
		if e.complexity.MimirLimits.MaxPartialQueryLength == nil {
			break
		}

		return e.complexity.MimirLimits.MaxPartialQueryLength(childComplexity), true

	case "MimirLimits.maxQueriersPerTenant":
		if e.complexity.MimirLimits.MaxQueriersPerTenant == nil {
			break
		}

		return e.complexity.MimirLimits.MaxQueriersPerTenant(childComplexity), true

	case "MimirLimits.maxQueryExpressionSizeBytes":
		if e.complexity.MimirLimits.MaxQueryExpressionSizeBytes == nil {
			break
		}

		return e.complexity.MimirLimits.MaxQueryExpressionSizeBytes(childComplexity), true

	case "MimirLimits.maxQueryLookback":
		if e.complexity.MimirLimits.MaxQueryLookback == nil {
			break
		}

		return e.complexity.MimirLimits.MaxQueryLookback(childComplexity), true

	case "MimirLimits.maxQueryParallelism":
		if e.complexity.MimirLimits.MaxQueryParallelism == nil {
			break
		}

		return e.complexity.MimirLimits.MaxQueryParallelism(childComplexity), true

	case "MimirLimits.maxTotalQueryLength":
		if e.complexity.MimirLimits.MaxTotalQueryLength == nil {
			break
		}

		return e.complexity.MimirLimits.MaxTotalQueryLength(childComplexity), true

	case "MimirLimits.metricRelabelConfigs":
		if e.complexity.MimirLimits.MetricRelabelConfigs == nil {
			break
		}

		return e.complexity.MimirLimits.MetricRelabelConfigs(childComplexity), true

	case "MimirLimits.nativeHistogramsIngestionEnabled":
		if e.complexity.MimirLimits.NativeHistogramsIngestionEnabled == nil {
			break
		}

		return e.complexity.MimirLimits.NativeHistogramsIngestionEnabled(childComplexity), true

	case "MimirLimits.notificationRateLimit":
		if e.complexity.MimirLimits.NotificationRateLimit == nil {
			break
		}

		return e.complexity.MimirLimits.NotificationRateLimit(childComplexity), true

	case "MimirLimits.notificationRateLimitPerIntegration":
		if e.complexity.MimirLimits.NotificationRateLimitPerIntegration == nil {
			break
		}

		return e.complexity.MimirLimits.NotificationRateLimitPerIntegration(childComplexity), true

	case "MimirLimits.outOfOrderBlocksExternalLabelEnabled":
		if e.complexity.MimirLimits.OutOfOrderBlocksExternalLabelEnabled == nil {
			break
		}

		return e.complexity.MimirLimits.OutOfOrderBlocksExternalLabelEnabled(childComplexity), true

	case "MimirLimits.outOfOrderTimeWindow":
		if e.complexity.MimirLimits.OutOfOrderTimeWindow == nil {
			break
		}

		return e.complexity.MimirLimits.OutOfOrderTimeWindow(childComplexity), true

	case "MimirLimits.QueryIngestersWithin":
		if e.complexity.MimirLimits.QueryIngestersWithin == nil {
			break
		}

		return e.complexity.MimirLimits.QueryIngestersWithin(childComplexity), true

	case "MimirLimits.queryShardingMaxRegexpSizeBytes":
		if e.complexity.MimirLimits.QueryShardingMaxRegexpSizeBytes == nil {
			break
		}

		return e.complexity.MimirLimits.QueryShardingMaxRegexpSizeBytes(childComplexity), true

	case "MimirLimits.queryShardingMaxShardedQueries":
		if e.complexity.MimirLimits.QueryShardingMaxShardedQueries == nil {
			break
		}

		return e.complexity.MimirLimits.QueryShardingMaxShardedQueries(childComplexity), true

	case "MimirLimits.queryShardingTotalShards":
		if e.complexity.MimirLimits.QueryShardingTotalShards == nil {
			break
		}

		return e.complexity.MimirLimits.QueryShardingTotalShards(childComplexity), true

	case "MimirLimits.requestBurstSize":
		if e.complexity.MimirLimits.RequestBurstSize == nil {
			break
		}

		return e.complexity.MimirLimits.RequestBurstSize(childComplexity), true

	case "MimirLimits.requestRate":
		if e.complexity.MimirLimits.RequestRate == nil {
			break
		}

		return e.complexity.MimirLimits.RequestRate(childComplexity), true

	case "MimirLimits.resultsCacheForUnalignedQueryEnabled":
		if e.complexity.MimirLimits.ResultsCacheForUnalignedQueryEnabled == nil {
			break
		}

		return e.complexity.MimirLimits.ResultsCacheForUnalignedQueryEnabled(childComplexity), true

	case "MimirLimits.resultsCacheTTL":
		if e.complexity.MimirLimits.ResultsCacheTTL == nil {
			break
		}

		return e.complexity.MimirLimits.ResultsCacheTTL(childComplexity), true

	case "MimirLimits.resultsCacheTTLForCardinalityQuery":
		if e.complexity.MimirLimits.ResultsCacheTTLForCardinalityQuery == nil {
			break
		}

		return e.complexity.MimirLimits.ResultsCacheTTLForCardinalityQuery(childComplexity), true

	case "MimirLimits.resultsCacheTTLForLabelsQuery":
		if e.complexity.MimirLimits.ResultsCacheTTLForLabelsQuery == nil {
			break
		}

		return e.complexity.MimirLimits.ResultsCacheTTLForLabelsQuery(childComplexity), true

	case "MimirLimits.resultsCacheTTLForOutOfOrderTimeWindow":
		if e.complexity.MimirLimits.ResultsCacheTTLForOutOfOrderTimeWindow == nil {
			break
		}

		return e.complexity.MimirLimits.ResultsCacheTTLForOutOfOrderTimeWindow(childComplexity), true

	case "MimirLimits.rulerAlertingRulesEvaluationEnabled":
		if e.complexity.MimirLimits.RulerAlertingRulesEvaluationEnabled == nil {
			break
		}

		return e.complexity.MimirLimits.RulerAlertingRulesEvaluationEnabled(childComplexity), true

	case "MimirLimits.rulerEvaluationDelay":
		if e.complexity.MimirLimits.RulerEvaluationDelay == nil {
			break
		}

		return e.complexity.MimirLimits.RulerEvaluationDelay(childComplexity), true

	case "MimirLimits.rulerMaxRuleGroupsPerTenant":
		if e.complexity.MimirLimits.RulerMaxRuleGroupsPerTenant == nil {
			break
		}

		return e.complexity.MimirLimits.RulerMaxRuleGroupsPerTenant(childComplexity), true

	case "MimirLimits.rulerMaxRulesPerRuleGroup":
		if e.complexity.MimirLimits.RulerMaxRulesPerRuleGroup == nil {
			break
		}

		return e.complexity.MimirLimits.RulerMaxRulesPerRuleGroup(childComplexity), true

	case "MimirLimits.rulerRecordingRulesEvaluationEnabled":
		if e.complexity.MimirLimits.RulerRecordingRulesEvaluationEnabled == nil {
			break
		}

		return e.complexity.MimirLimits.RulerRecordingRulesEvaluationEnabled(childComplexity), true

	case "MimirLimits.rulerSyncRulesOnChangesEnabled":
		if e.complexity.MimirLimits.RulerSyncRulesOnChangesEnabled == nil {
			break
		}

		return e.complexity.MimirLimits.RulerSyncRulesOnChangesEnabled(childComplexity), true

	case "MimirLimits.rulerTenantShardSize":
		if e.complexity.MimirLimits.RulerTenantShardSize == nil {
			break
		}

		return e.complexity.MimirLimits.RulerTenantShardSize(childComplexity), true

	case "MimirLimits.s3SSEKMSEncryptionContext":
		if e.complexity.MimirLimits.S3SSEKMSEncryptionContext == nil {
			break
		}

		return e.complexity.MimirLimits.S3SSEKMSEncryptionContext(childComplexity), true

	case "MimirLimits.s3SSEKMSKeyID":
		if e.complexity.MimirLimits.S3SSEKMSKeyID == nil {
			break
		}

		return e.complexity.MimirLimits.S3SSEKMSKeyID(childComplexity), true

	case "MimirLimits.s3SSEType":
		if e.complexity.MimirLimits.S3SSEType == nil {
			break
		}

		return e.complexity.MimirLimits.S3SSEType(childComplexity), true

	case "MimirLimits.separateMetricsGroupLabel":
		if e.complexity.MimirLimits.SeparateMetricsGroupLabel == nil {
			break
		}

		return e.complexity.MimirLimits.SeparateMetricsGroupLabel(childComplexity), true

	case "MimirLimits.splitInstantQueriesByInterval":
		if e.complexity.MimirLimits.SplitInstantQueriesByInterval == nil {
			break
		}

		return e.complexity.MimirLimits.SplitInstantQueriesByInterval(childComplexity), true

	case "MimirLimits.storeGatewayTenantShardSize":
		if e.complexity.MimirLimits.StoreGatewayTenantShardSize == nil {
			break
		}

		return e.complexity.MimirLimits.StoreGatewayTenantShardSize(childComplexity), true

	case "Mutation.acceptOAuth2ConsentRequest":
		if e.complexity.Mutation.AcceptOAuth2ConsentRequest == nil {
			break
		}

		args, err := ec.field_Mutation_acceptOAuth2ConsentRequest_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AcceptOAuth2ConsentRequest(childComplexity, args["challenge"].(string), args["grantAccessTokenAudience"].([]string), args["grantScope"].([]string), args["remember"].(*bool), args["rememberFor"].(*int64)), true

	case "Mutation.acceptOAuth2LoginRequest":
		if e.complexity.Mutation.AcceptOAuth2LoginRequest == nil {
			break
		}

		args, err := ec.field_Mutation_acceptOAuth2LoginRequest_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AcceptOAuth2LoginRequest(childComplexity, args["challenge"].(string), args["acr"].(*string), args["amr"].([]string), args["context"].(map[string]interface{}), args["remember"].(*bool), args["rememberFor"].(*int64), args["subject"].(string)), true

	case "Mutation.createOAuth2Client":
		if e.complexity.Mutation.CreateOAuth2Client == nil {
			break
		}

		args, err := ec.field_Mutation_createOAuth2Client_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateOAuth2Client(childComplexity, args["allowedCorsOrigins"].([]string), args["audience"].([]string), args["authorizationCodeGrantAccessTokenLifespan"].(*string), args["authorizationCodeGrantIdTokenLifespan"].(*string), args["authorizationCodeGrantRefreshTokenLifespan"].(*string), args["backChannelLogoutSessionRequired"].(*bool), args["backChannelLogoutUri"].(*string), args["clientCredentialsGrantAccessTokenLifespan"].(*string), args["clientName"].(*string), args["clientSecret"].(*string), args["ClientSecretExpiresAt"].(*int64), args["clientUri"].(*string), args["contacts"].([]string), args["frontchannelLogoutSessionRequired"].(*bool), args["frontchannelLogoutUri"].(*string), args["grantTypes"].([]string), args["implicitGrantAccessTokenLifespan"].(*string), args["implicitGrantIdTokenLifespan"].(*string), args["jwks"].(map[string]interface{}), args["jwksUri"].(*string), args["jwtBearerGrantAccessTokenLifespan"].(*string), args["logoUri"].(*string), args["metadata"].(map[string]interface{}), args["policyUri"].(*string), args["postLogoutRedirectUris"].([]string), args["redirectUris"].([]string), args["responseTypes"].([]string), args["scope"].(*string), args["sectorIdentifierUri"].(*string), args["subjectType"].(*string), args["tokenEndpointAuthMethod"].(*string), args["tokenEndpointAuthSigningAlgorithm"].(*string), args["tosUri"].(*string), args["userinfoSignedResponseAlgorithm"].(*string), args["loginBindings"].(*model.LoginBindingsInput)), true

	case "Mutation.createObservabilityTenant":
		if e.complexity.Mutation.CreateObservabilityTenant == nil {
			break
		}

		args, err := ec.field_Mutation_createObservabilityTenant_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateObservabilityTenant(childComplexity, args["id"].(string), args["name"].(*string), args["admins"].(*model.ObservabilityTenantPermissionBindingsInput), args["metricsReaders"].(*model.ObservabilityTenantPermissionBindingsInput), args["metricsWriters"].(*model.ObservabilityTenantPermissionBindingsInput), args["metricsDeleters"].(*model.ObservabilityTenantPermissionBindingsInput), args["metricsRulesReaders"].(*model.ObservabilityTenantPermissionBindingsInput), args["metricsRulesWriters"].(*model.ObservabilityTenantPermissionBindingsInput), args["metricsRulesDeleters"].(*model.ObservabilityTenantPermissionBindingsInput), args["metricsAlertsReaders"].(*model.ObservabilityTenantPermissionBindingsInput), args["metricsAlertsWriters"].(*model.ObservabilityTenantPermissionBindingsInput), args["logsReaders"].(*model.ObservabilityTenantPermissionBindingsInput), args["logsWriters"].(*model.ObservabilityTenantPermissionBindingsInput), args["logsDeleters"].(*model.ObservabilityTenantPermissionBindingsInput), args["logsRulesReaders"].(*model.ObservabilityTenantPermissionBindingsInput), args["logsRulesWriters"].(*model.ObservabilityTenantPermissionBindingsInput), args["logsRulesDeleters"].(*model.ObservabilityTenantPermissionBindingsInput), args["tracesReaders"].(*model.ObservabilityTenantPermissionBindingsInput), args["tracesWriters"].(*model.ObservabilityTenantPermissionBindingsInput), args["limits"].(*model.ObservabilityTenantLimitsInput)), true

	case "Mutation.createUser":
		if e.complexity.Mutation.CreateUser == nil {
			break
		}

		args, err := ec.field_Mutation_createUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUser(childComplexity, args["email"].(string), args["name"].(*model.NameInput)), true

	case "Mutation.deleteGroup":
		if e.complexity.Mutation.DeleteGroup == nil {
			break
		}

		args, err := ec.field_Mutation_deleteGroup_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteGroup(childComplexity, args["name"].(string)), true

	case "Mutation.deleteOAuth2Client":
		if e.complexity.Mutation.DeleteOAuth2Client == nil {
			break
		}

		args, err := ec.field_Mutation_deleteOAuth2Client_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteOAuth2Client(childComplexity, args["clientId"].(string)), true

	case "Mutation.deleteObservabilityTenant":
		if e.complexity.Mutation.DeleteObservabilityTenant == nil {
			break
		}

		args, err := ec.field_Mutation_deleteObservabilityTenant_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteObservabilityTenant(childComplexity, args["id"].(string)), true

	case "Mutation.deleteUser":
		if e.complexity.Mutation.DeleteUser == nil {
			break
		}

		args, err := ec.field_Mutation_deleteUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteUser(childComplexity, args["id"].(string)), true

	case "Mutation.group":
		if e.complexity.Mutation.Group == nil {
			break
		}

		args, err := ec.field_Mutation_group_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Group(childComplexity, args["name"].(string), args["members"].([]*model.UserInput)), true

	case "Mutation.organization":
		if e.complexity.Mutation.Organization == nil {
			break
		}

		args, err := ec.field_Mutation_organization_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Organization(childComplexity, args["admins"].([]*model.UserInput)), true

	case "Mutation.rejectOAuth2ConsentRequest":
		if e.complexity.Mutation.RejectOAuth2ConsentRequest == nil {
			break
		}

		args, err := ec.field_Mutation_rejectOAuth2ConsentRequest_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RejectOAuth2ConsentRequest(childComplexity, args["challenge"].(string)), true

	case "Mutation.rejectOAuth2LoginRequest":
		if e.complexity.Mutation.RejectOAuth2LoginRequest == nil {
			break
		}

		args, err := ec.field_Mutation_rejectOAuth2LoginRequest_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RejectOAuth2LoginRequest(childComplexity, args["challenge"].(string)), true

	case "Mutation.updateOAuth2Client":
		if e.complexity.Mutation.UpdateOAuth2Client == nil {
			break
		}

		args, err := ec.field_Mutation_updateOAuth2Client_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateOAuth2Client(childComplexity, args["allowedCorsOrigins"].([]string), args["audience"].([]string), args["authorizationCodeGrantAccessTokenLifespan"].(*string), args["authorizationCodeGrantIdTokenLifespan"].(*string), args["authorizationCodeGrantRefreshTokenLifespan"].(*string), args["backChannelLogoutSessionRequired"].(*bool), args["backChannelLogoutUri"].(*string), args["clientCredentialsGrantAccessTokenLifespan"].(*string), args["clientId"].(string), args["clientName"].(*string), args["clientSecret"].(*string), args["ClientSecretExpiresAt"].(*int64), args["clientUri"].(*string), args["contacts"].([]string), args["frontchannelLogoutSessionRequired"].(*bool), args["frontchannelLogoutUri"].(*string), args["grantTypes"].([]string), args["implicitGrantAccessTokenLifespan"].(*string), args["implicitGrantIdTokenLifespan"].(*string), args["jwks"].(map[string]interface{}), args["jwksUri"].(*string), args["jwtBearerGrantAccessTokenLifespan"].(*string), args["logoUri"].(*string), args["metadata"].(map[string]interface{}), args["policyUri"].(*string), args["postLogoutRedirectUris"].([]string), args["redirectUris"].([]string), args["responseTypes"].([]string), args["scope"].(*string), args["sectorIdentifierUri"].(*string), args["subjectType"].(*string), args["tokenEndpointAuthMethod"].(*string), args["tokenEndpointAuthSigningAlgorithm"].(*string), args["tosUri"].(*string), args["userinfoSignedResponseAlgorithm"].(*string), args["loginBindings"].(*model.LoginBindingsInput)), true

	case "Mutation.updateObservabilityTenant":
		if e.complexity.Mutation.UpdateObservabilityTenant == nil {
			break
		}

		args, err := ec.field_Mutation_updateObservabilityTenant_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateObservabilityTenant(childComplexity, args["id"].(string), args["name"].(*string), args["admins"].(*model.ObservabilityTenantPermissionBindingsInput), args["metricsReaders"].(*model.ObservabilityTenantPermissionBindingsInput), args["metricsWriters"].(*model.ObservabilityTenantPermissionBindingsInput), args["metricsDeleters"].(*model.ObservabilityTenantPermissionBindingsInput), args["metricsRulesReaders"].(*model.ObservabilityTenantPermissionBindingsInput), args["metricsRulesWriters"].(*model.ObservabilityTenantPermissionBindingsInput), args["metricsRulesDeleters"].(*model.ObservabilityTenantPermissionBindingsInput), args["metricsAlertsReaders"].(*model.ObservabilityTenantPermissionBindingsInput), args["metricsAlertsWriters"].(*model.ObservabilityTenantPermissionBindingsInput), args["logsReaders"].(*model.ObservabilityTenantPermissionBindingsInput), args["logsWriters"].(*model.ObservabilityTenantPermissionBindingsInput), args["logsDeleters"].(*model.ObservabilityTenantPermissionBindingsInput), args["logsRulesReaders"].(*model.ObservabilityTenantPermissionBindingsInput), args["logsRulesWriters"].(*model.ObservabilityTenantPermissionBindingsInput), args["logsRulesDeleters"].(*model.ObservabilityTenantPermissionBindingsInput), args["tracesReaders"].(*model.ObservabilityTenantPermissionBindingsInput), args["tracesWriters"].(*model.ObservabilityTenantPermissionBindingsInput), args["limits"].(*model.ObservabilityTenantLimitsInput)), true

	case "Name.first":
		if e.complexity.Name.First == nil {
			break
		}

		return e.complexity.Name.First(childComplexity), true

	case "Name.last":
		if e.complexity.Name.Last == nil {
			break
		}

		return e.complexity.Name.Last(childComplexity), true

	case "NotifierBasicAuth.password":
		if e.complexity.NotifierBasicAuth.Password == nil {
			break
		}

		return e.complexity.NotifierBasicAuth.Password(childComplexity), true

	case "NotifierBasicAuth.username":
		if e.complexity.NotifierBasicAuth.Username == nil {
			break
		}

		return e.complexity.NotifierBasicAuth.Username(childComplexity), true

	case "NotifierConfig.basicAuth":
		if e.complexity.NotifierConfig.BasicAuth == nil {
			break
		}

		return e.complexity.NotifierConfig.BasicAuth(childComplexity), true

	case "NotifierConfig.headerAuth":
		if e.complexity.NotifierConfig.HeaderAuth == nil {
			break
		}

		return e.complexity.NotifierConfig.HeaderAuth(childComplexity), true

	case "NotifierConfig.tls":
		if e.complexity.NotifierConfig.TLS == nil {
			break
		}

		return e.complexity.NotifierConfig.TLS(childComplexity), true

	case "NotifierHeaderAuth.credentials":
		if e.complexity.NotifierHeaderAuth.Credentials == nil {
			break
		}

		return e.complexity.NotifierHeaderAuth.Credentials(childComplexity), true

	case "NotifierHeaderAuth.credentialsFile":
		if e.complexity.NotifierHeaderAuth.CredentialsFile == nil {
			break
		}

		return e.complexity.NotifierHeaderAuth.CredentialsFile(childComplexity), true

	case "NotifierHeaderAuth.type":
		if e.complexity.NotifierHeaderAuth.Type == nil {
			break
		}

		return e.complexity.NotifierHeaderAuth.Type(childComplexity), true

	case "NotifierTLSClientConfig.caPath":
		if e.complexity.NotifierTLSClientConfig.CAPath == nil {
			break
		}

		return e.complexity.NotifierTLSClientConfig.CAPath(childComplexity), true

	case "NotifierTLSClientConfig.certPath":
		if e.complexity.NotifierTLSClientConfig.CertPath == nil {
			break
		}

		return e.complexity.NotifierTLSClientConfig.CertPath(childComplexity), true

	case "NotifierTLSClientConfig.cipherSuites":
		if e.complexity.NotifierTLSClientConfig.CipherSuites == nil {
			break
		}

		return e.complexity.NotifierTLSClientConfig.CipherSuites(childComplexity), true

	case "NotifierTLSClientConfig.insecureSkipVerify":
		if e.complexity.NotifierTLSClientConfig.InsecureSkipVerify == nil {
			break
		}

		return e.complexity.NotifierTLSClientConfig.InsecureSkipVerify(childComplexity), true

	case "NotifierTLSClientConfig.keyPath":
		if e.complexity.NotifierTLSClientConfig.KeyPath == nil {
			break
		}

		return e.complexity.NotifierTLSClientConfig.KeyPath(childComplexity), true

	case "NotifierTLSClientConfig.minVersion":
		if e.complexity.NotifierTLSClientConfig.MinVersion == nil {
			break
		}

		return e.complexity.NotifierTLSClientConfig.MinVersion(childComplexity), true

	case "NotifierTLSClientConfig.serverName":
		if e.complexity.NotifierTLSClientConfig.ServerName == nil {
			break
		}

		return e.complexity.NotifierTLSClientConfig.ServerName(childComplexity), true

	case "OAuth2Client.allowedCorsOrigins":
		if e.complexity.OAuth2Client.AllowedCorsOrigins == nil {
			break
		}

		return e.complexity.OAuth2Client.AllowedCorsOrigins(childComplexity), true

	case "OAuth2Client.audience":
		if e.complexity.OAuth2Client.Audience == nil {
			break
		}

		return e.complexity.OAuth2Client.Audience(childComplexity), true

	case "OAuth2Client.authorizationCodeGrantAccessTokenLifespan":
		if e.complexity.OAuth2Client.AuthorizationCodeGrantAccessTokenLifespan == nil {
			break
		}

		return e.complexity.OAuth2Client.AuthorizationCodeGrantAccessTokenLifespan(childComplexity), true

	case "OAuth2Client.authorizationCodeGrantIdTokenLifespan":
		if e.complexity.OAuth2Client.AuthorizationCodeGrantIDTokenLifespan == nil {
			break
		}

		return e.complexity.OAuth2Client.AuthorizationCodeGrantIDTokenLifespan(childComplexity), true

	case "OAuth2Client.authorizationCodeGrantRefreshTokenLifespan":
		if e.complexity.OAuth2Client.AuthorizationCodeGrantRefreshTokenLifespan == nil {
			break
		}

		return e.complexity.OAuth2Client.AuthorizationCodeGrantRefreshTokenLifespan(childComplexity), true

	case "OAuth2Client.backChannelLogoutSessionRequired":
		if e.complexity.OAuth2Client.BackChannelLogoutSessionRequired == nil {
			break
		}

		return e.complexity.OAuth2Client.BackChannelLogoutSessionRequired(childComplexity), true

	case "OAuth2Client.backChannelLogoutUri":
		if e.complexity.OAuth2Client.BackChannelLogoutURI == nil {
			break
		}

		return e.complexity.OAuth2Client.BackChannelLogoutURI(childComplexity), true

	case "OAuth2Client.clientCredentialsGrantAccessTokenLifespan":
		if e.complexity.OAuth2Client.ClientCredentialsGrantAccessTokenLifespan == nil {
			break
		}

		return e.complexity.OAuth2Client.ClientCredentialsGrantAccessTokenLifespan(childComplexity), true

	case "OAuth2Client.clientId":
		if e.complexity.OAuth2Client.ClientID == nil {
			break
		}

		return e.complexity.OAuth2Client.ClientID(childComplexity), true

	case "OAuth2Client.clientName":
		if e.complexity.OAuth2Client.ClientName == nil {
			break
		}

		return e.complexity.OAuth2Client.ClientName(childComplexity), true

	case "OAuth2Client.clientSecret":
		if e.complexity.OAuth2Client.ClientSecret == nil {
			break
		}

		return e.complexity.OAuth2Client.ClientSecret(childComplexity), true

	case "OAuth2Client.ClientSecretExpiresAt":
		if e.complexity.OAuth2Client.ClientSecretExpiresAt == nil {
			break
		}

		return e.complexity.OAuth2Client.ClientSecretExpiresAt(childComplexity), true

	case "OAuth2Client.clientUri":
		if e.complexity.OAuth2Client.ClientURI == nil {
			break
		}

		return e.complexity.OAuth2Client.ClientURI(childComplexity), true

	case "OAuth2Client.contacts":
		if e.complexity.OAuth2Client.Contacts == nil {
			break
		}

		return e.complexity.OAuth2Client.Contacts(childComplexity), true

	case "OAuth2Client.createdAt":
		if e.complexity.OAuth2Client.CreatedAt == nil {
			break
		}

		return e.complexity.OAuth2Client.CreatedAt(childComplexity), true

	case "OAuth2Client.frontchannelLogoutSessionRequired":
		if e.complexity.OAuth2Client.FrontchannelLogoutSessionRequired == nil {
			break
		}

		return e.complexity.OAuth2Client.FrontchannelLogoutSessionRequired(childComplexity), true

	case "OAuth2Client.frontchannelLogoutUri":
		if e.complexity.OAuth2Client.FrontchannelLogoutURI == nil {
			break
		}

		return e.complexity.OAuth2Client.FrontchannelLogoutURI(childComplexity), true

	case "OAuth2Client.grantTypes":
		if e.complexity.OAuth2Client.GrantTypes == nil {
			break
		}

		return e.complexity.OAuth2Client.GrantTypes(childComplexity), true

	case "OAuth2Client.implicitGrantAccessTokenLifespan":
		if e.complexity.OAuth2Client.ImplicitGrantAccessTokenLifespan == nil {
			break
		}

		return e.complexity.OAuth2Client.ImplicitGrantAccessTokenLifespan(childComplexity), true

	case "OAuth2Client.implicitGrantIdTokenLifespan":
		if e.complexity.OAuth2Client.ImplicitGrantIDTokenLifespan == nil {
			break
		}

		return e.complexity.OAuth2Client.ImplicitGrantIDTokenLifespan(childComplexity), true

	case "OAuth2Client.jwks":
		if e.complexity.OAuth2Client.Jwks == nil {
			break
		}

		return e.complexity.OAuth2Client.Jwks(childComplexity), true

	case "OAuth2Client.jwksUri":
		if e.complexity.OAuth2Client.JwksURI == nil {
			break
		}

		return e.complexity.OAuth2Client.JwksURI(childComplexity), true

	case "OAuth2Client.jwtBearerGrantAccessTokenLifespan":
		if e.complexity.OAuth2Client.JwtBearerGrantAccessTokenLifespan == nil {
			break
		}

		return e.complexity.OAuth2Client.JwtBearerGrantAccessTokenLifespan(childComplexity), true

	case "OAuth2Client.loginBindings":
		if e.complexity.OAuth2Client.LoginBindings == nil {
			break
		}

		return e.complexity.OAuth2Client.LoginBindings(childComplexity), true

	case "OAuth2Client.logoUri":
		if e.complexity.OAuth2Client.LogoURI == nil {
			break
		}

		return e.complexity.OAuth2Client.LogoURI(childComplexity), true

	case "OAuth2Client.metadata":
		if e.complexity.OAuth2Client.Metadata == nil {
			break
		}

		return e.complexity.OAuth2Client.Metadata(childComplexity), true

	case "OAuth2Client.owner":
		if e.complexity.OAuth2Client.Owner == nil {
			break
		}

		return e.complexity.OAuth2Client.Owner(childComplexity), true

	case "OAuth2Client.policyUri":
		if e.complexity.OAuth2Client.PolicyURI == nil {
			break
		}

		return e.complexity.OAuth2Client.PolicyURI(childComplexity), true

	case "OAuth2Client.postLogoutRedirectUris":
		if e.complexity.OAuth2Client.PostLogoutRedirectUris == nil {
			break
		}

		return e.complexity.OAuth2Client.PostLogoutRedirectUris(childComplexity), true

	case "OAuth2Client.redirectUris":
		if e.complexity.OAuth2Client.RedirectUris == nil {
			break
		}

		return e.complexity.OAuth2Client.RedirectUris(childComplexity), true

	case "OAuth2Client.responseTypes":
		if e.complexity.OAuth2Client.ResponseTypes == nil {
			break
		}

		return e.complexity.OAuth2Client.ResponseTypes(childComplexity), true

	case "OAuth2Client.scope":
		if e.complexity.OAuth2Client.Scope == nil {
			break
		}

		return e.complexity.OAuth2Client.Scope(childComplexity), true

	case "OAuth2Client.sectorIdentifierUri":
		if e.complexity.OAuth2Client.SectorIdentifierURI == nil {
			break
		}

		return e.complexity.OAuth2Client.SectorIdentifierURI(childComplexity), true

	case "OAuth2Client.subjectType":
		if e.complexity.OAuth2Client.SubjectType == nil {
			break
		}

		return e.complexity.OAuth2Client.SubjectType(childComplexity), true

	case "OAuth2Client.tokenEndpointAuthMethod":
		if e.complexity.OAuth2Client.TokenEndpointAuthMethod == nil {
			break
		}

		return e.complexity.OAuth2Client.TokenEndpointAuthMethod(childComplexity), true

	case "OAuth2Client.tokenEndpointAuthSigningAlgorithm":
		if e.complexity.OAuth2Client.TokenEndpointAuthSigningAlgorithm == nil {
			break
		}

		return e.complexity.OAuth2Client.TokenEndpointAuthSigningAlgorithm(childComplexity), true

	case "OAuth2Client.tosUri":
		if e.complexity.OAuth2Client.TosURI == nil {
			break
		}

		return e.complexity.OAuth2Client.TosURI(childComplexity), true

	case "OAuth2Client.updatedAt":
		if e.complexity.OAuth2Client.UpdatedAt == nil {
			break
		}

		return e.complexity.OAuth2Client.UpdatedAt(childComplexity), true

	case "OAuth2Client.userinfoSignedResponseAlgorithm":
		if e.complexity.OAuth2Client.UserinfoSignedResponseAlgorithm == nil {
			break
		}

		return e.complexity.OAuth2Client.UserinfoSignedResponseAlgorithm(childComplexity), true

	case "OAuth2ConsentRequest.acr":
		if e.complexity.OAuth2ConsentRequest.Acr == nil {
			break
		}

		return e.complexity.OAuth2ConsentRequest.Acr(childComplexity), true

	case "OAuth2ConsentRequest.amr":
		if e.complexity.OAuth2ConsentRequest.Amr == nil {
			break
		}

		return e.complexity.OAuth2ConsentRequest.Amr(childComplexity), true

	case "OAuth2ConsentRequest.challenge":
		if e.complexity.OAuth2ConsentRequest.Challenge == nil {
			break
		}

		return e.complexity.OAuth2ConsentRequest.Challenge(childComplexity), true

	case "OAuth2ConsentRequest.client":
		if e.complexity.OAuth2ConsentRequest.Client == nil {
			break
		}

		return e.complexity.OAuth2ConsentRequest.Client(childComplexity), true

	case "OAuth2ConsentRequest.context":
		if e.complexity.OAuth2ConsentRequest.Context == nil {
			break
		}

		return e.complexity.OAuth2ConsentRequest.Context(childComplexity), true

	case "OAuth2ConsentRequest.loginChallenge":
		if e.complexity.OAuth2ConsentRequest.LoginChallenge == nil {
			break
		}

		return e.complexity.OAuth2ConsentRequest.LoginChallenge(childComplexity), true

	case "OAuth2ConsentRequest.loginSessionId":
		if e.complexity.OAuth2ConsentRequest.LoginSessionID == nil {
			break
		}

		return e.complexity.OAuth2ConsentRequest.LoginSessionID(childComplexity), true

	case "OAuth2ConsentRequest.oidcContext":
		if e.complexity.OAuth2ConsentRequest.OidcContext == nil {
			break
		}

		return e.complexity.OAuth2ConsentRequest.OidcContext(childComplexity), true

	case "OAuth2ConsentRequest.redirectTo":
		if e.complexity.OAuth2ConsentRequest.RedirectTo == nil {
			break
		}

		return e.complexity.OAuth2ConsentRequest.RedirectTo(childComplexity), true

	case "OAuth2ConsentRequest.requestUrl":
		if e.complexity.OAuth2ConsentRequest.RequestURL == nil {
			break
		}

		return e.complexity.OAuth2ConsentRequest.RequestURL(childComplexity), true

	case "OAuth2ConsentRequest.requestedAccessTokenAudience":
		if e.complexity.OAuth2ConsentRequest.RequestedAccessTokenAudience == nil {
			break
		}

		return e.complexity.OAuth2ConsentRequest.RequestedAccessTokenAudience(childComplexity), true

	case "OAuth2ConsentRequest.requestedScope":
		if e.complexity.OAuth2ConsentRequest.RequestedScope == nil {
			break
		}

		return e.complexity.OAuth2ConsentRequest.RequestedScope(childComplexity), true

	case "OAuth2ConsentRequest.skip":
		if e.complexity.OAuth2ConsentRequest.Skip == nil {
			break
		}

		return e.complexity.OAuth2ConsentRequest.Skip(childComplexity), true

	case "OAuth2ConsentRequest.subject":
		if e.complexity.OAuth2ConsentRequest.Subject == nil {
			break
		}

		return e.complexity.OAuth2ConsentRequest.Subject(childComplexity), true

	case "OAuth2LoginRequest.challenge":
		if e.complexity.OAuth2LoginRequest.Challenge == nil {
			break
		}

		return e.complexity.OAuth2LoginRequest.Challenge(childComplexity), true

	case "OAuth2LoginRequest.client":
		if e.complexity.OAuth2LoginRequest.Client == nil {
			break
		}

		return e.complexity.OAuth2LoginRequest.Client(childComplexity), true

	case "OAuth2LoginRequest.oidcContext":
		if e.complexity.OAuth2LoginRequest.OidcContext == nil {
			break
		}

		return e.complexity.OAuth2LoginRequest.OidcContext(childComplexity), true

	case "OAuth2LoginRequest.redirectTo":
		if e.complexity.OAuth2LoginRequest.RedirectTo == nil {
			break
		}

		return e.complexity.OAuth2LoginRequest.RedirectTo(childComplexity), true

	case "OAuth2LoginRequest.requestUrl":
		if e.complexity.OAuth2LoginRequest.RequestURL == nil {
			break
		}

		return e.complexity.OAuth2LoginRequest.RequestURL(childComplexity), true

	case "OAuth2LoginRequest.requestedAccessTokenAudience":
		if e.complexity.OAuth2LoginRequest.RequestedAccessTokenAudience == nil {
			break
		}

		return e.complexity.OAuth2LoginRequest.RequestedAccessTokenAudience(childComplexity), true

	case "OAuth2LoginRequest.requestedScope":
		if e.complexity.OAuth2LoginRequest.RequestedScope == nil {
			break
		}

		return e.complexity.OAuth2LoginRequest.RequestedScope(childComplexity), true

	case "OAuth2LoginRequest.sessionId":
		if e.complexity.OAuth2LoginRequest.SessionID == nil {
			break
		}

		return e.complexity.OAuth2LoginRequest.SessionID(childComplexity), true

	case "OAuth2LoginRequest.skip":
		if e.complexity.OAuth2LoginRequest.Skip == nil {
			break
		}

		return e.complexity.OAuth2LoginRequest.Skip(childComplexity), true

	case "OAuth2LoginRequest.subject":
		if e.complexity.OAuth2LoginRequest.Subject == nil {
			break
		}

		return e.complexity.OAuth2LoginRequest.Subject(childComplexity), true

	case "OAuth2RedirectTo.redirectTo":
		if e.complexity.OAuth2RedirectTo.RedirectTo == nil {
			break
		}

		return e.complexity.OAuth2RedirectTo.RedirectTo(childComplexity), true

	case "ObservabilityTenant.admins":
		if e.complexity.ObservabilityTenant.Admins == nil {
			break
		}

		return e.complexity.ObservabilityTenant.Admins(childComplexity), true

	case "ObservabilityTenant.displayName":
		if e.complexity.ObservabilityTenant.DisplayName == nil {
			break
		}

		return e.complexity.ObservabilityTenant.DisplayName(childComplexity), true

	case "ObservabilityTenant.id":
		if e.complexity.ObservabilityTenant.ID == nil {
			break
		}

		return e.complexity.ObservabilityTenant.ID(childComplexity), true

	case "ObservabilityTenant.limits":
		if e.complexity.ObservabilityTenant.Limits == nil {
			break
		}

		return e.complexity.ObservabilityTenant.Limits(childComplexity), true

	case "ObservabilityTenant.logsDeleters":
		if e.complexity.ObservabilityTenant.LogsDeleters == nil {
			break
		}

		return e.complexity.ObservabilityTenant.LogsDeleters(childComplexity), true

	case "ObservabilityTenant.logsReaders":
		if e.complexity.ObservabilityTenant.LogsReaders == nil {
			break
		}

		return e.complexity.ObservabilityTenant.LogsReaders(childComplexity), true

	case "ObservabilityTenant.logsRulesDeleters":
		if e.complexity.ObservabilityTenant.LogsRulesDeleters == nil {
			break
		}

		return e.complexity.ObservabilityTenant.LogsRulesDeleters(childComplexity), true

	case "ObservabilityTenant.logsRulesReaders":
		if e.complexity.ObservabilityTenant.LogsRulesReaders == nil {
			break
		}

		return e.complexity.ObservabilityTenant.LogsRulesReaders(childComplexity), true

	case "ObservabilityTenant.logsRulesWriters":
		if e.complexity.ObservabilityTenant.LogsRulesWriters == nil {
			break
		}

		return e.complexity.ObservabilityTenant.LogsRulesWriters(childComplexity), true

	case "ObservabilityTenant.logsWriters":
		if e.complexity.ObservabilityTenant.LogsWriters == nil {
			break
		}

		return e.complexity.ObservabilityTenant.LogsWriters(childComplexity), true

	case "ObservabilityTenant.metricsAlertsReaders":
		if e.complexity.ObservabilityTenant.MetricsAlertsReaders == nil {
			break
		}

		return e.complexity.ObservabilityTenant.MetricsAlertsReaders(childComplexity), true

	case "ObservabilityTenant.metricsAlertsWriters":
		if e.complexity.ObservabilityTenant.MetricsAlertsWriters == nil {
			break
		}

		return e.complexity.ObservabilityTenant.MetricsAlertsWriters(childComplexity), true

	case "ObservabilityTenant.metricsDeleters":
		if e.complexity.ObservabilityTenant.MetricsDeleters == nil {
			break
		}

		return e.complexity.ObservabilityTenant.MetricsDeleters(childComplexity), true

	case "ObservabilityTenant.metricsReaders":
		if e.complexity.ObservabilityTenant.MetricsReaders == nil {
			break
		}

		return e.complexity.ObservabilityTenant.MetricsReaders(childComplexity), true

	case "ObservabilityTenant.metricsRulesDeleters":
		if e.complexity.ObservabilityTenant.MetricsRulesDeleters == nil {
			break
		}

		return e.complexity.ObservabilityTenant.MetricsRulesDeleters(childComplexity), true

	case "ObservabilityTenant.metricsRulesReaders":
		if e.complexity.ObservabilityTenant.MetricsRulesReaders == nil {
			break
		}

		return e.complexity.ObservabilityTenant.MetricsRulesReaders(childComplexity), true

	case "ObservabilityTenant.metricsRulesWriters":
		if e.complexity.ObservabilityTenant.MetricsRulesWriters == nil {
			break
		}

		return e.complexity.ObservabilityTenant.MetricsRulesWriters(childComplexity), true

	case "ObservabilityTenant.metricsWriters":
		if e.complexity.ObservabilityTenant.MetricsWriters == nil {
			break
		}

		return e.complexity.ObservabilityTenant.MetricsWriters(childComplexity), true

	case "ObservabilityTenant.tracesReaders":
		if e.complexity.ObservabilityTenant.TracesReaders == nil {
			break
		}

		return e.complexity.ObservabilityTenant.TracesReaders(childComplexity), true

	case "ObservabilityTenant.tracesWriters":
		if e.complexity.ObservabilityTenant.TracesWriters == nil {
			break
		}

		return e.complexity.ObservabilityTenant.TracesWriters(childComplexity), true

	case "ObservabilityTenantLimits.loki":
		if e.complexity.ObservabilityTenantLimits.Loki == nil {
			break
		}

		return e.complexity.ObservabilityTenantLimits.Loki(childComplexity), true

	case "ObservabilityTenantLimits.mimir":
		if e.complexity.ObservabilityTenantLimits.Mimir == nil {
			break
		}

		return e.complexity.ObservabilityTenantLimits.Mimir(childComplexity), true

	case "ObservabilityTenantLimits.tempo":
		if e.complexity.ObservabilityTenantLimits.Tempo == nil {
			break
		}

		return e.complexity.ObservabilityTenantLimits.Tempo(childComplexity), true

	case "ObservabilityTenantPermissionBindings.groups":
		if e.complexity.ObservabilityTenantPermissionBindings.Groups == nil {
			break
		}

		return e.complexity.ObservabilityTenantPermissionBindings.Groups(childComplexity), true

	case "ObservabilityTenantPermissionBindings.oauth2Clients":
		if e.complexity.ObservabilityTenantPermissionBindings.Oauth2Clients == nil {
			break
		}

		return e.complexity.ObservabilityTenantPermissionBindings.Oauth2Clients(childComplexity), true

	case "ObservabilityTenantPermissionBindings.users":
		if e.complexity.ObservabilityTenantPermissionBindings.Users == nil {
			break
		}

		return e.complexity.ObservabilityTenantPermissionBindings.Users(childComplexity), true

	case "OidcContext.acrValues":
		if e.complexity.OidcContext.AcrValues == nil {
			break
		}

		return e.complexity.OidcContext.AcrValues(childComplexity), true

	case "OidcContext.display":
		if e.complexity.OidcContext.Display == nil {
			break
		}

		return e.complexity.OidcContext.Display(childComplexity), true

	case "OidcContext.idTokenHintClaims":
		if e.complexity.OidcContext.IDTokenHintClaims == nil {
			break
		}

		return e.complexity.OidcContext.IDTokenHintClaims(childComplexity), true

	case "OidcContext.loginHint":
		if e.complexity.OidcContext.LoginHint == nil {
			break
		}

		return e.complexity.OidcContext.LoginHint(childComplexity), true

	case "OidcContext.uiLocales":
		if e.complexity.OidcContext.UILocales == nil {
			break
		}

		return e.complexity.OidcContext.UILocales(childComplexity), true

	case "Organization.admins":
		if e.complexity.Organization.Admins == nil {
			break
		}

		return e.complexity.Organization.Admins(childComplexity), true

	case "PolicyMatch.attributes":
		if e.complexity.PolicyMatch.Attributes == nil {
			break
		}

		return e.complexity.PolicyMatch.Attributes(childComplexity), true

	case "PolicyMatch.matchType":
		if e.complexity.PolicyMatch.MatchType == nil {
			break
		}

		return e.complexity.PolicyMatch.MatchType(childComplexity), true

	case "Query.getOAuth2Client":
		if e.complexity.Query.GetOAuth2Client == nil {
			break
		}

		args, err := ec.field_Query_getOAuth2Client_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetOAuth2Client(childComplexity, args["clientId"].(string)), true

	case "Query.getObservabilityTenant":
		if e.complexity.Query.GetObservabilityTenant == nil {
			break
		}

		args, err := ec.field_Query_getObservabilityTenant_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetObservabilityTenant(childComplexity, args["id"].(string)), true

	case "Query.getUser":
		if e.complexity.Query.GetUser == nil {
			break
		}

		args, err := ec.field_Query_getUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetUser(childComplexity, args["id"].(*string), args["email"].(*string)), true

	case "Query.listGroups":
		if e.complexity.Query.ListGroups == nil {
			break
		}

		return e.complexity.Query.ListGroups(childComplexity), true

	case "Query.listOAuth2Clients":
		if e.complexity.Query.ListOAuth2Clients == nil {
			break
		}

		return e.complexity.Query.ListOAuth2Clients(childComplexity), true

	case "Query.listObservabilityTenants":
		if e.complexity.Query.ListObservabilityTenants == nil {
			break
		}

		return e.complexity.Query.ListObservabilityTenants(childComplexity), true

	case "Query.listUsers":
		if e.complexity.Query.ListUsers == nil {
			break
		}

		return e.complexity.Query.ListUsers(childComplexity), true

	case "Query.oauth2ConsentRequest":
		if e.complexity.Query.Oauth2ConsentRequest == nil {
			break
		}

		args, err := ec.field_Query_oauth2ConsentRequest_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Oauth2ConsentRequest(childComplexity, args["challenge"].(string)), true

	case "Query.oauth2LoginRequest":
		if e.complexity.Query.Oauth2LoginRequest == nil {
			break
		}

		args, err := ec.field_Query_oauth2LoginRequest_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Oauth2LoginRequest(childComplexity, args["challenge"].(string)), true

	case "Query.organization":
		if e.complexity.Query.Organization == nil {
			break
		}

		return e.complexity.Query.Organization(childComplexity), true

	case "RelabelConfig.action":
		if e.complexity.RelabelConfig.Action == nil {
			break
		}

		return e.complexity.RelabelConfig.Action(childComplexity), true

	case "RelabelConfig.modulus":
		if e.complexity.RelabelConfig.Modulus == nil {
			break
		}

		return e.complexity.RelabelConfig.Modulus(childComplexity), true

	case "RelabelConfig.regex":
		if e.complexity.RelabelConfig.Regex == nil {
			break
		}

		return e.complexity.RelabelConfig.Regex(childComplexity), true

	case "RelabelConfig.replacement":
		if e.complexity.RelabelConfig.Replacement == nil {
			break
		}

		return e.complexity.RelabelConfig.Replacement(childComplexity), true

	case "RelabelConfig.separator":
		if e.complexity.RelabelConfig.Separator == nil {
			break
		}

		return e.complexity.RelabelConfig.Separator(childComplexity), true

	case "RelabelConfig.sourceLabels":
		if e.complexity.RelabelConfig.SourceLabels == nil {
			break
		}

		return e.complexity.RelabelConfig.SourceLabels(childComplexity), true

	case "RelabelConfig.targetLabel":
		if e.complexity.RelabelConfig.TargetLabel == nil {
			break
		}

		return e.complexity.RelabelConfig.TargetLabel(childComplexity), true

	case "RulerAlertManagerConfig.alertRelabelConfigs":
		if e.complexity.RulerAlertManagerConfig.AlertRelabelConfigs == nil {
			break
		}

		return e.complexity.RulerAlertManagerConfig.AlertRelabelConfigs(childComplexity), true

	case "RulerAlertManagerConfig.alertmanagerDiscovery":
		if e.complexity.RulerAlertManagerConfig.AlertmanagerDiscovery == nil {
			break
		}

		return e.complexity.RulerAlertManagerConfig.AlertmanagerDiscovery(childComplexity), true

	case "RulerAlertManagerConfig.alertmanagerRefreshInterval":
		if e.complexity.RulerAlertManagerConfig.AlertmanagerRefreshInterval == nil {
			break
		}

		return e.complexity.RulerAlertManagerConfig.AlertmanagerRefreshInterval(childComplexity), true

	case "RulerAlertManagerConfig.alertmanagerURL":
		if e.complexity.RulerAlertManagerConfig.AlertmanagerURL == nil {
			break
		}

		return e.complexity.RulerAlertManagerConfig.AlertmanagerURL(childComplexity), true

	case "RulerAlertManagerConfig.alertmanangerEnableV2API":
		if e.complexity.RulerAlertManagerConfig.AlertmanangerEnableV2API == nil {
			break
		}

		return e.complexity.RulerAlertManagerConfig.AlertmanangerEnableV2API(childComplexity), true

	case "RulerAlertManagerConfig.notificationQueueCapacity":
		if e.complexity.RulerAlertManagerConfig.NotificationQueueCapacity == nil {
			break
		}

		return e.complexity.RulerAlertManagerConfig.NotificationQueueCapacity(childComplexity), true

	case "RulerAlertManagerConfig.notificationTimeout":
		if e.complexity.RulerAlertManagerConfig.NotificationTimeout == nil {
			break
		}

		return e.complexity.RulerAlertManagerConfig.NotificationTimeout(childComplexity), true

	case "RulerAlertManagerConfig.notifier":
		if e.complexity.RulerAlertManagerConfig.Notifier == nil {
			break
		}

		return e.complexity.RulerAlertManagerConfig.Notifier(childComplexity), true

	case "ShardstreamsConfig.desiredRate":
		if e.complexity.ShardstreamsConfig.DesiredRate == nil {
			break
		}

		return e.complexity.ShardstreamsConfig.DesiredRate(childComplexity), true

	case "ShardstreamsConfig.enabled":
		if e.complexity.ShardstreamsConfig.Enabled == nil {
			break
		}

		return e.complexity.ShardstreamsConfig.Enabled(childComplexity), true

	case "ShardstreamsConfig.loggingEnabled":
		if e.complexity.ShardstreamsConfig.LoggingEnabled == nil {
			break
		}

		return e.complexity.ShardstreamsConfig.LoggingEnabled(childComplexity), true

	case "StreamRetention.period":
		if e.complexity.StreamRetention.Period == nil {
			break
		}

		return e.complexity.StreamRetention.Period(childComplexity), true

	case "StreamRetention.priority":
		if e.complexity.StreamRetention.Priority == nil {
			break
		}

		return e.complexity.StreamRetention.Priority(childComplexity), true

	case "StreamRetention.selector":
		if e.complexity.StreamRetention.Selector == nil {
			break
		}

		return e.complexity.StreamRetention.Selector(childComplexity), true

	case "TempoLimits.blockRetention":
		if e.complexity.TempoLimits.BlockRetention == nil {
			break
		}

		return e.complexity.TempoLimits.BlockRetention(childComplexity), true

	case "TempoLimits.forwarders":
		if e.complexity.TempoLimits.Forwarders == nil {
			break
		}

		return e.complexity.TempoLimits.Forwarders(childComplexity), true

	case "TempoLimits.ingestionBurstSizeBytes":
		if e.complexity.TempoLimits.IngestionBurstSizeBytes == nil {
			break
		}

		return e.complexity.TempoLimits.IngestionBurstSizeBytes(childComplexity), true

	case "TempoLimits.ingestionRateLimitBytes":
		if e.complexity.TempoLimits.IngestionRateLimitBytes == nil {
			break
		}

		return e.complexity.TempoLimits.IngestionRateLimitBytes(childComplexity), true

	case "TempoLimits.ingestionRateStrategy":
		if e.complexity.TempoLimits.IngestionRateStrategy == nil {
			break
		}

		return e.complexity.TempoLimits.IngestionRateStrategy(childComplexity), true

	case "TempoLimits.maxBlocksPerTagValuesQuery":
		if e.complexity.TempoLimits.MaxBlocksPerTagValuesQuery == nil {
			break
		}

		return e.complexity.TempoLimits.MaxBlocksPerTagValuesQuery(childComplexity), true

	case "TempoLimits.maxBytesPerTagValuesQuery":
		if e.complexity.TempoLimits.MaxBytesPerTagValuesQuery == nil {
			break
		}

		return e.complexity.TempoLimits.MaxBytesPerTagValuesQuery(childComplexity), true

	case "TempoLimits.maxBytesPerTrace":
		if e.complexity.TempoLimits.MaxBytesPerTrace == nil {
			break
		}

		return e.complexity.TempoLimits.MaxBytesPerTrace(childComplexity), true

	case "TempoLimits.maxGlobalTracesPerUser":
		if e.complexity.TempoLimits.MaxGlobalTracesPerUser == nil {
			break
		}

		return e.complexity.TempoLimits.MaxGlobalTracesPerUser(childComplexity), true

	case "TempoLimits.maxLocalTracesPerUser":
		if e.complexity.TempoLimits.MaxLocalTracesPerUser == nil {
			break
		}

		return e.complexity.TempoLimits.MaxLocalTracesPerUser(childComplexity), true

	case "TempoLimits.maxSearchDuration":
		if e.complexity.TempoLimits.MaxSearchDuration == nil {
			break
		}

		return e.complexity.TempoLimits.MaxSearchDuration(childComplexity), true

	case "TempoLimits.metricsGeneratorCollectionInterval":
		if e.complexity.TempoLimits.MetricsGeneratorCollectionInterval == nil {
			break
		}

		return e.complexity.TempoLimits.MetricsGeneratorCollectionInterval(childComplexity), true

	case "TempoLimits.metricsGeneratorDisableCollection":
		if e.complexity.TempoLimits.MetricsGeneratorDisableCollection == nil {
			break
		}

		return e.complexity.TempoLimits.MetricsGeneratorDisableCollection(childComplexity), true

	case "TempoLimits.metricsGeneratorForwarderQueueSize":
		if e.complexity.TempoLimits.MetricsGeneratorForwarderQueueSize == nil {
			break
		}

		return e.complexity.TempoLimits.MetricsGeneratorForwarderQueueSize(childComplexity), true

	case "TempoLimits.metricsGeneratorForwarderWorkers":
		if e.complexity.TempoLimits.MetricsGeneratorForwarderWorkers == nil {
			break
		}

		return e.complexity.TempoLimits.MetricsGeneratorForwarderWorkers(childComplexity), true

	case "TempoLimits.metricsGeneratorMaxActiveSeries":
		if e.complexity.TempoLimits.MetricsGeneratorMaxActiveSeries == nil {
			break
		}

		return e.complexity.TempoLimits.MetricsGeneratorMaxActiveSeries(childComplexity), true

	case "TempoLimits.metricsGeneratorProcessorLocalBlocksCompleteBlockTimeout":
		if e.complexity.TempoLimits.MetricsGeneratorProcessorLocalBlocksCompleteBlockTimeout == nil {
			break
		}

		return e.complexity.TempoLimits.MetricsGeneratorProcessorLocalBlocksCompleteBlockTimeout(childComplexity), true

	case "TempoLimits.metricsGeneratorProcessorLocalBlocksFlushCheckPeriod":
		if e.complexity.TempoLimits.MetricsGeneratorProcessorLocalBlocksFlushCheckPeriod == nil {
			break
		}

		return e.complexity.TempoLimits.MetricsGeneratorProcessorLocalBlocksFlushCheckPeriod(childComplexity), true

	case "TempoLimits.metricsGeneratorProcessorLocalBlocksMaxBlockBytes":
		if e.complexity.TempoLimits.MetricsGeneratorProcessorLocalBlocksMaxBlockBytes == nil {
			break
		}

		return e.complexity.TempoLimits.MetricsGeneratorProcessorLocalBlocksMaxBlockBytes(childComplexity), true

	case "TempoLimits.metricsGeneratorProcessorLocalBlocksMaxBlockDuration":
		if e.complexity.TempoLimits.MetricsGeneratorProcessorLocalBlocksMaxBlockDuration == nil {
			break
		}

		return e.complexity.TempoLimits.MetricsGeneratorProcessorLocalBlocksMaxBlockDuration(childComplexity), true

	case "TempoLimits.metricsGeneratorProcessorLocalBlocksMaxLiveTraces":
		if e.complexity.TempoLimits.MetricsGeneratorProcessorLocalBlocksMaxLiveTraces == nil {
			break
		}

		return e.complexity.TempoLimits.MetricsGeneratorProcessorLocalBlocksMaxLiveTraces(childComplexity), true

	case "TempoLimits.metricsGeneratorProcessorLocalBlocksTraceIdlePeriod":
		if e.complexity.TempoLimits.MetricsGeneratorProcessorLocalBlocksTraceIdlePeriod == nil {
			break
		}

		return e.complexity.TempoLimits.MetricsGeneratorProcessorLocalBlocksTraceIdlePeriod(childComplexity), true

	case "TempoLimits.metricsGeneratorProcessorServiceGraphsDimensions":
		if e.complexity.TempoLimits.MetricsGeneratorProcessorServiceGraphsDimensions == nil {
			break
		}

		return e.complexity.TempoLimits.MetricsGeneratorProcessorServiceGraphsDimensions(childComplexity), true

	case "TempoLimits.metricsGeneratorProcessorServiceGraphsEnableClientServerPrefix":
		if e.complexity.TempoLimits.MetricsGeneratorProcessorServiceGraphsEnableClientServerPrefix == nil {
			break
		}

		return e.complexity.TempoLimits.MetricsGeneratorProcessorServiceGraphsEnableClientServerPrefix(childComplexity), true

	case "TempoLimits.metricsGeneratorProcessorServiceGraphsHistogramBuckets":
		if e.complexity.TempoLimits.MetricsGeneratorProcessorServiceGraphsHistogramBuckets == nil {
			break
		}

		return e.complexity.TempoLimits.MetricsGeneratorProcessorServiceGraphsHistogramBuckets(childComplexity), true

	case "TempoLimits.metricsGeneratorProcessorServiceGraphsPeerAttributes":
		if e.complexity.TempoLimits.MetricsGeneratorProcessorServiceGraphsPeerAttributes == nil {
			break
		}

		return e.complexity.TempoLimits.MetricsGeneratorProcessorServiceGraphsPeerAttributes(childComplexity), true

	case "TempoLimits.metricsGeneratorProcessorSpanMetricsDimensionMappings":
		if e.complexity.TempoLimits.MetricsGeneratorProcessorSpanMetricsDimensionMappings == nil {
			break
		}

		return e.complexity.TempoLimits.MetricsGeneratorProcessorSpanMetricsDimensionMappings(childComplexity), true

	case "TempoLimits.metricsGeneratorProcessorSpanMetricsDimensions":
		if e.complexity.TempoLimits.MetricsGeneratorProcessorSpanMetricsDimensions == nil {
			break
		}

		return e.complexity.TempoLimits.MetricsGeneratorProcessorSpanMetricsDimensions(childComplexity), true

	case "TempoLimits.metricsGeneratorProcessorSpanMetricsEnableTargetInfo":
		if e.complexity.TempoLimits.MetricsGeneratorProcessorSpanMetricsEnableTargetInfo == nil {
			break
		}

		return e.complexity.TempoLimits.MetricsGeneratorProcessorSpanMetricsEnableTargetInfo(childComplexity), true

	case "TempoLimits.metricsGeneratorProcessorSpanMetricsFilterPolicies":
		if e.complexity.TempoLimits.MetricsGeneratorProcessorSpanMetricsFilterPolicies == nil {
			break
		}

		return e.complexity.TempoLimits.MetricsGeneratorProcessorSpanMetricsFilterPolicies(childComplexity), true

	case "TempoLimits.metricsGeneratorProcessorSpanMetricsHistogramBuckets":
		if e.complexity.TempoLimits.MetricsGeneratorProcessorSpanMetricsHistogramBuckets == nil {
			break
		}

		return e.complexity.TempoLimits.MetricsGeneratorProcessorSpanMetricsHistogramBuckets(childComplexity), true

	case "TempoLimits.metricsGeneratorProcessorSpanMetricsIntrinsicDimensions":
		if e.complexity.TempoLimits.MetricsGeneratorProcessorSpanMetricsIntrinsicDimensions == nil {
			break
		}

		return e.complexity.TempoLimits.MetricsGeneratorProcessorSpanMetricsIntrinsicDimensions(childComplexity), true

	case "TempoLimits.metricsGeneratorProcessors":
		if e.complexity.TempoLimits.MetricsGeneratorProcessors == nil {
			break
		}

		return e.complexity.TempoLimits.MetricsGeneratorProcessors(childComplexity), true

	case "TempoLimits.metricsGeneratorRingSize":
		if e.complexity.TempoLimits.MetricsGeneratorRingSize == nil {
			break
		}

		return e.complexity.TempoLimits.MetricsGeneratorRingSize(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.groups":
		if e.complexity.User.Groups == nil {
			break
		}

		return e.complexity.User.Groups(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.recoveryLink":
		if e.complexity.User.RecoveryLink == nil {
			break
		}

		return e.complexity.User.RecoveryLink(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAcceptOAuth2ConsentRequestSession,
		ec.unmarshalInputBlockedQueryInput,
		ec.unmarshalInputDimensionMappingsInput,
		ec.unmarshalInputFilterPolicyInput,
		ec.unmarshalInputGroupInput,
		ec.unmarshalInputLoginBindingsInput,
		ec.unmarshalInputLokiLimitsInput,
		ec.unmarshalInputMatchPolicyAttributeInput,
		ec.unmarshalInputMimirLimitsInput,
		ec.unmarshalInputNameInput,
		ec.unmarshalInputNotifierBasicAuthInput,
		ec.unmarshalInputNotifierConfigInput,
		ec.unmarshalInputNotifierHeaderAuthInput,
		ec.unmarshalInputNotifierTLSClientConfigInput,
		ec.unmarshalInputOAuth2ClientInput,
		ec.unmarshalInputObservabilityTenantLimitsInput,
		ec.unmarshalInputObservabilityTenantPermissionBindingsInput,
		ec.unmarshalInputPolicyMatchInput,
		ec.unmarshalInputRelabelConfigInput,
		ec.unmarshalInputRulerAlertManagerConfigInput,
		ec.unmarshalInputShardstreamsConfigInput,
		ec.unmarshalInputStreamRetentionInput,
		ec.unmarshalInputTempoLimitsInput,
		ec.unmarshalInputUserInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._queryMiddleware(ctx, rc.Operation, func(ctx context.Context) (interface{}, error) {
					return ec._Query(ctx, rc.Operation.SelectionSet), nil
				})
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._mutationMiddleware(ctx, rc.Operation, func(ctx context.Context) (interface{}, error) {
				return ec._Mutation(ctx, rc.Operation.SelectionSet), nil
			})
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../directives.graphqls", Input: `#check if the user is authenticated or not
directive @isAuthenticated on QUERY | MUTATION | FIELD | FIELD_DEFINITION

#checks user permissions using Keto
directive @checkPermissions on QUERY | MUTATION | FIELD | FIELD_DEFINITION
`, BuiltIn: false},
	{Name: "../group.graphqls", Input: `"Representation a group of users."
type Group {
  "The unique name of the group."
  name: String!

  "The users that are admins of the organization."
  members: [User!]

  # "The organization that the group belongs to."
  # organization: Organization!
}

"Input for a group using its name."
input GroupInput {
  "The name of the group."
  name: String!
}

extend type Query {
  "Get a list of all users."
  listGroups: [Group!] @checkPermissions @isAuthenticated
}

extend type Mutation {
  "Create or update a group."
  group(
    "The unique name of the group."
    name: String!

    "The IDs or email addresses of the users that are members of the group."
    members: [UserInput!]
  ): Group! @checkPermissions @isAuthenticated

  "Delete a group."
  deleteGroup(
    "The unique name of the group."
    name: String!
  ): Group! @checkPermissions @isAuthenticated
}
`, BuiltIn: false},
	{Name: "../loki_limits.graphqls", Input: `"Representation of the limits for Loki for a tenant."
type LokiLimits {
  ingestionRateStrategy: String
  ingestionRateMB: Float
  ingestionBurstSizeMB: Float
  maxLabelNameLength: Int
  maxLabelValueLength: Int
  maxLabelNamesPerSeries: Int
  rejectOldSamples: Boolean
  rejectOldSamplesMaxAge: Duration
  creationGracePeriod: Duration
  enforceMetricName: Boolean
  maxLineSize: UInt
  maxLineSizeTruncate: Boolean
  incrementDuplicateTimestamp: Boolean
  maxLocalStreamsPerUser: Int
  maxGlobalStreamsPerUser: Int
  unorderedWrites: Boolean
  perStreamRateLimit: UInt
  perStreamRateLimitBurst: UInt
  maxChunksPerQuery: Int
  maxQuerySeries: Int
  maxQueryLookback: Duration
  maxQueryLength: Duration
  maxQueryRange: Duration
  maxQueryParallelism: Int
  tsdbMaxQueryParallelism: Int
  tsdbMaxBytesPerShard: UInt
  cardinalityLimit: Int
  maxStreamsMatchersPerQuery: Int
  maxConcurrentTailRequests: Int
  maxEntriesLimitPerQuery: Int
  maxCacheFreshness: Duration
  maxStatsCacheFreshness: Duration
  maxQueriersPerTenant: Int
  queryReadyIndexNumDays: Int
  queryTimeout: Duration
  querySplitDuration: Duration
  minShardingLookback: Duration
  maxQueryBytesRead: UInt
  maxQuerierBytesRead: UInt
  volumeEnabled: Boolean
  volumeMaxSeries: Int
  rulerEvaluationDelay: Duration
  rulerMaxRulesPerRuleGroup: Int
  rulerMaxRuleGroupsPerTenant: Int
  rulerAlertManagerConfig: RulerAlertManagerConfig
  rulerTenantShardSize: Int
  rulerRemoteWriteDisabled: Boolean
  # TODO: create scalar and type rulerRemoteWriteConfig: map[string]RemoteWriteSpec
  rulerRemoteEvaluationTimeout: Duration
  rulerRemoteEvaluationMaxResponseSize: Int
  deletionMode: String
  retentionPeriod: Duration
  streamRetention: [StreamRetention!]
  shardStreams: ShardstreamsConfig
  blockedQueries: [BlockedQuery!]
  requiredLabels: [String!]
  requiredNumberLabels: Int
  indexGatewayShardSize: Int
}

type RulerAlertManagerConfig {
  alertmanagerURL: String!
  alertmanagerDiscovery: Boolean
  alertmanagerRefreshInterval: Duration
  alertmanangerEnableV2API: Boolean
  alertRelabelConfigs: [RelabelConfig!]
  notificationQueueCapacity: Int
  notificationTimeout: Duration
  notifier: NotifierConfig
}

type NotifierConfig {
  basicAuth: NotifierBasicAuth
  headerAuth: NotifierHeaderAuth
  tls: NotifierTLSClientConfig
}

type NotifierBasicAuth {
  username: String
  password: String
}

type NotifierHeaderAuth {
  type: String
  credentials: String
  credentialsFile: String
}

type NotifierTLSClientConfig {
  certPath: String
  keyPath: String
  caPath: String
  serverName: String
  insecureSkipVerify: Boolean
  cipherSuites: String
  minVersion: String
}

type StreamRetention {
  period: Duration
  priority: Int
  selector: String
}

type ShardstreamsConfig {
  enabled: Boolean
  loggingEnabled: Boolean
  desiredRate: UInt
}

type BlockedQuery {
  pattern: String
  regex: Boolean
  hash: UInt
  types: [BlockedQueryType!]
}

enum BlockedQueryType {
  metric
  filter
  limited
}


"Input of the limits for Loki for a tenant."
input LokiLimitsInput {
  ingestionRateStrategy: String
  ingestionRateMB: Float
  ingestionBurstSizeMB: Float
  maxLabelNameLength: Int
  maxLabelValueLength: Int
  maxLabelNamesPerSeries: Int
  rejectOldSamples: Boolean
  rejectOldSamplesMaxAge: Duration
  creationGracePeriod: Duration
  enforceMetricName: Boolean
  maxLineSize: UInt
  maxLineSizeTruncate: Boolean
  incrementDuplicateTimestamp: Boolean
  maxLocalStreamsPerUser: Int
  maxGlobalStreamsPerUser: Int
  unorderedWrites: Boolean
  perStreamRateLimit: UInt
  perStreamRateLimitBurst: UInt
  maxChunksPerQuery: Int
  maxQuerySeries: Int
  maxQueryLookback: Duration
  maxQueryLength: Duration
  maxQueryRange: Duration
  maxQueryParallelism: Int
  tsdbMaxQueryParallelism: Int
  tsdbMaxBytesPerShard: UInt
  cardinalityLimit: Int
  maxStreamsMatchersPerQuery: Int
  maxConcurrentTailRequests: Int
  maxEntriesLimitPerQuery: Int
  maxCacheFreshness: Duration
  maxStatsCacheFreshness: Duration
  maxQueriersPerTenant: Int
  queryReadyIndexNumDays: Int
  queryTimeout: Duration
  querySplitDuration: Duration
  minShardingLookback: Duration
  maxQueryBytesRead: UInt
  maxQuerierBytesRead: UInt
  volumeEnabled: Boolean
  volumeMaxSeries: Int
  rulerEvaluationDelay: Duration
  rulerMaxRulesPerRuleGroup: Int
  rulerMaxRuleGroupsPerTenant: Int
  rulerAlertManagerConfig: RulerAlertManagerConfigInput
  rulerTenantShardSize: Int
  rulerRemoteWriteDisabled: Boolean
  # TODO: create scalar and type rulerRemoteWriteConfig: map[string]RemoteWriteSpec
  rulerRemoteEvaluationTimeout: Duration
  rulerRemoteEvaluationMaxResponseSize: Int
  deletionMode: String
  retentionPeriod: Duration
  streamRetention: [StreamRetentionInput!]
  shardStreams: ShardstreamsConfigInput
  blockedQueries: [BlockedQueryInput!]
  requiredLabels: [String!]
  requiredNumberLabels: Int
  indexGatewayShardSize: Int
}

input RulerAlertManagerConfigInput {
  alertmanagerURL: String!
  alertmanagerDiscovery: Boolean
  alertmanagerRefreshInterval: Duration
  alertmanangerEnableV2API: Boolean
  alertRelabelConfigs: [RelabelConfigInput!]
  notificationQueueCapacity: Int
  notificationTimeout: Duration
  notifier: NotifierConfigInput
}

input NotifierConfigInput {
  basicAuth: NotifierBasicAuthInput
  headerAuth: NotifierHeaderAuthInput
  tls: NotifierTLSClientConfigInput
}

input NotifierBasicAuthInput {
  username: String
  password: String
}

input NotifierHeaderAuthInput {
  type: String
  credentials: String
  credentialsFile: String
}

input NotifierTLSClientConfigInput {
  certPath: String
  keyPath: String
  caPath: String
  serverName: String
  insecureSkipVerify: Boolean
  cipherSuites: String
  minVersion: String
}

input StreamRetentionInput {
  period: Duration
  priority: Int
  selector: String
}

input ShardstreamsConfigInput {
  enabled: Boolean
  loggingEnabled: Boolean
  desiredRate: UInt
}

input BlockedQueryInput {
  pattern: String
  regex: Boolean
  hash: UInt
  types: [BlockedQueryType!]
}
`, BuiltIn: false},
	{Name: "../mimir_limits.graphqls", Input: `"Representation of the limits for Mimir for a tenant."
type MimirLimits {
  requestRate: Float
  requestBurstSize: Int
  ingestionRate: Float
  ingestionBurstSize: Int
  acceptHASamples: Boolean
  haClusterLabel: String
  haReplicaLabel: String
  haMaxClusters: Int
  dropLabels: [String!]
  maxLabelNameLength: Int
  maxLabelValueLength: Int
  maxLabelNamesPerSeries: Int
  maxMetadataLength: Int
  maxNativeHistogramBuckets: Int
  creationGracePeriod: Duration
  enforceMetadataMetricName: Boolean
  ingestionTenantShardSize: Int
  metricRelabelConfigs: [RelabelConfig!]
  maxGlobalSeriesPerUser: Int
  maxGlobalSeriesPerMetric: Int
  maxGlobalMetricsWithMetadataPerUser: Int
  maxGlobalMetadataPerMetric: Int
  maxGlobalExemplarsPerUser: Int
  nativeHistogramsIngestionEnabled: Boolean
  activeSeriesCustomTrackersConfig: StringMap
  outOfOrderTimeWindow: Duration
  outOfOrderBlocksExternalLabelEnabled: Boolean
  separateMetricsGroupLabel: String
  maxChunksPerQuery: Int
  maxFetchedSeriesPerQuery: Int
  maxFetchedChunkBytesPerQuery: Int
  maxQueryLookback: Duration
  maxPartialQueryLength: Duration
  maxQueryParallelism: Int
  maxLabelsQueryLength: Duration
  maxCacheFreshness: Duration
  maxQueriersPerTenant: Int
  queryShardingTotalShards: Int
  queryShardingMaxShardedQueries: Int
  queryShardingMaxRegexpSizeBytes: Int
  splitInstantQueriesByInterval: Duration
  QueryIngestersWithin: Duration
  maxTotalQueryLength: Duration
  resultsCacheTTL: Duration
  resultsCacheTTLForOutOfOrderTimeWindow: Duration
  resultsCacheTTLForCardinalityQuery: Duration
  resultsCacheTTLForLabelsQuery: Duration
  resultsCacheForUnalignedQueryEnabled: Boolean
  maxQueryExpressionSizeBytes: Int
  cardinalityAnalysisEnabled: Boolean
  labelNamesAndValuesResultsMaxSizeBytes: Int
  labelValuesMaxCardinalityLabelNamesPerRequest: Int
  rulerEvaluationDelay: Duration
  rulerTenantShardSize: Int
  rulerMaxRulesPerRuleGroup: Int
  rulerMaxRuleGroupsPerTenant: Int
  rulerRecordingRulesEvaluationEnabled: Boolean
  rulerAlertingRulesEvaluationEnabled: Boolean
  rulerSyncRulesOnChangesEnabled: Boolean
  storeGatewayTenantShardSize: Int
  compactorBlocksRetentionPeriod: Duration
  compactorSplitAndMergeShards: Int
  compactorSplitGroups: Int
  compactorTenantShardSize: Int
  compactorPartialBlockDeletionDelay: Duration
  compactorBlockUploadEnabled: Boolean
  compactorBlockUploadValidationEnabled: Boolean
  compactorBlockUploadVerifyChunks: Boolean
  compactorBlockUploadMaxBlockSizeBytes: Int
  s3SSEType: String
  s3SSEKMSKeyID: String
  s3SSEKMSEncryptionContext: String
  alertmanagerReceiversBlockCIDRNetworks: String
  alertmanagerReceiversBlockPrivateAddresses: Boolean
  notificationRateLimit: Float
  notificationRateLimitPerIntegration: FloatMap
  alertmanagerMaxConfigSizeBytes: Int
  alertmanagerMaxTemplatesCount: Int
  alertmanagerMaxTemplateSizeBytes: Int
  alertmanagerMaxDispatcherAggregationGroups: Int
  alertmanagerMaxAlertsCount: Int
  alertmanagerMaxAlertsSizeBytes: Int
}

"Input of the limits for Mimir for a tenant."
input MimirLimitsInput {
  requestRate: Float
  requestBurstSize: Int
  ingestionRate: Float
  ingestionBurstSize: Int
  acceptHASamples: Boolean
  haClusterLabel: String
  haReplicaLabel: String
  haMaxClusters: Int
  dropLabels: [String!]
  maxLabelNameLength: Int
  maxLabelValueLength: Int
  maxLabelNamesPerSeries: Int
  maxMetadataLength: Int
  maxNativeHistogramBuckets: Int
  creationGracePeriod: Duration
  enforceMetadataMetricName: Boolean
  ingestionTenantShardSize: Int
  metricRelabelConfigs: [RelabelConfigInput!]
  maxGlobalSeriesPerUser: Int
  maxGlobalSeriesPerMetric: Int
  maxGlobalMetricsWithMetadataPerUser: Int
  maxGlobalMetadataPerMetric: Int
  maxGlobalExemplarsPerUser: Int
  nativeHistogramsIngestionEnabled: Boolean
  activeSeriesCustomTrackersConfig: StringMap
  outOfOrderTimeWindow: Duration
  outOfOrderBlocksExternalLabelEnabled: Boolean
  separateMetricsGroupLabel: String
  maxChunksPerQuery: Int
  maxFetchedSeriesPerQuery: Int
  maxFetchedChunkBytesPerQuery: Int
  maxQueryLookback: Duration
  maxPartialQueryLength: Duration
  maxQueryParallelism: Int
  maxLabelsQueryLength: Duration
  maxCacheFreshness: Duration
  maxQueriersPerTenant: Int
  queryShardingTotalShards: Int
  queryShardingMaxShardedQueries: Int
  queryShardingMaxRegexpSizeBytes: Int
  splitInstantQueriesByInterval: Duration
  QueryIngestersWithin: Duration
  maxTotalQueryLength: Duration
  resultsCacheTTL: Duration
  resultsCacheTTLForOutOfOrderTimeWindow: Duration
  resultsCacheTTLForCardinalityQuery: Duration
  resultsCacheTTLForLabelsQuery: Duration
  resultsCacheForUnalignedQueryEnabled: Boolean
  maxQueryExpressionSizeBytes: Int
  cardinalityAnalysisEnabled: Boolean
  labelNamesAndValuesResultsMaxSizeBytes: Int
  labelValuesMaxCardinalityLabelNamesPerRequest: Int
  rulerEvaluationDelay: Duration
  rulerTenantShardSize: Int
  rulerMaxRulesPerRuleGroup: Int
  rulerMaxRuleGroupsPerTenant: Int
  rulerRecordingRulesEvaluationEnabled: Boolean
  rulerAlertingRulesEvaluationEnabled: Boolean
  rulerSyncRulesOnChangesEnabled: Boolean
  storeGatewayTenantShardSize: Int
  compactorBlocksRetentionPeriod: Duration
  compactorSplitAndMergeShards: Int
  compactorSplitGroups: Int
  compactorTenantShardSize: Int
  compactorPartialBlockDeletionDelay: Duration
  compactorBlockUploadEnabled: Boolean
  compactorBlockUploadValidationEnabled: Boolean
  compactorBlockUploadVerifyChunks: Boolean
  compactorBlockUploadMaxBlockSizeBytes: Int
  s3SSEType: String
  s3SSEKMSKeyID: String
  s3SSEKMSEncryptionContext: String
  alertmanagerReceiversBlockCIDRNetworks: String
  alertmanagerReceiversBlockPrivateAddresses: Boolean
  notificationRateLimit: Float
  notificationRateLimitPerIntegration: FloatMap
  alertmanagerMaxConfigSizeBytes: Int
  alertmanagerMaxTemplatesCount: Int
  alertmanagerMaxTemplateSizeBytes: Int
  alertmanagerMaxDispatcherAggregationGroups: Int
  alertmanagerMaxAlertsCount: Int
  alertmanagerMaxAlertsSizeBytes: Int
}
`, BuiltIn: false},
	{Name: "../oauth2client.graphqls", Input: `scalar Time
scalar Map

"Representation of the information about an OAuth2 Client sourced from Hydra."
type OAuth2Client {

  "OAuth 2.0 Client Allowed CORS Origins. AllowedCORSOrigins is an array of allowed CORS origins. If the array is empty, the value of the first element is considered valid."
  allowedCorsOrigins: [String!]

  "OAuth 2.0 Client Audience. Audience is an array of URLs that the OAuth 2.0 Client is allowed to request tokens for."
  audience: [String!]

  "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
  authorizationCodeGrantAccessTokenLifespan: String

  "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
  authorizationCodeGrantIdTokenLifespan: String

  "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
  authorizationCodeGrantRefreshTokenLifespan: String

  "OpenID Connect Back-Channel Logout Session Required  Boolean value specifying whether the RP requires that a sid (session ID) Claim be included in the Logout Token to identify the RP session with the OP when the backchannel_logout_uri is used. If omitted, the default value is false."
  backChannelLogoutSessionRequired: Boolean

  "OpenID Connect Back-Channel Logout URI. RP URL that will cause the RP to log itself out when sent a Logout Token by the OP."
  backChannelLogoutUri: String

  "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
  clientCredentialsGrantAccessTokenLifespan: String

  "OAuth 2.0 Client ID. The ID is autogenerated and immutable."
  clientId: String

  "OAuth 2.0 Client Name. The human-readable name of the client to be presented to the end-user during authorization."
  clientName: String

  "OAuth 2.0 Client Secret. The secret will be included in the create request as cleartext, and then never again. The secret is kept in hashed format and is not recoverable once lost."
  clientSecret: String

  "OAuth 2.0 Client Secret Expires At. The field is currently not supported and its value is always 0."
  ClientSecretExpiresAt: Int

  "OAuth 2.0 Client URI. ClientURI is a URL string of a web page providing information about the client. If present, the server SHOULD display this URL to the end-user in a clickable fashion."
  clientUri: String

  "OAuth 2.0 Client Contacts. Contacts is an array of strings representing ways to contact people responsible for this client, typically email addresses."
  contacts: [String!]

  "OAuth 2.0 Client Creation Date. CreatedAt returns the timestamp of the client's creation."
  createdAt: Time

  "OpenID Connect Front-Channel Logout Session Required. Boolean value specifying whether the RP requires that iss (issuer) and sid (session ID) query parameters be included to identify the RP session with the OP when the frontchannel_logout_uri is used. If omitted, the default value is false."
  frontchannelLogoutSessionRequired: Boolean

  "OpenID Connect Front-Channel Logout URI. RP URL that will cause the RP to log itself out when rendered in an iframe by the OP."
  frontchannelLogoutUri: String

  grantTypes: [String!]

  "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
  implicitGrantAccessTokenLifespan: String

  "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
  implicitGrantIdTokenLifespan: String

  "OAuth 2.0 Client JSON Web Key Set. Client's JSON Web Key Set [JWK] document, passed by value. The semantics of the jwks parameter are the same as the jwks_uri parameter, other than that the JWK Set is passed by value, rather than by reference. This parameter is intended only to be used by Clients that, for some reason, are unable to use the jwks_uri parameter, for instance, by native applications that might not have a location to host the contents of the JWK Set. If a Client can use jwks_uri, it MUST NOT use jwks. One significant downside of jwks is that it does not enable key rotation (which jwks_uri does, as described in Section 10 of OpenID Connect Core 1.0 [OpenID.Core]). The jwks_uri and jwks parameters MUST NOT be used together."
  jwks: Map

  "OAuth 2.0 Client JSON Web Key Set URI. Client's JSON Web Key Set [JWK] document URI, passed by reference. The semantics of the jwks_uri parameter are the same as the jwks parameter, other than that the JWK Set is passed by reference, rather than by value. The jwks_uri and jwks parameters MUST NOT be used together."
  jwksUri: String

  "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
  jwtBearerGrantAccessTokenLifespan: String

  "OAuth 2.0 Client Logo URI. A URL string referencing the client's logo."
  logoUri: String

  "OAuth 2.0 Client Metadata. Metadata is a map of key-value pairs that contain additional information about the client."
  metadata: Map

  "OAuth 2.0 Client Owner. Owner is a string identifying the owner of the OAuth 2.0 Client."
  owner: String

  "OAuth 2.0 Client Policy URI. PolicyURI is a URL string that points to a human-readable privacy policy document that describes how the deployment organization collects, uses, retains, and discloses personal data."
  policyUri: String

  "OAuth 2.0 Client Post Logout Redirect URIs. PostLogoutRedirectUris is an array of allowed URLs to which the RP is allowed to redirect the End-User's User Agent after a logout has been performed."
  postLogoutRedirectUris: [String!]

  "OAuth 2.0 Client Redirect URIs. RedirectUris is an array of allowed redirect URLs for the OAuth 2.0 Client."
  redirectUris: [String!]

  "OAuth 2.0 Client Response Types. ResponseTypes is an array of the OAuth 2.0 response type strings that the client can use at the Authorization Endpoint."
  responseTypes: [String!]

  "OAuth 2.0 Client Scope. Scope is a string containing a space-separated list of scope values (as described in Section 3.3 of OAuth 2.0 [RFC6749]) that the client can use when requesting access tokens."
  scope: String

  "OAuth 2.0 Client Sector Identifier URI. SectorIdentifierURI is a URL string using the https scheme referencing a file with a single JSON array of redirect_uri values."
  sectorIdentifierUri: String

  "OAuth 2.0 Client Subject Type. SubjectType requested for responses to this Client. The subject_types_supported Discovery parameter contains a list of the supported subject_type values for this server. Valid types include pairwise and public."
  subjectType: String

  "OAuth 2.0 Client Token Endpoint Auth Method. TokenEndpointAuthMethod is the requested Client Authentication method for the Token Endpoint. The token_endpoint_auth_methods_supported Discovery parameter contains a list of the authentication methods supported by this server. Valid types include client_secret_post, client_secret_basic, private_key_jwt, and none."
  tokenEndpointAuthMethod: String

  "OAuth 2.0 Client Token Endpoint Auth Signing Algorithm. TokenEndpointAuthSigningAlgorithm is the requested Client Authentication signing algorithm for the Token Endpoint. The token_endpoint_auth_signing_alg_values_supported Discovery parameter contains a list of the supported signing algorithms for the token endpoint."
  tokenEndpointAuthSigningAlgorithm: String

  "OAuth 2.0 Client Terms of Service URI. A URL string pointing to a human-readable terms of service document for the client that describes a contractual relationship between the end-user and the client that the end-user accepts when authorizing the client."
  tosUri: String

  "OAuth 2.0 Client Updated Date. UpdatedAt returns the timestamp of the client's last update."
  updatedAt: Time

  "OpenID Connect Userinfo Signed Response Algorithm. UserInfoSignedResponseAlg is a string containing the JWS signing algorithm (alg) parameter required for signing UserInfo Responses. The value none MAY be used, which indicates that the UserInfo Response will not be signed. The alg value RS256 MUST be used unless support for RS256 has been explicitly disabled. If support for RS256 has been disabled, the value none MUST be used."
  userinfoSignedResponseAlgorithm: String

  # "The organization that owns this OAuth2 Client."
  # organization: Organization!

  "The users and groups that are allowed to login with this OAuth2 Client."
  loginBindings: LoginBindings
}

"Representation of users and groups that are allowed to login with through OAuth2 Client."
type LoginBindings {
  "The users that are allowed to login with this OAuth2 Client."
  users: [User!]

  "The groups that are allowed to login with this OAuth2 Client."
  groups: [Group!]
}

input LoginBindingsInput {
  "The IDs or email addresses of the users that are allowed to login with this OAuth2 Client."
  users: [UserInput!]

  "The groups that are allowed to login with this OAuth2 Client."
  groups: [GroupInput!]
}

"Input an OAuth2Client using its clientId."
input OAuth2ClientInput {
  "The ID of the OAuth2 Client."
  clientId: ID!
}

extend type Query {
  "Get a list of all OAuth2 Clients."
  listOAuth2Clients: [OAuth2Client!]! @checkPermissions @isAuthenticated

  "Get a single OAuth2 Client by ID."
  getOAuth2Client(
    "The ID of the OAuth2 Client."
    clientId: ID!
  ): OAuth2Client @checkPermissions @isAuthenticated
}

extend type Mutation {
  "Create a new OAuth2 Client."
  createOAuth2Client(
    "OAuth 2.0 Client Allowed CORS Origins. AllowedCORSOrigins is an array of allowed CORS origins. If the array is empty, the value of the first element is considered valid."
    allowedCorsOrigins: [String!]

    "OAuth 2.0 Client Audience. Audience is an array of URLs that the OAuth 2.0 Client is allowed to request tokens for."
    audience: [String!]

    "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
    authorizationCodeGrantAccessTokenLifespan: String

    "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
    authorizationCodeGrantIdTokenLifespan: String

    "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
    authorizationCodeGrantRefreshTokenLifespan: String

    "OpenID Connect Back-Channel Logout Session Required  Boolean value specifying whether the RP requires that a sid (session ID) Claim be included in the Logout Token to identify the RP session with the OP when the backchannel_logout_uri is used. If omitted, the default value is false."
    backChannelLogoutSessionRequired: Boolean

    "OpenID Connect Back-Channel Logout URI. RP URL that will cause the RP to log itself out when sent a Logout Token by the OP."
    backChannelLogoutUri: String

    "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
    clientCredentialsGrantAccessTokenLifespan: String

    "OAuth 2.0 Client Name. The human-readable name of the client to be presented to the end-user during authorization."
    clientName: String

    "OAuth 2.0 Client Secret. The secret will be included in the create request as cleartext, and then never again. The secret is kept in hashed format and is not recoverable once lost."
    clientSecret: String

    "OAuth 2.0 Client Secret Expires At. The field is currently not supported and its value is always 0."
    ClientSecretExpiresAt: Int

    "OAuth 2.0 Client URI. ClientURI is a URL string of a web page providing information about the client. If present, the server SHOULD display this URL to the end-user in a clickable fashion."
    clientUri: String

    "OAuth 2.0 Client Contacts. Contacts is an array of strings representing ways to contact people responsible for this client, typically email addresses."
    contacts: [String!]

    "OpenID Connect Front-Channel Logout Session Required. Boolean value specifying whether the RP requires that iss (issuer) and sid (session ID) query parameters be included to identify the RP session with the OP when the frontchannel_logout_uri is used. If omitted, the default value is false."
    frontchannelLogoutSessionRequired: Boolean

    "OpenID Connect Front-Channel Logout URI. RP URL that will cause the RP to log itself out when rendered in an iframe by the OP."
    frontchannelLogoutUri: String

    grantTypes: [String!]

    "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
    implicitGrantAccessTokenLifespan: String

    "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
    implicitGrantIdTokenLifespan: String

    "OAuth 2.0 Client JSON Web Key Set. Client's JSON Web Key Set [JWK] document, passed by value. The semantics of the jwks parameter are the same as the jwks_uri parameter, other than that the JWK Set is passed by value, rather than by reference. This parameter is intended only to be used by Clients that, for some reason, are unable to use the jwks_uri parameter, for instance, by native applications that might not have a location to host the contents of the JWK Set. If a Client can use jwks_uri, it MUST NOT use jwks. One significant downside of jwks is that it does not enable key rotation (which jwks_uri does, as described in Section 10 of OpenID Connect Core 1.0 [OpenID.Core]). The jwks_uri and jwks parameters MUST NOT be used together."
    jwks: Map

    "OAuth 2.0 Client JSON Web Key Set URI. Client's JSON Web Key Set [JWK] document URI, passed by reference. The semantics of the jwks_uri parameter are the same as the jwks parameter, other than that the JWK Set is passed by reference, rather than by value. The jwks_uri and jwks parameters MUST NOT be used together."
    jwksUri: String

    "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
    jwtBearerGrantAccessTokenLifespan: String

    "OAuth 2.0 Client Logo URI. A URL string referencing the client's logo."
    logoUri: String

    "OAuth 2.0 Client Metadata. Metadata is a map of key-value pairs that contain additional information about the client."
    metadata: Map

    "OAuth 2.0 Client Policy URI. PolicyURI is a URL string that points to a human-readable privacy policy document that describes how the deployment organization collects, uses, retains, and discloses personal data."
    policyUri: String

    "OAuth 2.0 Client Post Logout Redirect URIs. PostLogoutRedirectUris is an array of allowed URLs to which the RP is allowed to redirect the End-User's User Agent after a logout has been performed."
    postLogoutRedirectUris: [String!]

    "OAuth 2.0 Client Redirect URIs. RedirectUris is an array of allowed redirect URLs for the OAuth 2.0 Client."
    redirectUris: [String!]

    "OAuth 2.0 Client Response Types. ResponseTypes is an array of the OAuth 2.0 response type strings that the client can use at the Authorization Endpoint."
    responseTypes: [String!]

    "OAuth 2.0 Client Scope. Scope is a string containing a space-separated list of scope values (as described in Section 3.3 of OAuth 2.0 [RFC6749]) that the client can use when requesting access tokens."
    scope: String

    "OAuth 2.0 Client Sector Identifier URI. SectorIdentifierURI is a URL string using the https scheme referencing a file with a single JSON array of redirect_uri values."
    sectorIdentifierUri: String

    "OAuth 2.0 Client Subject Type. SubjectType requested for responses to this Client. The subject_types_supported Discovery parameter contains a list of the supported subject_type values for this server. Valid types include pairwise and public."
    subjectType: String

    "OAuth 2.0 Client Token Endpoint Auth Method. TokenEndpointAuthMethod is the requested Client Authentication method for the Token Endpoint. The token_endpoint_auth_methods_supported Discovery parameter contains a list of the authentication methods supported by this server. Valid types include client_secret_post, client_secret_basic, private_key_jwt, and none."
    tokenEndpointAuthMethod: String

    "OAuth 2.0 Client Token Endpoint Auth Signing Algorithm. TokenEndpointAuthSigningAlgorithm is the requested Client Authentication signing algorithm for the Token Endpoint. The token_endpoint_auth_signing_alg_values_supported Discovery parameter contains a list of the supported signing algorithms for the token endpoint."
    tokenEndpointAuthSigningAlgorithm: String

    "OAuth 2.0 Client Terms of Service URI. A URL string pointing to a human-readable terms of service document for the client that describes a contractual relationship between the end-user and the client that the end-user accepts when authorizing the client."
    tosUri: String

    "OpenID Connect Userinfo Signed Response Algorithm. UserInfoSignedResponseAlg is a string containing the JWS signing algorithm (alg) parameter required for signing UserInfo Responses. The value none MAY be used, which indicates that the UserInfo Response will not be signed. The alg value RS256 MUST be used unless support for RS256 has been explicitly disabled. If support for RS256 has been disabled, the value none MUST be used."
    userinfoSignedResponseAlgorithm: String

    "The users and groups that are allowed to login with this OAuth2 Client."
    loginBindings: LoginBindingsInput
  ): OAuth2Client! @checkPermissions @isAuthenticated

  "Update an OAuth 2 Client."
  updateOAuth2Client(
    "OAuth 2.0 Client Allowed CORS Origins. AllowedCORSOrigins is an array of allowed CORS origins. If the array is empty, the value of the first element is considered valid."
    allowedCorsOrigins: [String!]

    "OAuth 2.0 Client Audience. Audience is an array of URLs that the OAuth 2.0 Client is allowed to request tokens for."
    audience: [String!]

    "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
    authorizationCodeGrantAccessTokenLifespan: String

    "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
    authorizationCodeGrantIdTokenLifespan: String

    "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
    authorizationCodeGrantRefreshTokenLifespan: String

    "OpenID Connect Back-Channel Logout Session Required  Boolean value specifying whether the RP requires that a sid (session ID) Claim be included in the Logout Token to identify the RP session with the OP when the backchannel_logout_uri is used. If omitted, the default value is false."
    backChannelLogoutSessionRequired: Boolean

    "OpenID Connect Back-Channel Logout URI. RP URL that will cause the RP to log itself out when sent a Logout Token by the OP."
    backChannelLogoutUri: String

    "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
    clientCredentialsGrantAccessTokenLifespan: String

    "OAuth 2.0 Client ID. The ID is autogenerated and immutable."
    clientId: String!

    "OAuth 2.0 Client Name. The human-readable name of the client to be presented to the end-user during authorization."
    clientName: String

    "OAuth 2.0 Client Secret. The secret will be included in the create request as cleartext, and then never again. The secret is kept in hashed format and is not recoverable once lost."
    clientSecret: String

    "OAuth 2.0 Client Secret Expires At. The field is currently not supported and its value is always 0."
    ClientSecretExpiresAt: Int

    "OAuth 2.0 Client URI. ClientURI is a URL string of a web page providing information about the client. If present, the server SHOULD display this URL to the end-user in a clickable fashion."
    clientUri: String

    "OAuth 2.0 Client Contacts. Contacts is an array of strings representing ways to contact people responsible for this client, typically email addresses."
    contacts: [String!]

    "OpenID Connect Front-Channel Logout Session Required. Boolean value specifying whether the RP requires that iss (issuer) and sid (session ID) query parameters be included to identify the RP session with the OP when the frontchannel_logout_uri is used. If omitted, the default value is false."
    frontchannelLogoutSessionRequired: Boolean

    "OpenID Connect Front-Channel Logout URI. RP URL that will cause the RP to log itself out when rendered in an iframe by the OP."
    frontchannelLogoutUri: String

    grantTypes: [String!]

    "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
    implicitGrantAccessTokenLifespan: String

    "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
    implicitGrantIdTokenLifespan: String

    "OAuth 2.0 Client JSON Web Key Set. Client's JSON Web Key Set [JWK] document, passed by value. The semantics of the jwks parameter are the same as the jwks_uri parameter, other than that the JWK Set is passed by value, rather than by reference. This parameter is intended only to be used by Clients that, for some reason, are unable to use the jwks_uri parameter, for instance, by native applications that might not have a location to host the contents of the JWK Set. If a Client can use jwks_uri, it MUST NOT use jwks. One significant downside of jwks is that it does not enable key rotation (which jwks_uri does, as described in Section 10 of OpenID Connect Core 1.0 [OpenID.Core]). The jwks_uri and jwks parameters MUST NOT be used together."
    jwks: Map

    "OAuth 2.0 Client JSON Web Key Set URI. Client's JSON Web Key Set [JWK] document URI, passed by reference. The semantics of the jwks_uri parameter are the same as the jwks parameter, other than that the JWK Set is passed by reference, rather than by value. The jwks_uri and jwks parameters MUST NOT be used together."
    jwksUri: String

    "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
    jwtBearerGrantAccessTokenLifespan: String

    "OAuth 2.0 Client Logo URI. A URL string referencing the client's logo."
    logoUri: String

    "OAuth 2.0 Client Metadata. Metadata is a map of key-value pairs that contain additional information about the client."
    metadata: Map

    "OAuth 2.0 Client Policy URI. PolicyURI is a URL string that points to a human-readable privacy policy document that describes how the deployment organization collects, uses, retains, and discloses personal data."
    policyUri: String

    "OAuth 2.0 Client Post Logout Redirect URIs. PostLogoutRedirectUris is an array of allowed URLs to which the RP is allowed to redirect the End-User's User Agent after a logout has been performed."
    postLogoutRedirectUris: [String!]

    "OAuth 2.0 Client Redirect URIs. RedirectUris is an array of allowed redirect URLs for the OAuth 2.0 Client."
    redirectUris: [String!]

    "OAuth 2.0 Client Response Types. ResponseTypes is an array of the OAuth 2.0 response type strings that the client can use at the Authorization Endpoint."
    responseTypes: [String!]

    "OAuth 2.0 Client Scope. Scope is a string containing a space-separated list of scope values (as described in Section 3.3 of OAuth 2.0 [RFC6749]) that the client can use when requesting access tokens."
    scope: String

    "OAuth 2.0 Client Sector Identifier URI. SectorIdentifierURI is a URL string using the https scheme referencing a file with a single JSON array of redirect_uri values."
    sectorIdentifierUri: String

    "OAuth 2.0 Client Subject Type. SubjectType requested for responses to this Client. The subject_types_supported Discovery parameter contains a list of the supported subject_type values for this server. Valid types include pairwise and public."
    subjectType: String

    "OAuth 2.0 Client Token Endpoint Auth Method. TokenEndpointAuthMethod is the requested Client Authentication method for the Token Endpoint. The token_endpoint_auth_methods_supported Discovery parameter contains a list of the authentication methods supported by this server. Valid types include client_secret_post, client_secret_basic, private_key_jwt, and none."
    tokenEndpointAuthMethod: String

    "OAuth 2.0 Client Token Endpoint Auth Signing Algorithm. TokenEndpointAuthSigningAlgorithm is the requested Client Authentication signing algorithm for the Token Endpoint. The token_endpoint_auth_signing_alg_values_supported Discovery parameter contains a list of the supported signing algorithms for the token endpoint."
    tokenEndpointAuthSigningAlgorithm: String

    "OAuth 2.0 Client Terms of Service URI. A URL string pointing to a human-readable terms of service document for the client that describes a contractual relationship between the end-user and the client that the end-user accepts when authorizing the client."
    tosUri: String

    "OpenID Connect Userinfo Signed Response Algorithm. UserInfoSignedResponseAlg is a string containing the JWS signing algorithm (alg) parameter required for signing UserInfo Responses. The value none MAY be used, which indicates that the UserInfo Response will not be signed. The alg value RS256 MUST be used unless support for RS256 has been explicitly disabled. If support for RS256 has been disabled, the value none MUST be used."
    userinfoSignedResponseAlgorithm: String

    "The users and groups that are allowed to login with this OAuth2 Client."
    loginBindings: LoginBindingsInput
  ): OAuth2Client! @checkPermissions @isAuthenticated

  "Delete an OAuth2 Client."
  deleteOAuth2Client(
    "OAuth 2.0 Client ID. The ID is autogenerated and immutable."
    clientId: String!
  ): OAuth2Client! @checkPermissions @isAuthenticated
}
`, BuiltIn: false},
	{Name: "../oauth2consent.graphqls", Input: `"OAuth2ConsentRequest represents an OAuth 2.0 consent request."
type OAuth2ConsentRequest {
  "ACR represents the Authentication AuthorizationContext Class Reference value for this authentication session. You can use it to express that, for example, a user authenticated using two factor authentication."
  acr: String

  "AMR represents the Authentication Methods References. It lists the method used to authenticate the end-user. For instance, if the end-user authenticated using password and OTP, the AMR value would be [\"pwd\", \"otp\"]."
  amr: [String!]

  "The challenge is a random string which is used to identify the consent request."
  challenge: String!

  "The client is the OAuth 2.0 Client requesting the OAuth 2.0 Authorization."
  client: OAuth2Client!

  "Context contains arbitrary context that is forwarded from the login request. This is useful if you want to pass data from the login request to the consent request."
  context: Map

  "LoginChallenge is the login challenge this consent challenge belongs to. It can be used to associate a login and consent request in the login & consent app."
  loginChallenge: String

  "LoginSessionID is the login session ID. If the user-agent reuses a login session (via cookie / remember flag) this ID will remain the same. If the user-agent did not have an existing authentication session (e.g. remember is false) this will be a new random value. This value is used as the \"sid\" parameter in the ID Token and in OIDC Front-/Back- channel logout. It's value can generally be used to associate consecutive login requests by a certain user."
  loginSessionId: String

  "OIDCContext contains the OIDC context of the request. If the OAuth 2.0 Authorization request was not an OpenID Connect request, this value will be nil."
  oidcContext: OidcContext

  "RequestURL is the original OAuth 2.0 Authorization URL requested by the OAuth 2.0 client. It is the URL which initiates the OAuth 2.0 Authorization Code or OAuth 2.0 Implicit flow. This URL is typically not needed, but might come in handy if you want to deal with additional request parameters."
  requestUrl: String

  "RequestedAccessTokenAudience contains the audience (client) that the OAuth 2.0 Client requested the OAuth 2.0 Access Token to be issued for."
  requestedAccessTokenAudience: [String!]

  "RequestedScope contains the OAuth 2.0 Scope requested by the OAuth 2.0 Client."
  requestedScope: [String!]

  "Skip is true when the client has requested the same scopes from the same user before. If this is true, you can skip asking the user to grant the requested scopes, or you can force showing the UI by setting this value to false."
  skip: Boolean

  "Subject is the user ID of the end-user that authenticated. This value will be set to the 'sub' claim in the ID Token."
  subject: String!

  "The URL to redirect to if an error occurred."
  redirectTo: String
}

"OIDC Context for a consent request."
type OidcContext {
  "ACRValues is the Authentication AuthorizationContext Class Reference requested in the OAuth 2.0 Authorization request. It is a parameter defined by OpenID Connect and expresses which level of authentication (e.g. 2FA) is required.  OpenID Connect defines it as follows: > Requested Authentication AuthorizationContext Class Reference values. Space-separated string that specifies the acr values that the Authorization Server is being requested to use for processing this Authentication Request, with the values appearing in order of preference. The Authentication AuthorizationContext Class satisfied by the authentication performed is returned as the acr Claim Value, as specified in Section 2. The acr Claim is requested as a Voluntary Claim by this parameter."
  acrValues: [String!]

  "Display is the display mode requested in the OAuth 2.0 Authorization request. It is a parameter defined by OpenID Connect and expresses how the Authorization Server displays authentication and consent user interfaces to the End-User.  OpenID Connect defines it as follows: > ASCII string value that specifies how the Authorization Server displays the authentication and consent user interface pages to the End-User. The defined values are: page: The Authorization Server SHOULD display the authentication and consent UI consistent with a full User Agent page view. If the display parameter is not specified, this is the default display mode. popup: The Authorization Server SHOULD display the authentication and consent UI consistent with a popup User Agent window. The popup User Agent window should be of an appropriate size for a login-focused dialog and should not obscure the entire window that it is popping up over. touch: The Authorization Server SHOULD display the authentication and consent UI consistent with a device that leverages a touch interface. > The display parameter is used only if the prompt parameter value is not none. If the prompt parameter value is none, the display parameter is ignored."
  display: String

  "IDTokenHintClaims contains the claims from the ID Token hint if it was present in the OAuth 2.0 Authorization request."
  idTokenHintClaims: Map

  "LoginHint is the login hint requested in the OAuth 2.0 Authorization request. It is a parameter defined by OpenID Connect and expresses the preferred login identifier the End-User might use to log in (if necessary).  OpenID Connect defines it as follows: > Hint to the Authorization Server about the login identifier the End-User might use to log in (if necessary). > This hint can be used by an RP if it first asks the End-User for their e-mail address (or other identifier) and then wants to pass that value as a hint to the discovered authorization service. > It is RECOMMENDED that the hint value match the value used for discovery. > This value MAY also be a phone number in the format specified for the phone_number Claim. > The use of this parameter is left to the OP's discretion."
  loginHint: String

  "UILocales is the End-User'id preferred languages and scripts for the user interface, represented as a space-separated list of BCP47 [RFC5646] language tag values, ordered by preference. For instance, the value \"fr-CA fr en\" represents a preference for French as spoken in Canada, then French (without a region designation), followed by English (without a region designation). An error SHOULD NOT result if some or all of the requested locales are not supported by the OpenID Provider."
  uiLocales: [String!]
}

type OAuth2RedirectTo {
  "RedirectTo can be used to redirect the user-agent to a specific location. This is useful if you want to redirect the user-agent to a specific location after the consent flow has been completed."
  redirectTo: String!
}

input AcceptOAuth2ConsentRequestSession {
  "AccessToken sets session data for the access and refresh token, as well as any future tokens issued by the refresh grant. Keep in mind that this data will be available to anyone performing OAuth 2.0 Challenge Introspection. If only your services can perform OAuth 2.0 Challenge Introspection, this is usually fine. But if third parties can access that endpoint as well, sensitive data from the session might be exposed to them. Use with care!"
  accessToken: Map

  "IDToken sets session data for the OpenID Connect ID token. Keep in mind that the session'id payloads are readable by anyone that has access to the ID Challenge. Use with care!"
  idToken: Map
}

extend type Query {
  "OAuth2ConsentRequest returns the OAuth 2.0 consent request information."
  oauth2ConsentRequest(
    "The challenge to fetch the consent request for."
    challenge: String!
  ): OAuth2ConsentRequest
}

extend type Mutation {
  "AcceptOAuth2ConsentRequest accepts an OAuth 2.0 consent request. If the request was granted, a code or access token will be issued. If the request was denied, the request will be rejected."
  acceptOAuth2ConsentRequest(
    "The challenge to accept."
    challenge: String!

    "The audience to grant."
    grantAccessTokenAudience: [String!]

    "The scopes to grant."
    grantScope: [String!]

    "Remember, if set to true, tells ORY Hydra to remember this consent authorization and reuse it if the same client asks the same user for the same, or a subset of, scope."
    remember: Boolean

    "RememberFor sets how long the consent authorization should be remembered for in seconds. If set to 0, the authorization will be remembered indefinitely."
    rememberFor: Int
  ): OAuth2RedirectTo!

  "RejectOAuth2ConsentRequest rejects an OAuth 2.0 consent request."
  rejectOAuth2ConsentRequest(
    "The challenge to reject."
    challenge: String!
  ): OAuth2RedirectTo!
}
`, BuiltIn: false},
	{Name: "../oauth2login.graphqls", Input: `"OAuth2LoginRequest represents an OAuth 2.0 login request."
type OAuth2LoginRequest {
  "The challenge is a random string which is used to identify the consent request."
  challenge: String!

  "The client is the OAuth 2.0 Client requesting the OAuth 2.0 Authorization."
  client: OAuth2Client!

  "OIDCContext contains the OIDC context of the request. If the OAuth 2.0 Authorization request was not an OpenID Connect request, this value will be nil."
  oidcContext: OidcContext

  "RequestURL is the original OAuth 2.0 Authorization URL requested by the OAuth 2.0 client. It is the URL which initiates the OAuth 2.0 Authorization Code or OAuth 2.0 Implicit flow. This URL is typically not needed, but might come in handy if you want to deal with additional request parameters."
  requestUrl: String

  "RequestedAccessTokenAudience contains the audience (client) that the OAuth 2.0 Client requested the OAuth 2.0 Access Token to be issued for."
  requestedAccessTokenAudience: [String!]

  "RequestedScope contains the OAuth 2.0 Scope requested by the OAuth 2.0 Client."
  requestedScope: [String!]

  "SessionID is the login session ID. If the user-agent reuses a login session (via cookie / remember flag) this ID will remain the same. If the user-agent did not have an existing authentication session (e.g. remember is false) this will be a new random value. This value is used as the 'sid' parameter in the ID Token and in OIDC Front-/Back- channel logout. It's value can generally be used to associate consecutive login requests by a certain user."
  sessionId: String

  "Skip is true when the client has requested the same scopes from the same user before. If this is true, you can skip asking the user to grant the requested scopes, or you can force showing the UI by setting this value to false."
  skip: Boolean

  "Subject is the user ID of the end-user that authenticated. This value will be set to the 'sub' claim in the ID Token."
  subject: String!

  "The URL to redirect to if an error occurred."
  redirectTo: String
}

extend type Query {
  "OAuth2LoginRequest returns the OAuth 2.0 login request information."
  oauth2LoginRequest(
    "The challenge to fetch the login request for."
    challenge: String!
  ): OAuth2LoginRequest
}

extend type Mutation {
  "AcceptOAuth2LoginRequest accepts an OAuth 2.0 login request. If the request was granted, a code or access token will be issued. If the request was denied, the request will be rejected."
  acceptOAuth2LoginRequest(
    "The challenge to accept."
    challenge: String!

    "ACR represents the Authentication AuthorizationContext Class Reference value for this authentication session. You can use it to express that, for example, a user authenticated using two factor authentication."
    acr: String

    "AMR represents the Authentication Methods References. It lists the method used to authenticate the end-user. For instance, if the end-user authenticated using password and OTP, the AMR value would be ['pwd', 'otp']."
    amr: [String!]

    "Context contains arbitrary context that is forwarded from the login request. This is useful if you want to pass data from the login request to the consent request."
    context: Map

    "Remember, if set to true, tells ORY Hydra to remember this login authorization and reuse it if the same client asks the same user for the same, or a subset of, scope."
    remember: Boolean

    "RememberFor sets how long the login authorization should be remembered for in seconds. If set to 0, the authorization will be remembered indefinitely."
    rememberFor: Int

    "Subject is the user ID of the end-user that authenticated."
    subject: String!
  ): OAuth2RedirectTo!

  "RejectOAuth2LoginRequest rejects an OAuth 2.0 login request."
  rejectOAuth2LoginRequest(
    "The challenge to reject."
    challenge: String!
  ): OAuth2RedirectTo!
}
`, BuiltIn: false},
	{Name: "../observabilitytenant.graphqls", Input: `scalar Duration
scalar FloatMap
scalar StringMap

"Representation a tenant in the Grafana observability stack where metrics, logs and traces can be sent to or retrieved from."
type ObservabilityTenant {
  "The unique id of the tenant."
  id: ID!

  "The display name of the tenant."
  displayName: String

  # "The organization that the tenant belongs to."
  # organization: Organization!

  "The users, groups or clients that are admins of the observability tenant and can change its permissions."
  admins: ObservabilityTenantPermissionBindings

  "The users, groups or clients that can read metrics from the tenant."
  metricsReaders: ObservabilityTenantPermissionBindings

  "The users, groups or clients that can write metrics to the tenant."
  metricsWriters: ObservabilityTenantPermissionBindings

  "The users, groups or clients that can delete metrics from the tenant."
  metricsDeleters: ObservabilityTenantPermissionBindings

  "The users, groups or clients that can read metric rules from the tenant."
  metricsRulesReaders: ObservabilityTenantPermissionBindings

  "The users, groups or clients that can write metric rules to the tenant."
  metricsRulesWriters: ObservabilityTenantPermissionBindings

  "The users, groups or clients that can delete metric rules from the tenant."
  metricsRulesDeleters: ObservabilityTenantPermissionBindings

  "The users, groups or clients that can view the Alertmanager UI and get the Alertmanager configuration for a tenant."
  metricsAlertsReaders: ObservabilityTenantPermissionBindings

  "The users, groups or clients that can create silences in the Alertmanager UI and create and delete the Alertmanager configuration for a tenant."
  metricsAlertsWriters: ObservabilityTenantPermissionBindings

  "The users, groups or clients that can read logs from the tenant."
  logsReaders: ObservabilityTenantPermissionBindings

  "The users, groups or clients that can write logs to the tenant."
  logsWriters: ObservabilityTenantPermissionBindings

  "The users, groups or clients that can delete logs from the tenant."
  logsDeleters: ObservabilityTenantPermissionBindings

  "The users, groups or clients that can read log rules from the tenant."
  logsRulesReaders: ObservabilityTenantPermissionBindings

  "The users, groups or clients that can write log rules to the tenant."
  logsRulesWriters: ObservabilityTenantPermissionBindings

  "The users, groups or clients that can delete log rules from the tenant."
  logsRulesDeleters: ObservabilityTenantPermissionBindings

  "The users, groups or clients that can read traces from the tenant."
  tracesReaders: ObservabilityTenantPermissionBindings

  "The users, groups or clients that can write traces to the tenant."
  tracesWriters: ObservabilityTenantPermissionBindings

  "The limits of the tenant."
  limits: ObservabilityTenantLimits
}

"Representation of the limits of a tenant."
type ObservabilityTenantLimits {
  "The limits for Mimir for the tenant."
  mimir: MimirLimits

  "The limits for Loki for the tenant."
  loki: LokiLimits

  "The limits for Tempo for the tenant."
  tempo: TempoLimits
}

"Inputs for the limits of a tenant."
input ObservabilityTenantLimitsInput {
  "The limits for Mimir for the tenant."
  mimir: MimirLimitsInput

  "The limits for Loki for the tenant."
  loki: LokiLimitsInput

  "The limits for Tempo for the tenant."
  tempo: TempoLimitsInput
}

"Representation of the users, groups and oauth2 clients that have a set of permissions on a tenant."
type ObservabilityTenantPermissionBindings {
  "The users that have a particular permission on a tenant."
  users: [User!]

  "The groups have a particular permission on a tenant."
  groups: [Group!]

  "The oauth2 clients  have a particular permission on a tenant."
  oauth2Clients: [OAuth2Client!] # TODO: add check so that an oauth2 client can only be added to a single tenant
}

input ObservabilityTenantPermissionBindingsInput {
  "The IDs or email addresses of users that can view a tenant."
  users: [UserInput!]

  "The names of groups that can view a tenant."
  groups: [GroupInput!]

  "The clientIDs oauth2 clients that can send data a tenant."
  oauth2Clients: [OAuth2ClientInput!]
}

extend type Query {
  "Get a list of all users."
  listObservabilityTenants: [ObservabilityTenant!]! @checkPermissions @isAuthenticated

  getObservabilityTenant(
    "The unique ID of the tenant."
    id: ID!
  ): ObservabilityTenant! @checkPermissions @isAuthenticated
}

extend type Mutation {
  "Create an observability tenant."
  createObservabilityTenant(
    "The unique ID of the tenant."
    id: ID!
    "The display name of the tenant."
    name: String
    "The users, groups or clients that are admins of the observability tenant and can change its permissions."
    admins: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can read metrics from the tenant."
    metricsReaders: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can write metrics to the tenant."
    metricsWriters: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can delete metrics from the tenant."
    metricsDeleters: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can read metric rules from the tenant."
    metricsRulesReaders: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can write metric rules to the tenant."
    metricsRulesWriters: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can delete metric rules from the tenant."
    metricsRulesDeleters: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can view the Alertmanager UI and get the Alertmanager configuration for a tenant."
    metricsAlertsReaders: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can create silences in the Alertmanager UI and create and delete the Alertmanager configuration for a tenant."
    metricsAlertsWriters: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can read logs from the tenant."
    logsReaders: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can write logs to the tenant."
    logsWriters: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can delete logs from the tenant."
    logsDeleters: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can read log rules from the tenant."
    logsRulesReaders: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can write log rules to the tenant."
    logsRulesWriters: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can delete log rules from the tenant."
    logsRulesDeleters: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can read traces from the tenant."
    tracesReaders: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can write traces to the tenant."
    tracesWriters: ObservabilityTenantPermissionBindingsInput
    "The limits for the tenant."
    limits: ObservabilityTenantLimitsInput
  ): ObservabilityTenant! @checkPermissions @isAuthenticated

  "Update an observability tenant."
  updateObservabilityTenant(
    "The unique ID of the tenant."
    id: ID!
    "The display name of the tenant."
    name: String
    "The users, groups or clients that are admins of the observability tenant and can change its permissions."
    admins: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can read metrics from the tenant."
    metricsReaders: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can write metrics to the tenant."
    metricsWriters: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can delete metrics from the tenant."
    metricsDeleters: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can read metric rules from the tenant."
    metricsRulesReaders: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can write metric rules to the tenant."
    metricsRulesWriters: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can delete metric rules from the tenant."
    metricsRulesDeleters: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can view the Alertmanager UI and get the Alertmanager configuration for a tenant."
    metricsAlertsReaders: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can create silences in the Alertmanager UI and create and delete the Alertmanager configuration for a tenant."
    metricsAlertsWriters: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can read logs from the tenant."
    logsReaders: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can write logs to the tenant."
    logsWriters: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can delete logs from the tenant."
    logsDeleters: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can read log rules from the tenant."
    logsRulesReaders: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can write log rules to the tenant."
    logsRulesWriters: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can delete log rules from the tenant."
    logsRulesDeleters: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can read traces from the tenant."
    tracesReaders: ObservabilityTenantPermissionBindingsInput
    "The users, groups or clients that can write traces to the tenant."
    tracesWriters: ObservabilityTenantPermissionBindingsInput
    "The limits for the tenant."
    limits: ObservabilityTenantLimitsInput
  ): ObservabilityTenant! @checkPermissions @isAuthenticated

  "Delete an observability tenant."
  deleteObservabilityTenant(
    "The unique ID of the tenant."
    id: ID!
  ): ObservabilityTenant! @checkPermissions @isAuthenticated
}
`, BuiltIn: false},
	{Name: "../organization.graphqls", Input: `"Representation an Organization in the auth stack."
type Organization {
  # "The unique name of the organization."
  # name: String!

  "The users that are admins of the organization."
  admins: [User!]
}

extend type Query {
  # "Get a list of all users."
  # listOrganizations: [Organization!]! @checkPermissions @isAuthenticated

  "Get a single organization by name."
  organization: Organization! @checkPermissions @isAuthenticated
}

extend type Mutation {
  "Create a new organization."
  organization(
    # "The name of the organization."
    # name: String!,

    "The IDs or email addresses of the users that are organization admins."
    admins: [UserInput!]
    ): Organization! @checkPermissions @isAuthenticated
}
`, BuiltIn: false},
	{Name: "../prometheus_types.graphqls", Input: `scalar UInt
type RelabelConfig {
  sourceLabels: [String]
  separator: String
  regex: String
  modulus: UInt
  targetLabel: String
  replacement: String
  action: RelabelAction
}
enum RelabelAction {
  replace
  Replace
  keep
  Keep
  drop
  Drop
  hashmod
  HashMod
  labelmap
  LabelMap
  labeldrop
  LabelDrop
  labelkeep
  LabelKeep
  lowercase
  Lowercase
  uppercase
  Uppercase
  keepequal
  KeepEqual
  dropequal
  DropEqual
}
input RelabelConfigInput {
  sourceLabels: [String]
  separator: String
  regex: String
  modulus: UInt
  targetLabel: String
  replacement: String
  action: RelabelAction
}
`, BuiltIn: false},
	{Name: "../tempo_limits.graphqls", Input: `scalar BoolMap

"Representation of the limits for Tempo for a tenant."
type TempoLimits {
  ingestionRateStrategy: String
  ingestionRateLimitBytes: Int
  ingestionBurstSizeBytes: Int
  maxLocalTracesPerUser: Int
  maxGlobalTracesPerUser: Int
  forwarders: [String!]
  metricsGeneratorRingSize: Int
  metricsGeneratorProcessors: [String!]
  metricsGeneratorMaxActiveSeries: UInt
  metricsGeneratorCollectionInterval: Duration
  metricsGeneratorDisableCollection: Boolean
  metricsGeneratorForwarderQueueSize: Int
  metricsGeneratorForwarderWorkers: Int
  metricsGeneratorProcessorServiceGraphsHistogramBuckets: [Float]
  metricsGeneratorProcessorServiceGraphsDimensions: [String!]
  metricsGeneratorProcessorServiceGraphsPeerAttributes: [String!]
  metricsGeneratorProcessorServiceGraphsEnableClientServerPrefix: Boolean
  metricsGeneratorProcessorSpanMetricsHistogramBuckets: [Float]
  metricsGeneratorProcessorSpanMetricsDimensions: [String!]
  metricsGeneratorProcessorSpanMetricsIntrinsicDimensions: BoolMap
  metricsGeneratorProcessorSpanMetricsFilterPolicies: [FilterPolicy!]
  metricsGeneratorProcessorSpanMetricsDimensionMappings: [DimensionMappings!]
  metricsGeneratorProcessorSpanMetricsEnableTargetInfo: Boolean
  metricsGeneratorProcessorLocalBlocksMaxLiveTraces: UInt
  metricsGeneratorProcessorLocalBlocksMaxBlockDuration: Duration
  metricsGeneratorProcessorLocalBlocksMaxBlockBytes: UInt
  metricsGeneratorProcessorLocalBlocksFlushCheckPeriod: Duration
  metricsGeneratorProcessorLocalBlocksTraceIdlePeriod: Duration
  metricsGeneratorProcessorLocalBlocksCompleteBlockTimeout: Duration
  blockRetention: Duration
  maxBytesPerTagValuesQuery: Int
  maxBlocksPerTagValuesQuery: Int
  maxSearchDuration: Duration
  maxBytesPerTrace: Int
}

type FilterPolicy {
  include: PolicyMatch
  exclude: PolicyMatch
}

type PolicyMatch {
  matchType: MatchType
  attributes: [MatchPolicyAttribute!]
}

enum MatchType {
  strict
  regex
}

type MatchPolicyAttribute {
  key: String
  value: Map
}

type DimensionMappings {
  name: String
  sourceLabel: [String!]
  join: String
}

"Input of the limits for Tempo for a tenant."
input TempoLimitsInput {
  ingestionRateStrategy: String
  ingestionRateLimitBytes: Int
  ingestionBurstSizeBytes: Int
  maxLocalTracesPerUser: Int
  maxGlobalTracesPerUser: Int
  forwarders: [String!]
  metricsGeneratorRingSize: Int
  metricsGeneratorProcessors: [String!]
  metricsGeneratorMaxActiveSeries: UInt
  metricsGeneratorCollectionInterval: Duration
  metricsGeneratorDisableCollection: Boolean
  metricsGeneratorForwarderQueueSize: Int
  metricsGeneratorForwarderWorkers: Int
  metricsGeneratorProcessorServiceGraphsHistogramBuckets: [Float]
  metricsGeneratorProcessorServiceGraphsDimensions: [String!]
  metricsGeneratorProcessorServiceGraphsPeerAttributes: [String!]
  metricsGeneratorProcessorServiceGraphsEnableClientServerPrefix: Boolean
  metricsGeneratorProcessorSpanMetricsHistogramBuckets: [Float]
  metricsGeneratorProcessorSpanMetricsDimensions: [String!]
  metricsGeneratorProcessorSpanMetricsIntrinsicDimensions: BoolMap
  metricsGeneratorProcessorSpanMetricsFilterPolicies: [FilterPolicyInput!]
  metricsGeneratorProcessorSpanMetricsDimensionMappings: [DimensionMappingsInput!]
  metricsGeneratorProcessorSpanMetricsEnableTargetInfo: Boolean
  metricsGeneratorProcessorLocalBlocksMaxLiveTraces: UInt
  metricsGeneratorProcessorLocalBlocksMaxBlockDuration: Duration
  metricsGeneratorProcessorLocalBlocksMaxBlockBytes: UInt
  metricsGeneratorProcessorLocalBlocksFlushCheckPeriod: Duration
  metricsGeneratorProcessorLocalBlocksTraceIdlePeriod: Duration
  metricsGeneratorProcessorLocalBlocksCompleteBlockTimeout: Duration
  blockRetention: Duration
  maxBytesPerTagValuesQuery: Int
  maxBlocksPerTagValuesQuery: Int
  maxSearchDuration: Duration
  maxBytesPerTrace: Int
}

input FilterPolicyInput {
  include: PolicyMatchInput
  exclude: PolicyMatchInput
}

input PolicyMatchInput {
  matchType: MatchType
  attributes: [MatchPolicyAttributeInput!]
}

input MatchPolicyAttributeInput {
  key: String
  value: Map
}

input DimensionMappingsInput {
  name: String
  sourceLabel: [String!]
  join: String
}
`, BuiltIn: false},
	{Name: "../user.graphqls", Input: `"Representation of the information about a user sourced from Kratos."
type User {
  "The unique ID of the user."
  id: ID!

  "The user's full name."
  name: Name

  "The user's email address."
  email: String!

  "The groups the user belongs to."
  groups: [Group!]

  # "The organization the user belongs to."
  # organization: Organization!

  "The link a user can use to recover their account."
  recoveryLink: String
}

"The first and last name of a user."
type Name {
  "The user's first name."
  first: String

  "The user's last name."
  last: String
}

input NameInput {
  "The user's first name."
  first: String

  "The user's last name."
  last: String
}

"Input for a user using either ID or email."
input UserInput {
  "The user IDs."
  id: ID

  "The user's email address."
  email: String
}

type Query {
  "Get a list of all users."
  listUsers: [User!]! @checkPermissions @isAuthenticated

  "Get a user by ID or email."
  getUser(id: ID, email: String): User! @checkPermissions @isAuthenticated
}

type Mutation {
  "Create a new user."
  createUser(
    "The user's email address."
    email: String!

    "The user's name."
    name: NameInput

  ): User! @checkPermissions @isAuthenticated

  "Delete a user."
  deleteUser(
    "The ID of the user to delete."
    id: ID!
  ): User! @checkPermissions @isAuthenticated
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_acceptOAuth2ConsentRequest_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["challenge"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("challenge"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["challenge"] = arg0
	var arg1 []string
	if tmp, ok := rawArgs["grantAccessTokenAudience"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("grantAccessTokenAudience"))
		arg1, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["grantAccessTokenAudience"] = arg1
	var arg2 []string
	if tmp, ok := rawArgs["grantScope"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("grantScope"))
		arg2, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["grantScope"] = arg2
	var arg3 *bool
	if tmp, ok := rawArgs["remember"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remember"))
		arg3, err = ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["remember"] = arg3
	var arg4 *int64
	if tmp, ok := rawArgs["rememberFor"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rememberFor"))
		arg4, err = ec.unmarshalOInt2ᚖint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["rememberFor"] = arg4
	return args, nil
}

func (ec *executionContext) field_Mutation_acceptOAuth2LoginRequest_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["challenge"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("challenge"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["challenge"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["acr"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("acr"))
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["acr"] = arg1
	var arg2 []string
	if tmp, ok := rawArgs["amr"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amr"))
		arg2, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["amr"] = arg2
	var arg3 map[string]interface{}
	if tmp, ok := rawArgs["context"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("context"))
		arg3, err = ec.unmarshalOMap2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["context"] = arg3
	var arg4 *bool
	if tmp, ok := rawArgs["remember"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remember"))
		arg4, err = ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["remember"] = arg4
	var arg5 *int64
	if tmp, ok := rawArgs["rememberFor"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rememberFor"))
		arg5, err = ec.unmarshalOInt2ᚖint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["rememberFor"] = arg5
	var arg6 string
	if tmp, ok := rawArgs["subject"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subject"))
		arg6, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["subject"] = arg6
	return args, nil
}

func (ec *executionContext) field_Mutation_createOAuth2Client_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["allowedCorsOrigins"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("allowedCorsOrigins"))
		arg0, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["allowedCorsOrigins"] = arg0
	var arg1 []string
	if tmp, ok := rawArgs["audience"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("audience"))
		arg1, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["audience"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["authorizationCodeGrantAccessTokenLifespan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizationCodeGrantAccessTokenLifespan"))
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authorizationCodeGrantAccessTokenLifespan"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["authorizationCodeGrantIdTokenLifespan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizationCodeGrantIdTokenLifespan"))
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authorizationCodeGrantIdTokenLifespan"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["authorizationCodeGrantRefreshTokenLifespan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizationCodeGrantRefreshTokenLifespan"))
		arg4, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authorizationCodeGrantRefreshTokenLifespan"] = arg4
	var arg5 *bool
	if tmp, ok := rawArgs["backChannelLogoutSessionRequired"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backChannelLogoutSessionRequired"))
		arg5, err = ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["backChannelLogoutSessionRequired"] = arg5
	var arg6 *string
	if tmp, ok := rawArgs["backChannelLogoutUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backChannelLogoutUri"))
		arg6, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["backChannelLogoutUri"] = arg6
	var arg7 *string
	if tmp, ok := rawArgs["clientCredentialsGrantAccessTokenLifespan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientCredentialsGrantAccessTokenLifespan"))
		arg7, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clientCredentialsGrantAccessTokenLifespan"] = arg7
	var arg8 *string
	if tmp, ok := rawArgs["clientName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientName"))
		arg8, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clientName"] = arg8
	var arg9 *string
	if tmp, ok := rawArgs["clientSecret"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientSecret"))
		arg9, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clientSecret"] = arg9
	var arg10 *int64
	if tmp, ok := rawArgs["ClientSecretExpiresAt"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ClientSecretExpiresAt"))
		arg10, err = ec.unmarshalOInt2ᚖint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["ClientSecretExpiresAt"] = arg10
	var arg11 *string
	if tmp, ok := rawArgs["clientUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientUri"))
		arg11, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clientUri"] = arg11
	var arg12 []string
	if tmp, ok := rawArgs["contacts"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contacts"))
		arg12, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["contacts"] = arg12
	var arg13 *bool
	if tmp, ok := rawArgs["frontchannelLogoutSessionRequired"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("frontchannelLogoutSessionRequired"))
		arg13, err = ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["frontchannelLogoutSessionRequired"] = arg13
	var arg14 *string
	if tmp, ok := rawArgs["frontchannelLogoutUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("frontchannelLogoutUri"))
		arg14, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["frontchannelLogoutUri"] = arg14
	var arg15 []string
	if tmp, ok := rawArgs["grantTypes"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("grantTypes"))
		arg15, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["grantTypes"] = arg15
	var arg16 *string
	if tmp, ok := rawArgs["implicitGrantAccessTokenLifespan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("implicitGrantAccessTokenLifespan"))
		arg16, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["implicitGrantAccessTokenLifespan"] = arg16
	var arg17 *string
	if tmp, ok := rawArgs["implicitGrantIdTokenLifespan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("implicitGrantIdTokenLifespan"))
		arg17, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["implicitGrantIdTokenLifespan"] = arg17
	var arg18 map[string]interface{}
	if tmp, ok := rawArgs["jwks"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jwks"))
		arg18, err = ec.unmarshalOMap2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["jwks"] = arg18
	var arg19 *string
	if tmp, ok := rawArgs["jwksUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jwksUri"))
		arg19, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["jwksUri"] = arg19
	var arg20 *string
	if tmp, ok := rawArgs["jwtBearerGrantAccessTokenLifespan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jwtBearerGrantAccessTokenLifespan"))
		arg20, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["jwtBearerGrantAccessTokenLifespan"] = arg20
	var arg21 *string
	if tmp, ok := rawArgs["logoUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logoUri"))
		arg21, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["logoUri"] = arg21
	var arg22 map[string]interface{}
	if tmp, ok := rawArgs["metadata"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metadata"))
		arg22, err = ec.unmarshalOMap2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["metadata"] = arg22
	var arg23 *string
	if tmp, ok := rawArgs["policyUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("policyUri"))
		arg23, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["policyUri"] = arg23
	var arg24 []string
	if tmp, ok := rawArgs["postLogoutRedirectUris"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("postLogoutRedirectUris"))
		arg24, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["postLogoutRedirectUris"] = arg24
	var arg25 []string
	if tmp, ok := rawArgs["redirectUris"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("redirectUris"))
		arg25, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["redirectUris"] = arg25
	var arg26 []string
	if tmp, ok := rawArgs["responseTypes"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("responseTypes"))
		arg26, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["responseTypes"] = arg26
	var arg27 *string
	if tmp, ok := rawArgs["scope"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scope"))
		arg27, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["scope"] = arg27
	var arg28 *string
	if tmp, ok := rawArgs["sectorIdentifierUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sectorIdentifierUri"))
		arg28, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sectorIdentifierUri"] = arg28
	var arg29 *string
	if tmp, ok := rawArgs["subjectType"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subjectType"))
		arg29, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["subjectType"] = arg29
	var arg30 *string
	if tmp, ok := rawArgs["tokenEndpointAuthMethod"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenEndpointAuthMethod"))
		arg30, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tokenEndpointAuthMethod"] = arg30
	var arg31 *string
	if tmp, ok := rawArgs["tokenEndpointAuthSigningAlgorithm"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenEndpointAuthSigningAlgorithm"))
		arg31, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tokenEndpointAuthSigningAlgorithm"] = arg31
	var arg32 *string
	if tmp, ok := rawArgs["tosUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tosUri"))
		arg32, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tosUri"] = arg32
	var arg33 *string
	if tmp, ok := rawArgs["userinfoSignedResponseAlgorithm"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userinfoSignedResponseAlgorithm"))
		arg33, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userinfoSignedResponseAlgorithm"] = arg33
	var arg34 *model.LoginBindingsInput
	if tmp, ok := rawArgs["loginBindings"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("loginBindings"))
		arg34, err = ec.unmarshalOLoginBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐLoginBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["loginBindings"] = arg34
	return args, nil
}

func (ec *executionContext) field_Mutation_createObservabilityTenant_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg1
	var arg2 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["admins"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("admins"))
		arg2, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["admins"] = arg2
	var arg3 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["metricsReaders"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsReaders"))
		arg3, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["metricsReaders"] = arg3
	var arg4 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["metricsWriters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsWriters"))
		arg4, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["metricsWriters"] = arg4
	var arg5 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["metricsDeleters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsDeleters"))
		arg5, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["metricsDeleters"] = arg5
	var arg6 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["metricsRulesReaders"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsRulesReaders"))
		arg6, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["metricsRulesReaders"] = arg6
	var arg7 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["metricsRulesWriters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsRulesWriters"))
		arg7, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["metricsRulesWriters"] = arg7
	var arg8 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["metricsRulesDeleters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsRulesDeleters"))
		arg8, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["metricsRulesDeleters"] = arg8
	var arg9 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["metricsAlertsReaders"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsAlertsReaders"))
		arg9, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["metricsAlertsReaders"] = arg9
	var arg10 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["metricsAlertsWriters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsAlertsWriters"))
		arg10, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["metricsAlertsWriters"] = arg10
	var arg11 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["logsReaders"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logsReaders"))
		arg11, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["logsReaders"] = arg11
	var arg12 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["logsWriters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logsWriters"))
		arg12, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["logsWriters"] = arg12
	var arg13 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["logsDeleters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logsDeleters"))
		arg13, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["logsDeleters"] = arg13
	var arg14 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["logsRulesReaders"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logsRulesReaders"))
		arg14, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["logsRulesReaders"] = arg14
	var arg15 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["logsRulesWriters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logsRulesWriters"))
		arg15, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["logsRulesWriters"] = arg15
	var arg16 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["logsRulesDeleters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logsRulesDeleters"))
		arg16, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["logsRulesDeleters"] = arg16
	var arg17 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["tracesReaders"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tracesReaders"))
		arg17, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tracesReaders"] = arg17
	var arg18 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["tracesWriters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tracesWriters"))
		arg18, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tracesWriters"] = arg18
	var arg19 *model.ObservabilityTenantLimitsInput
	if tmp, ok := rawArgs["limits"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limits"))
		arg19, err = ec.unmarshalOObservabilityTenantLimitsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantLimitsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limits"] = arg19
	return args, nil
}

func (ec *executionContext) field_Mutation_createUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["email"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["email"] = arg0
	var arg1 *model.NameInput
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg1, err = ec.unmarshalONameInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐNameInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteGroup_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteOAuth2Client_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["clientId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clientId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteObservabilityTenant_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_group_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 []*model.UserInput
	if tmp, ok := rawArgs["members"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("members"))
		arg1, err = ec.unmarshalOUserInput2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐUserInputᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["members"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_organization_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []*model.UserInput
	if tmp, ok := rawArgs["admins"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("admins"))
		arg0, err = ec.unmarshalOUserInput2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐUserInputᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["admins"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_rejectOAuth2ConsentRequest_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["challenge"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("challenge"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["challenge"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_rejectOAuth2LoginRequest_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["challenge"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("challenge"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["challenge"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateOAuth2Client_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["allowedCorsOrigins"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("allowedCorsOrigins"))
		arg0, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["allowedCorsOrigins"] = arg0
	var arg1 []string
	if tmp, ok := rawArgs["audience"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("audience"))
		arg1, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["audience"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["authorizationCodeGrantAccessTokenLifespan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizationCodeGrantAccessTokenLifespan"))
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authorizationCodeGrantAccessTokenLifespan"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["authorizationCodeGrantIdTokenLifespan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizationCodeGrantIdTokenLifespan"))
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authorizationCodeGrantIdTokenLifespan"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["authorizationCodeGrantRefreshTokenLifespan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizationCodeGrantRefreshTokenLifespan"))
		arg4, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authorizationCodeGrantRefreshTokenLifespan"] = arg4
	var arg5 *bool
	if tmp, ok := rawArgs["backChannelLogoutSessionRequired"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backChannelLogoutSessionRequired"))
		arg5, err = ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["backChannelLogoutSessionRequired"] = arg5
	var arg6 *string
	if tmp, ok := rawArgs["backChannelLogoutUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backChannelLogoutUri"))
		arg6, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["backChannelLogoutUri"] = arg6
	var arg7 *string
	if tmp, ok := rawArgs["clientCredentialsGrantAccessTokenLifespan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientCredentialsGrantAccessTokenLifespan"))
		arg7, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clientCredentialsGrantAccessTokenLifespan"] = arg7
	var arg8 string
	if tmp, ok := rawArgs["clientId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientId"))
		arg8, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clientId"] = arg8
	var arg9 *string
	if tmp, ok := rawArgs["clientName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientName"))
		arg9, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clientName"] = arg9
	var arg10 *string
	if tmp, ok := rawArgs["clientSecret"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientSecret"))
		arg10, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clientSecret"] = arg10
	var arg11 *int64
	if tmp, ok := rawArgs["ClientSecretExpiresAt"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ClientSecretExpiresAt"))
		arg11, err = ec.unmarshalOInt2ᚖint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["ClientSecretExpiresAt"] = arg11
	var arg12 *string
	if tmp, ok := rawArgs["clientUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientUri"))
		arg12, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clientUri"] = arg12
	var arg13 []string
	if tmp, ok := rawArgs["contacts"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contacts"))
		arg13, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["contacts"] = arg13
	var arg14 *bool
	if tmp, ok := rawArgs["frontchannelLogoutSessionRequired"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("frontchannelLogoutSessionRequired"))
		arg14, err = ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["frontchannelLogoutSessionRequired"] = arg14
	var arg15 *string
	if tmp, ok := rawArgs["frontchannelLogoutUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("frontchannelLogoutUri"))
		arg15, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["frontchannelLogoutUri"] = arg15
	var arg16 []string
	if tmp, ok := rawArgs["grantTypes"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("grantTypes"))
		arg16, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["grantTypes"] = arg16
	var arg17 *string
	if tmp, ok := rawArgs["implicitGrantAccessTokenLifespan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("implicitGrantAccessTokenLifespan"))
		arg17, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["implicitGrantAccessTokenLifespan"] = arg17
	var arg18 *string
	if tmp, ok := rawArgs["implicitGrantIdTokenLifespan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("implicitGrantIdTokenLifespan"))
		arg18, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["implicitGrantIdTokenLifespan"] = arg18
	var arg19 map[string]interface{}
	if tmp, ok := rawArgs["jwks"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jwks"))
		arg19, err = ec.unmarshalOMap2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["jwks"] = arg19
	var arg20 *string
	if tmp, ok := rawArgs["jwksUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jwksUri"))
		arg20, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["jwksUri"] = arg20
	var arg21 *string
	if tmp, ok := rawArgs["jwtBearerGrantAccessTokenLifespan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jwtBearerGrantAccessTokenLifespan"))
		arg21, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["jwtBearerGrantAccessTokenLifespan"] = arg21
	var arg22 *string
	if tmp, ok := rawArgs["logoUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logoUri"))
		arg22, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["logoUri"] = arg22
	var arg23 map[string]interface{}
	if tmp, ok := rawArgs["metadata"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metadata"))
		arg23, err = ec.unmarshalOMap2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["metadata"] = arg23
	var arg24 *string
	if tmp, ok := rawArgs["policyUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("policyUri"))
		arg24, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["policyUri"] = arg24
	var arg25 []string
	if tmp, ok := rawArgs["postLogoutRedirectUris"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("postLogoutRedirectUris"))
		arg25, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["postLogoutRedirectUris"] = arg25
	var arg26 []string
	if tmp, ok := rawArgs["redirectUris"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("redirectUris"))
		arg26, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["redirectUris"] = arg26
	var arg27 []string
	if tmp, ok := rawArgs["responseTypes"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("responseTypes"))
		arg27, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["responseTypes"] = arg27
	var arg28 *string
	if tmp, ok := rawArgs["scope"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scope"))
		arg28, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["scope"] = arg28
	var arg29 *string
	if tmp, ok := rawArgs["sectorIdentifierUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sectorIdentifierUri"))
		arg29, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sectorIdentifierUri"] = arg29
	var arg30 *string
	if tmp, ok := rawArgs["subjectType"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subjectType"))
		arg30, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["subjectType"] = arg30
	var arg31 *string
	if tmp, ok := rawArgs["tokenEndpointAuthMethod"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenEndpointAuthMethod"))
		arg31, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tokenEndpointAuthMethod"] = arg31
	var arg32 *string
	if tmp, ok := rawArgs["tokenEndpointAuthSigningAlgorithm"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenEndpointAuthSigningAlgorithm"))
		arg32, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tokenEndpointAuthSigningAlgorithm"] = arg32
	var arg33 *string
	if tmp, ok := rawArgs["tosUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tosUri"))
		arg33, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tosUri"] = arg33
	var arg34 *string
	if tmp, ok := rawArgs["userinfoSignedResponseAlgorithm"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userinfoSignedResponseAlgorithm"))
		arg34, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userinfoSignedResponseAlgorithm"] = arg34
	var arg35 *model.LoginBindingsInput
	if tmp, ok := rawArgs["loginBindings"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("loginBindings"))
		arg35, err = ec.unmarshalOLoginBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐLoginBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["loginBindings"] = arg35
	return args, nil
}

func (ec *executionContext) field_Mutation_updateObservabilityTenant_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg1
	var arg2 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["admins"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("admins"))
		arg2, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["admins"] = arg2
	var arg3 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["metricsReaders"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsReaders"))
		arg3, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["metricsReaders"] = arg3
	var arg4 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["metricsWriters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsWriters"))
		arg4, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["metricsWriters"] = arg4
	var arg5 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["metricsDeleters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsDeleters"))
		arg5, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["metricsDeleters"] = arg5
	var arg6 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["metricsRulesReaders"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsRulesReaders"))
		arg6, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["metricsRulesReaders"] = arg6
	var arg7 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["metricsRulesWriters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsRulesWriters"))
		arg7, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["metricsRulesWriters"] = arg7
	var arg8 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["metricsRulesDeleters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsRulesDeleters"))
		arg8, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["metricsRulesDeleters"] = arg8
	var arg9 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["metricsAlertsReaders"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsAlertsReaders"))
		arg9, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["metricsAlertsReaders"] = arg9
	var arg10 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["metricsAlertsWriters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsAlertsWriters"))
		arg10, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["metricsAlertsWriters"] = arg10
	var arg11 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["logsReaders"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logsReaders"))
		arg11, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["logsReaders"] = arg11
	var arg12 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["logsWriters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logsWriters"))
		arg12, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["logsWriters"] = arg12
	var arg13 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["logsDeleters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logsDeleters"))
		arg13, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["logsDeleters"] = arg13
	var arg14 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["logsRulesReaders"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logsRulesReaders"))
		arg14, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["logsRulesReaders"] = arg14
	var arg15 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["logsRulesWriters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logsRulesWriters"))
		arg15, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["logsRulesWriters"] = arg15
	var arg16 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["logsRulesDeleters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logsRulesDeleters"))
		arg16, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["logsRulesDeleters"] = arg16
	var arg17 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["tracesReaders"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tracesReaders"))
		arg17, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tracesReaders"] = arg17
	var arg18 *model.ObservabilityTenantPermissionBindingsInput
	if tmp, ok := rawArgs["tracesWriters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tracesWriters"))
		arg18, err = ec.unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tracesWriters"] = arg18
	var arg19 *model.ObservabilityTenantLimitsInput
	if tmp, ok := rawArgs["limits"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limits"))
		arg19, err = ec.unmarshalOObservabilityTenantLimitsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantLimitsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limits"] = arg19
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getOAuth2Client_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["clientId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clientId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getObservabilityTenant_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalOID2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["email"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["email"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_oauth2ConsentRequest_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["challenge"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("challenge"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["challenge"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_oauth2LoginRequest_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["challenge"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("challenge"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["challenge"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

func (ec *executionContext) _queryMiddleware(ctx context.Context, obj *ast.OperationDefinition, next func(ctx context.Context) (interface{}, error)) graphql.Marshaler {

	for _, d := range obj.Directives {
		switch d.Name {
		case "checkPermissions":
			n := next
			next = func(ctx context.Context) (interface{}, error) {
				if ec.directives.CheckPermissions == nil {
					return nil, errors.New("directive checkPermissions is not implemented")
				}
				return ec.directives.CheckPermissions(ctx, obj, n)
			}
		case "isAuthenticated":
			n := next
			next = func(ctx context.Context) (interface{}, error) {
				if ec.directives.IsAuthenticated == nil {
					return nil, errors.New("directive isAuthenticated is not implemented")
				}
				return ec.directives.IsAuthenticated(ctx, obj, n)
			}
		}
	}
	tmp, err := next(ctx)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if data, ok := tmp.(graphql.Marshaler); ok {
		return data
	}
	ec.Errorf(ctx, `unexpected type %T from directive, should be graphql.Marshaler`, tmp)
	return graphql.Null

}

func (ec *executionContext) _mutationMiddleware(ctx context.Context, obj *ast.OperationDefinition, next func(ctx context.Context) (interface{}, error)) graphql.Marshaler {

	for _, d := range obj.Directives {
		switch d.Name {
		case "checkPermissions":
			n := next
			next = func(ctx context.Context) (interface{}, error) {
				if ec.directives.CheckPermissions == nil {
					return nil, errors.New("directive checkPermissions is not implemented")
				}
				return ec.directives.CheckPermissions(ctx, obj, n)
			}
		case "isAuthenticated":
			n := next
			next = func(ctx context.Context) (interface{}, error) {
				if ec.directives.IsAuthenticated == nil {
					return nil, errors.New("directive isAuthenticated is not implemented")
				}
				return ec.directives.IsAuthenticated(ctx, obj, n)
			}
		}
	}
	tmp, err := next(ctx)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if data, ok := tmp.(graphql.Marshaler); ok {
		return data
	}
	ec.Errorf(ctx, `unexpected type %T from directive, should be graphql.Marshaler`, tmp)
	return graphql.Null

}

func (ec *executionContext) _fieldMiddleware(ctx context.Context, obj interface{}, next graphql.Resolver) interface{} {
	fc := graphql.GetFieldContext(ctx)
	for _, d := range fc.Field.Directives {
		switch d.Name {
		case "checkPermissions":
			n := next
			next = func(ctx context.Context) (interface{}, error) {
				if ec.directives.CheckPermissions == nil {
					return nil, errors.New("directive checkPermissions is not implemented")
				}
				return ec.directives.CheckPermissions(ctx, obj, n)
			}
		case "isAuthenticated":
			n := next
			next = func(ctx context.Context) (interface{}, error) {
				if ec.directives.IsAuthenticated == nil {
					return nil, errors.New("directive isAuthenticated is not implemented")
				}
				return ec.directives.IsAuthenticated(ctx, obj, n)
			}
		}
	}
	res, err := ec.ResolverMiddleware(ctx, next)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return res
}

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _BlockedQuery_pattern(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.BlockedQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BlockedQuery_pattern(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pattern, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BlockedQuery_pattern(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlockedQuery",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlockedQuery_regex(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.BlockedQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BlockedQuery_regex(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Regex, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BlockedQuery_regex(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlockedQuery",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlockedQuery_hash(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.BlockedQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BlockedQuery_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hash, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint32)
	fc.Result = res
	return ec.marshalOUInt2ᚖuint32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BlockedQuery_hash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlockedQuery",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlockedQuery_types(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.BlockedQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BlockedQuery_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.BlockedQuery().Types(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.BlockedQueryType)
	fc.Result = res
	return ec.marshalOBlockedQueryType2ᚕgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐBlockedQueryTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BlockedQuery_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlockedQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BlockedQueryType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DimensionMappings_name(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.DimensionMappings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DimensionMappings_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DimensionMappings_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DimensionMappings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DimensionMappings_sourceLabel(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.DimensionMappings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DimensionMappings_sourceLabel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SourceLabel, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DimensionMappings_sourceLabel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DimensionMappings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DimensionMappings_join(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.DimensionMappings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DimensionMappings_join(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Join, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DimensionMappings_join(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DimensionMappings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterPolicy_include(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.FilterPolicy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterPolicy_include(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Include, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1alpha1.PolicyMatch)
	fc.Result = res
	return ec.marshalOPolicyMatch2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐPolicyMatch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterPolicy_include(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterPolicy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "matchType":
				return ec.fieldContext_PolicyMatch_matchType(ctx, field)
			case "attributes":
				return ec.fieldContext_PolicyMatch_attributes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PolicyMatch", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterPolicy_exclude(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.FilterPolicy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterPolicy_exclude(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Exclude, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1alpha1.PolicyMatch)
	fc.Result = res
	return ec.marshalOPolicyMatch2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐPolicyMatch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterPolicy_exclude(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterPolicy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "matchType":
				return ec.fieldContext_PolicyMatch_matchType(ctx, field)
			case "attributes":
				return ec.fieldContext_PolicyMatch_attributes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PolicyMatch", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Group_name(ctx context.Context, field graphql.CollectedField, obj *model.Group) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Group_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Group_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Group",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Group_members(ctx context.Context, field graphql.CollectedField, obj *model.Group) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Group_members(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Group().Members(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.User)
	fc.Result = res
	return ec.marshalOUser2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐUserᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Group_members(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Group",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "recoveryLink":
				return ec.fieldContext_User_recoveryLink(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoginBindings_users(ctx context.Context, field graphql.CollectedField, obj *model.LoginBindings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoginBindings_users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.LoginBindings().Users(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.User)
	fc.Result = res
	return ec.marshalOUser2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐUserᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoginBindings_users(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoginBindings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "recoveryLink":
				return ec.fieldContext_User_recoveryLink(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoginBindings_groups(ctx context.Context, field graphql.CollectedField, obj *model.LoginBindings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoginBindings_groups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.LoginBindings().Groups(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Group)
	fc.Result = res
	return ec.marshalOGroup2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐGroupᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoginBindings_groups(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoginBindings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Group_name(ctx, field)
			case "members":
				return ec.fieldContext_Group_members(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Group", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_ingestionRateStrategy(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_ingestionRateStrategy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IngestionRateStrategy, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_ingestionRateStrategy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_ingestionRateMB(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_ingestionRateMB(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IngestionRateMB, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2ᚖfloat64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_ingestionRateMB(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_ingestionBurstSizeMB(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_ingestionBurstSizeMB(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IngestionBurstSizeMB, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2ᚖfloat64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_ingestionBurstSizeMB(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_maxLabelNameLength(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_maxLabelNameLength(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxLabelNameLength, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_maxLabelNameLength(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_maxLabelValueLength(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_maxLabelValueLength(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxLabelValueLength, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_maxLabelValueLength(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_maxLabelNamesPerSeries(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_maxLabelNamesPerSeries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxLabelNamesPerSeries, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_maxLabelNamesPerSeries(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_rejectOldSamples(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_rejectOldSamples(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RejectOldSamples, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_rejectOldSamples(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_rejectOldSamplesMaxAge(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_rejectOldSamplesMaxAge(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RejectOldSamplesMaxAge, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_rejectOldSamplesMaxAge(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_creationGracePeriod(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_creationGracePeriod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationGracePeriod, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_creationGracePeriod(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_enforceMetricName(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_enforceMetricName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnforceMetricName, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_enforceMetricName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_maxLineSize(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_maxLineSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxLineSize, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUInt2ᚖuint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_maxLineSize(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_maxLineSizeTruncate(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_maxLineSizeTruncate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxLineSizeTruncate, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_maxLineSizeTruncate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_incrementDuplicateTimestamp(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_incrementDuplicateTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IncrementDuplicateTimestamp, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_incrementDuplicateTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_maxLocalStreamsPerUser(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_maxLocalStreamsPerUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxLocalStreamsPerUser, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_maxLocalStreamsPerUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_maxGlobalStreamsPerUser(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_maxGlobalStreamsPerUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxGlobalStreamsPerUser, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_maxGlobalStreamsPerUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_unorderedWrites(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_unorderedWrites(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UnorderedWrites, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_unorderedWrites(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_perStreamRateLimit(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_perStreamRateLimit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PerStreamRateLimit, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUInt2ᚖuint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_perStreamRateLimit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_perStreamRateLimitBurst(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_perStreamRateLimitBurst(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PerStreamRateLimitBurst, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUInt2ᚖuint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_perStreamRateLimitBurst(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_maxChunksPerQuery(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_maxChunksPerQuery(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxChunksPerQuery, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_maxChunksPerQuery(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_maxQuerySeries(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_maxQuerySeries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxQuerySeries, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_maxQuerySeries(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_maxQueryLookback(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_maxQueryLookback(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxQueryLookback, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_maxQueryLookback(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_maxQueryLength(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_maxQueryLength(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxQueryLength, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_maxQueryLength(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_maxQueryRange(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_maxQueryRange(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxQueryRange, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_maxQueryRange(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_maxQueryParallelism(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_maxQueryParallelism(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxQueryParallelism, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_maxQueryParallelism(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_tsdbMaxQueryParallelism(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_tsdbMaxQueryParallelism(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TSDBMaxQueryParallelism, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_tsdbMaxQueryParallelism(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_tsdbMaxBytesPerShard(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_tsdbMaxBytesPerShard(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TSDBMaxBytesPerShard, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUInt2ᚖuint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_tsdbMaxBytesPerShard(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_cardinalityLimit(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_cardinalityLimit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CardinalityLimit, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_cardinalityLimit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_maxStreamsMatchersPerQuery(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_maxStreamsMatchersPerQuery(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxStreamsMatchersPerQuery, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_maxStreamsMatchersPerQuery(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_maxConcurrentTailRequests(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_maxConcurrentTailRequests(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxConcurrentTailRequests, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_maxConcurrentTailRequests(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_maxEntriesLimitPerQuery(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_maxEntriesLimitPerQuery(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxEntriesLimitPerQuery, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_maxEntriesLimitPerQuery(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_maxCacheFreshness(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_maxCacheFreshness(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxCacheFreshness, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_maxCacheFreshness(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_maxStatsCacheFreshness(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_maxStatsCacheFreshness(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxStatsCacheFreshness, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_maxStatsCacheFreshness(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_maxQueriersPerTenant(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_maxQueriersPerTenant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxQueriersPerTenant, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_maxQueriersPerTenant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_queryReadyIndexNumDays(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_queryReadyIndexNumDays(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryReadyIndexNumDays, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_queryReadyIndexNumDays(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_queryTimeout(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_queryTimeout(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryTimeout, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_queryTimeout(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_querySplitDuration(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_querySplitDuration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QuerySplitDuration, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_querySplitDuration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_minShardingLookback(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_minShardingLookback(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MinShardingLookback, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_minShardingLookback(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_maxQueryBytesRead(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_maxQueryBytesRead(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxQueryBytesRead, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUInt2ᚖuint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_maxQueryBytesRead(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_maxQuerierBytesRead(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_maxQuerierBytesRead(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxQuerierBytesRead, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUInt2ᚖuint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_maxQuerierBytesRead(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_volumeEnabled(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_volumeEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VolumeEnabled, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_volumeEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_volumeMaxSeries(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_volumeMaxSeries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VolumeMaxSeries, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_volumeMaxSeries(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_rulerEvaluationDelay(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_rulerEvaluationDelay(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RulerEvaluationDelay, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_rulerEvaluationDelay(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_rulerMaxRulesPerRuleGroup(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_rulerMaxRulesPerRuleGroup(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RulerMaxRulesPerRuleGroup, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_rulerMaxRulesPerRuleGroup(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_rulerMaxRuleGroupsPerTenant(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_rulerMaxRuleGroupsPerTenant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RulerMaxRuleGroupsPerTenant, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_rulerMaxRuleGroupsPerTenant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_rulerAlertManagerConfig(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_rulerAlertManagerConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RulerAlertManagerConfig, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1alpha1.RulerAlertManagerConfig)
	fc.Result = res
	return ec.marshalORulerAlertManagerConfig2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐRulerAlertManagerConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_rulerAlertManagerConfig(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "alertmanagerURL":
				return ec.fieldContext_RulerAlertManagerConfig_alertmanagerURL(ctx, field)
			case "alertmanagerDiscovery":
				return ec.fieldContext_RulerAlertManagerConfig_alertmanagerDiscovery(ctx, field)
			case "alertmanagerRefreshInterval":
				return ec.fieldContext_RulerAlertManagerConfig_alertmanagerRefreshInterval(ctx, field)
			case "alertmanangerEnableV2API":
				return ec.fieldContext_RulerAlertManagerConfig_alertmanangerEnableV2API(ctx, field)
			case "alertRelabelConfigs":
				return ec.fieldContext_RulerAlertManagerConfig_alertRelabelConfigs(ctx, field)
			case "notificationQueueCapacity":
				return ec.fieldContext_RulerAlertManagerConfig_notificationQueueCapacity(ctx, field)
			case "notificationTimeout":
				return ec.fieldContext_RulerAlertManagerConfig_notificationTimeout(ctx, field)
			case "notifier":
				return ec.fieldContext_RulerAlertManagerConfig_notifier(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RulerAlertManagerConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_rulerTenantShardSize(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_rulerTenantShardSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RulerTenantShardSize, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_rulerTenantShardSize(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_rulerRemoteWriteDisabled(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_rulerRemoteWriteDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RulerRemoteWriteDisabled, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_rulerRemoteWriteDisabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_rulerRemoteEvaluationTimeout(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_rulerRemoteEvaluationTimeout(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RulerRemoteEvaluationTimeout, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_rulerRemoteEvaluationTimeout(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_rulerRemoteEvaluationMaxResponseSize(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_rulerRemoteEvaluationMaxResponseSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RulerRemoteEvaluationMaxResponseSize, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int64)
	fc.Result = res
	return ec.marshalOInt2ᚖint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_rulerRemoteEvaluationMaxResponseSize(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_deletionMode(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_deletionMode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletionMode, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_deletionMode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_retentionPeriod(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_retentionPeriod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RetentionPeriod, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_retentionPeriod(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_streamRetention(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_streamRetention(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StreamRetention, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]v1alpha1.StreamRetention)
	fc.Result = res
	return ec.marshalOStreamRetention2ᚕgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐStreamRetentionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_streamRetention(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "period":
				return ec.fieldContext_StreamRetention_period(ctx, field)
			case "priority":
				return ec.fieldContext_StreamRetention_priority(ctx, field)
			case "selector":
				return ec.fieldContext_StreamRetention_selector(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StreamRetention", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_shardStreams(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_shardStreams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShardStreams, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1alpha1.ShardstreamsConfig)
	fc.Result = res
	return ec.marshalOShardstreamsConfig2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐShardstreamsConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_shardStreams(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "enabled":
				return ec.fieldContext_ShardstreamsConfig_enabled(ctx, field)
			case "loggingEnabled":
				return ec.fieldContext_ShardstreamsConfig_loggingEnabled(ctx, field)
			case "desiredRate":
				return ec.fieldContext_ShardstreamsConfig_desiredRate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ShardstreamsConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_blockedQueries(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_blockedQueries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BlockedQueries, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*v1alpha1.BlockedQuery)
	fc.Result = res
	return ec.marshalOBlockedQuery2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐBlockedQueryᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_blockedQueries(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pattern":
				return ec.fieldContext_BlockedQuery_pattern(ctx, field)
			case "regex":
				return ec.fieldContext_BlockedQuery_regex(ctx, field)
			case "hash":
				return ec.fieldContext_BlockedQuery_hash(ctx, field)
			case "types":
				return ec.fieldContext_BlockedQuery_types(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BlockedQuery", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_requiredLabels(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_requiredLabels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequiredLabels, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_requiredLabels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_requiredNumberLabels(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_requiredNumberLabels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequiredNumberLabels, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_requiredNumberLabels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LokiLimits_indexGatewayShardSize(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.LokiLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LokiLimits_indexGatewayShardSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IndexGatewayShardSize, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LokiLimits_indexGatewayShardSize(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LokiLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchPolicyAttribute_key(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MatchPolicyAttribute) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchPolicyAttribute_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchPolicyAttribute_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchPolicyAttribute",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchPolicyAttribute_value(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MatchPolicyAttribute) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchPolicyAttribute_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchPolicyAttribute().Value(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchPolicyAttribute_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchPolicyAttribute",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_requestRate(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_requestRate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestRate, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2ᚖfloat64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_requestRate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_requestBurstSize(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_requestBurstSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestBurstSize, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_requestBurstSize(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_ingestionRate(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_ingestionRate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IngestionRate, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2ᚖfloat64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_ingestionRate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_ingestionBurstSize(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_ingestionBurstSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IngestionBurstSize, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_ingestionBurstSize(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_acceptHASamples(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_acceptHASamples(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AcceptHASamples, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_acceptHASamples(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_haClusterLabel(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_haClusterLabel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HAClusterLabel, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_haClusterLabel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_haReplicaLabel(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_haReplicaLabel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HAReplicaLabel, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_haReplicaLabel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_haMaxClusters(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_haMaxClusters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HAMaxClusters, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_haMaxClusters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_dropLabels(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_dropLabels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DropLabels, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2ᚕᚖstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_dropLabels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_maxLabelNameLength(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_maxLabelNameLength(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxLabelNameLength, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_maxLabelNameLength(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_maxLabelValueLength(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_maxLabelValueLength(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxLabelValueLength, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_maxLabelValueLength(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_maxLabelNamesPerSeries(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_maxLabelNamesPerSeries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxLabelNamesPerSeries, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_maxLabelNamesPerSeries(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_maxMetadataLength(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_maxMetadataLength(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxMetadataLength, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_maxMetadataLength(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_maxNativeHistogramBuckets(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_maxNativeHistogramBuckets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxNativeHistogramBuckets, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_maxNativeHistogramBuckets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_creationGracePeriod(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_creationGracePeriod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationGracePeriod, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_creationGracePeriod(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_enforceMetadataMetricName(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_enforceMetadataMetricName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnforceMetadataMetricName, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_enforceMetadataMetricName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_ingestionTenantShardSize(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_ingestionTenantShardSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IngestionTenantShardSize, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_ingestionTenantShardSize(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_metricRelabelConfigs(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_metricRelabelConfigs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MetricRelabelConfigs, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]v1alpha1.RelabelConfig)
	fc.Result = res
	return ec.marshalORelabelConfig2ᚕgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐRelabelConfigᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_metricRelabelConfigs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "sourceLabels":
				return ec.fieldContext_RelabelConfig_sourceLabels(ctx, field)
			case "separator":
				return ec.fieldContext_RelabelConfig_separator(ctx, field)
			case "regex":
				return ec.fieldContext_RelabelConfig_regex(ctx, field)
			case "modulus":
				return ec.fieldContext_RelabelConfig_modulus(ctx, field)
			case "targetLabel":
				return ec.fieldContext_RelabelConfig_targetLabel(ctx, field)
			case "replacement":
				return ec.fieldContext_RelabelConfig_replacement(ctx, field)
			case "action":
				return ec.fieldContext_RelabelConfig_action(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RelabelConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_maxGlobalSeriesPerUser(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_maxGlobalSeriesPerUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxGlobalSeriesPerUser, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_maxGlobalSeriesPerUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_maxGlobalSeriesPerMetric(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_maxGlobalSeriesPerMetric(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxGlobalSeriesPerMetric, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_maxGlobalSeriesPerMetric(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_maxGlobalMetricsWithMetadataPerUser(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_maxGlobalMetricsWithMetadataPerUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxGlobalMetricsWithMetadataPerUser, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_maxGlobalMetricsWithMetadataPerUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_maxGlobalMetadataPerMetric(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_maxGlobalMetadataPerMetric(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxGlobalMetadataPerMetric, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_maxGlobalMetadataPerMetric(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_maxGlobalExemplarsPerUser(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_maxGlobalExemplarsPerUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxGlobalExemplarsPerUser, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_maxGlobalExemplarsPerUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_nativeHistogramsIngestionEnabled(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_nativeHistogramsIngestionEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NativeHistogramsIngestionEnabled, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_nativeHistogramsIngestionEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_activeSeriesCustomTrackersConfig(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_activeSeriesCustomTrackersConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ActiveSeriesCustomTrackersConfig, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]string)
	fc.Result = res
	return ec.marshalOStringMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_activeSeriesCustomTrackersConfig(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StringMap does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_outOfOrderTimeWindow(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_outOfOrderTimeWindow(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OutOfOrderTimeWindow, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_outOfOrderTimeWindow(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_outOfOrderBlocksExternalLabelEnabled(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_outOfOrderBlocksExternalLabelEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OutOfOrderBlocksExternalLabelEnabled, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_outOfOrderBlocksExternalLabelEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_separateMetricsGroupLabel(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_separateMetricsGroupLabel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SeparateMetricsGroupLabel, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_separateMetricsGroupLabel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_maxChunksPerQuery(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_maxChunksPerQuery(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxChunksPerQuery, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_maxChunksPerQuery(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_maxFetchedSeriesPerQuery(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_maxFetchedSeriesPerQuery(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxFetchedSeriesPerQuery, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_maxFetchedSeriesPerQuery(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_maxFetchedChunkBytesPerQuery(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_maxFetchedChunkBytesPerQuery(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxFetchedChunkBytesPerQuery, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_maxFetchedChunkBytesPerQuery(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_maxQueryLookback(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_maxQueryLookback(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxQueryLookback, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_maxQueryLookback(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_maxPartialQueryLength(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_maxPartialQueryLength(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxPartialQueryLength, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_maxPartialQueryLength(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_maxQueryParallelism(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_maxQueryParallelism(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxQueryParallelism, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_maxQueryParallelism(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_maxLabelsQueryLength(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_maxLabelsQueryLength(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxLabelsQueryLength, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_maxLabelsQueryLength(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_maxCacheFreshness(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_maxCacheFreshness(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxCacheFreshness, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_maxCacheFreshness(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_maxQueriersPerTenant(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_maxQueriersPerTenant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxQueriersPerTenant, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_maxQueriersPerTenant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_queryShardingTotalShards(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_queryShardingTotalShards(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryShardingTotalShards, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_queryShardingTotalShards(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_queryShardingMaxShardedQueries(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_queryShardingMaxShardedQueries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryShardingMaxShardedQueries, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_queryShardingMaxShardedQueries(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_queryShardingMaxRegexpSizeBytes(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_queryShardingMaxRegexpSizeBytes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryShardingMaxRegexpSizeBytes, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_queryShardingMaxRegexpSizeBytes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_splitInstantQueriesByInterval(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_splitInstantQueriesByInterval(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SplitInstantQueriesByInterval, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_splitInstantQueriesByInterval(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_QueryIngestersWithin(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_QueryIngestersWithin(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryIngestersWithin, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_QueryIngestersWithin(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_maxTotalQueryLength(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_maxTotalQueryLength(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxTotalQueryLength, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_maxTotalQueryLength(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_resultsCacheTTL(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_resultsCacheTTL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResultsCacheTTL, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_resultsCacheTTL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_resultsCacheTTLForOutOfOrderTimeWindow(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_resultsCacheTTLForOutOfOrderTimeWindow(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResultsCacheTTLForOutOfOrderTimeWindow, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_resultsCacheTTLForOutOfOrderTimeWindow(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_resultsCacheTTLForCardinalityQuery(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_resultsCacheTTLForCardinalityQuery(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResultsCacheTTLForCardinalityQuery, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_resultsCacheTTLForCardinalityQuery(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_resultsCacheTTLForLabelsQuery(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_resultsCacheTTLForLabelsQuery(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResultsCacheTTLForLabelsQuery, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_resultsCacheTTLForLabelsQuery(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_resultsCacheForUnalignedQueryEnabled(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_resultsCacheForUnalignedQueryEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResultsCacheForUnalignedQueryEnabled, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_resultsCacheForUnalignedQueryEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_maxQueryExpressionSizeBytes(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_maxQueryExpressionSizeBytes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxQueryExpressionSizeBytes, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_maxQueryExpressionSizeBytes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_cardinalityAnalysisEnabled(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_cardinalityAnalysisEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CardinalityAnalysisEnabled, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_cardinalityAnalysisEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_labelNamesAndValuesResultsMaxSizeBytes(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_labelNamesAndValuesResultsMaxSizeBytes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LabelNamesAndValuesResultsMaxSizeBytes, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_labelNamesAndValuesResultsMaxSizeBytes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_labelValuesMaxCardinalityLabelNamesPerRequest(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_labelValuesMaxCardinalityLabelNamesPerRequest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LabelValuesMaxCardinalityLabelNamesPerRequest, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_labelValuesMaxCardinalityLabelNamesPerRequest(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_rulerEvaluationDelay(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_rulerEvaluationDelay(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RulerEvaluationDelay, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_rulerEvaluationDelay(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_rulerTenantShardSize(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_rulerTenantShardSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RulerTenantShardSize, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_rulerTenantShardSize(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_rulerMaxRulesPerRuleGroup(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_rulerMaxRulesPerRuleGroup(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RulerMaxRulesPerRuleGroup, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_rulerMaxRulesPerRuleGroup(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_rulerMaxRuleGroupsPerTenant(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_rulerMaxRuleGroupsPerTenant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RulerMaxRuleGroupsPerTenant, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_rulerMaxRuleGroupsPerTenant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_rulerRecordingRulesEvaluationEnabled(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_rulerRecordingRulesEvaluationEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RulerRecordingRulesEvaluationEnabled, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_rulerRecordingRulesEvaluationEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_rulerAlertingRulesEvaluationEnabled(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_rulerAlertingRulesEvaluationEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RulerAlertingRulesEvaluationEnabled, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_rulerAlertingRulesEvaluationEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_rulerSyncRulesOnChangesEnabled(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_rulerSyncRulesOnChangesEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RulerSyncRulesOnChangesEnabled, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_rulerSyncRulesOnChangesEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_storeGatewayTenantShardSize(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_storeGatewayTenantShardSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StoreGatewayTenantShardSize, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_storeGatewayTenantShardSize(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_compactorBlocksRetentionPeriod(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_compactorBlocksRetentionPeriod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompactorBlocksRetentionPeriod, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_compactorBlocksRetentionPeriod(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_compactorSplitAndMergeShards(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_compactorSplitAndMergeShards(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompactorSplitAndMergeShards, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_compactorSplitAndMergeShards(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_compactorSplitGroups(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_compactorSplitGroups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompactorSplitGroups, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_compactorSplitGroups(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_compactorTenantShardSize(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_compactorTenantShardSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompactorTenantShardSize, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_compactorTenantShardSize(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_compactorPartialBlockDeletionDelay(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_compactorPartialBlockDeletionDelay(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompactorPartialBlockDeletionDelay, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_compactorPartialBlockDeletionDelay(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_compactorBlockUploadEnabled(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_compactorBlockUploadEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompactorBlockUploadEnabled, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_compactorBlockUploadEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_compactorBlockUploadValidationEnabled(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_compactorBlockUploadValidationEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompactorBlockUploadValidationEnabled, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_compactorBlockUploadValidationEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_compactorBlockUploadVerifyChunks(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_compactorBlockUploadVerifyChunks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompactorBlockUploadVerifyChunks, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_compactorBlockUploadVerifyChunks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_compactorBlockUploadMaxBlockSizeBytes(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_compactorBlockUploadMaxBlockSizeBytes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompactorBlockUploadMaxBlockSizeBytes, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int64)
	fc.Result = res
	return ec.marshalOInt2ᚖint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_compactorBlockUploadMaxBlockSizeBytes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_s3SSEType(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_s3SSEType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.S3SSEType, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_s3SSEType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_s3SSEKMSKeyID(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_s3SSEKMSKeyID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.S3SSEKMSKeyID, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_s3SSEKMSKeyID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_s3SSEKMSEncryptionContext(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_s3SSEKMSEncryptionContext(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.S3SSEKMSEncryptionContext, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_s3SSEKMSEncryptionContext(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_alertmanagerReceiversBlockCIDRNetworks(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_alertmanagerReceiversBlockCIDRNetworks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AlertmanagerReceiversBlockCIDRNetworks, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_alertmanagerReceiversBlockCIDRNetworks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_alertmanagerReceiversBlockPrivateAddresses(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_alertmanagerReceiversBlockPrivateAddresses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AlertmanagerReceiversBlockPrivateAddresses, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_alertmanagerReceiversBlockPrivateAddresses(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_notificationRateLimit(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_notificationRateLimit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NotificationRateLimit, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2ᚖfloat64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_notificationRateLimit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_notificationRateLimitPerIntegration(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_notificationRateLimitPerIntegration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NotificationRateLimitPerIntegration, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]float64)
	fc.Result = res
	return ec.marshalOFloatMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_notificationRateLimitPerIntegration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FloatMap does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_alertmanagerMaxConfigSizeBytes(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_alertmanagerMaxConfigSizeBytes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AlertmanagerMaxConfigSizeBytes, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_alertmanagerMaxConfigSizeBytes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_alertmanagerMaxTemplatesCount(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_alertmanagerMaxTemplatesCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AlertmanagerMaxTemplatesCount, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_alertmanagerMaxTemplatesCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_alertmanagerMaxTemplateSizeBytes(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_alertmanagerMaxTemplateSizeBytes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AlertmanagerMaxTemplateSizeBytes, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_alertmanagerMaxTemplateSizeBytes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_alertmanagerMaxDispatcherAggregationGroups(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_alertmanagerMaxDispatcherAggregationGroups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AlertmanagerMaxDispatcherAggregationGroups, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_alertmanagerMaxDispatcherAggregationGroups(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_alertmanagerMaxAlertsCount(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_alertmanagerMaxAlertsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AlertmanagerMaxAlertsCount, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_alertmanagerMaxAlertsCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MimirLimits_alertmanagerMaxAlertsSizeBytes(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.MimirLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MimirLimits_alertmanagerMaxAlertsSizeBytes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AlertmanagerMaxAlertsSizeBytes, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MimirLimits_alertmanagerMaxAlertsSizeBytes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MimirLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateUser(rctx, fc.Args["email"].(string), fc.Args["name"].(*model.NameInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/trace-shield/graph/model.User`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	fc.Result = res
	return ec.marshalNUser2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "recoveryLink":
				return ec.fieldContext_User_recoveryLink(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteUser(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/trace-shield/graph/model.User`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	fc.Result = res
	return ec.marshalNUser2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "recoveryLink":
				return ec.fieldContext_User_recoveryLink(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_group(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_group(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().Group(rctx, fc.Args["name"].(string), fc.Args["members"].([]*model.UserInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Group); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/trace-shield/graph/model.Group`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Group)
	fc.Result = res
	return ec.marshalNGroup2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_group(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Group_name(ctx, field)
			case "members":
				return ec.fieldContext_Group_members(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Group", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_group_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteGroup(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteGroup(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteGroup(rctx, fc.Args["name"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Group); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/trace-shield/graph/model.Group`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Group)
	fc.Result = res
	return ec.marshalNGroup2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteGroup(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Group_name(ctx, field)
			case "members":
				return ec.fieldContext_Group_members(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Group", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteGroup_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createOAuth2Client(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createOAuth2Client(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateOAuth2Client(rctx, fc.Args["allowedCorsOrigins"].([]string), fc.Args["audience"].([]string), fc.Args["authorizationCodeGrantAccessTokenLifespan"].(*string), fc.Args["authorizationCodeGrantIdTokenLifespan"].(*string), fc.Args["authorizationCodeGrantRefreshTokenLifespan"].(*string), fc.Args["backChannelLogoutSessionRequired"].(*bool), fc.Args["backChannelLogoutUri"].(*string), fc.Args["clientCredentialsGrantAccessTokenLifespan"].(*string), fc.Args["clientName"].(*string), fc.Args["clientSecret"].(*string), fc.Args["ClientSecretExpiresAt"].(*int64), fc.Args["clientUri"].(*string), fc.Args["contacts"].([]string), fc.Args["frontchannelLogoutSessionRequired"].(*bool), fc.Args["frontchannelLogoutUri"].(*string), fc.Args["grantTypes"].([]string), fc.Args["implicitGrantAccessTokenLifespan"].(*string), fc.Args["implicitGrantIdTokenLifespan"].(*string), fc.Args["jwks"].(map[string]interface{}), fc.Args["jwksUri"].(*string), fc.Args["jwtBearerGrantAccessTokenLifespan"].(*string), fc.Args["logoUri"].(*string), fc.Args["metadata"].(map[string]interface{}), fc.Args["policyUri"].(*string), fc.Args["postLogoutRedirectUris"].([]string), fc.Args["redirectUris"].([]string), fc.Args["responseTypes"].([]string), fc.Args["scope"].(*string), fc.Args["sectorIdentifierUri"].(*string), fc.Args["subjectType"].(*string), fc.Args["tokenEndpointAuthMethod"].(*string), fc.Args["tokenEndpointAuthSigningAlgorithm"].(*string), fc.Args["tosUri"].(*string), fc.Args["userinfoSignedResponseAlgorithm"].(*string), fc.Args["loginBindings"].(*model.LoginBindingsInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.OAuth2Client); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/trace-shield/graph/model.OAuth2Client`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.OAuth2Client)
	fc.Result = res
	return ec.marshalNOAuth2Client2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2Client(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createOAuth2Client(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "allowedCorsOrigins":
				return ec.fieldContext_OAuth2Client_allowedCorsOrigins(ctx, field)
			case "audience":
				return ec.fieldContext_OAuth2Client_audience(ctx, field)
			case "authorizationCodeGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantAccessTokenLifespan(ctx, field)
			case "authorizationCodeGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantIdTokenLifespan(ctx, field)
			case "authorizationCodeGrantRefreshTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantRefreshTokenLifespan(ctx, field)
			case "backChannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_backChannelLogoutSessionRequired(ctx, field)
			case "backChannelLogoutUri":
				return ec.fieldContext_OAuth2Client_backChannelLogoutUri(ctx, field)
			case "clientCredentialsGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_clientCredentialsGrantAccessTokenLifespan(ctx, field)
			case "clientId":
				return ec.fieldContext_OAuth2Client_clientId(ctx, field)
			case "clientName":
				return ec.fieldContext_OAuth2Client_clientName(ctx, field)
			case "clientSecret":
				return ec.fieldContext_OAuth2Client_clientSecret(ctx, field)
			case "ClientSecretExpiresAt":
				return ec.fieldContext_OAuth2Client_ClientSecretExpiresAt(ctx, field)
			case "clientUri":
				return ec.fieldContext_OAuth2Client_clientUri(ctx, field)
			case "contacts":
				return ec.fieldContext_OAuth2Client_contacts(ctx, field)
			case "createdAt":
				return ec.fieldContext_OAuth2Client_createdAt(ctx, field)
			case "frontchannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutSessionRequired(ctx, field)
			case "frontchannelLogoutUri":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutUri(ctx, field)
			case "grantTypes":
				return ec.fieldContext_OAuth2Client_grantTypes(ctx, field)
			case "implicitGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantAccessTokenLifespan(ctx, field)
			case "implicitGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantIdTokenLifespan(ctx, field)
			case "jwks":
				return ec.fieldContext_OAuth2Client_jwks(ctx, field)
			case "jwksUri":
				return ec.fieldContext_OAuth2Client_jwksUri(ctx, field)
			case "jwtBearerGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_jwtBearerGrantAccessTokenLifespan(ctx, field)
			case "logoUri":
				return ec.fieldContext_OAuth2Client_logoUri(ctx, field)
			case "metadata":
				return ec.fieldContext_OAuth2Client_metadata(ctx, field)
			case "owner":
				return ec.fieldContext_OAuth2Client_owner(ctx, field)
			case "policyUri":
				return ec.fieldContext_OAuth2Client_policyUri(ctx, field)
			case "postLogoutRedirectUris":
				return ec.fieldContext_OAuth2Client_postLogoutRedirectUris(ctx, field)
			case "redirectUris":
				return ec.fieldContext_OAuth2Client_redirectUris(ctx, field)
			case "responseTypes":
				return ec.fieldContext_OAuth2Client_responseTypes(ctx, field)
			case "scope":
				return ec.fieldContext_OAuth2Client_scope(ctx, field)
			case "sectorIdentifierUri":
				return ec.fieldContext_OAuth2Client_sectorIdentifierUri(ctx, field)
			case "subjectType":
				return ec.fieldContext_OAuth2Client_subjectType(ctx, field)
			case "tokenEndpointAuthMethod":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthMethod(ctx, field)
			case "tokenEndpointAuthSigningAlgorithm":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthSigningAlgorithm(ctx, field)
			case "tosUri":
				return ec.fieldContext_OAuth2Client_tosUri(ctx, field)
			case "updatedAt":
				return ec.fieldContext_OAuth2Client_updatedAt(ctx, field)
			case "userinfoSignedResponseAlgorithm":
				return ec.fieldContext_OAuth2Client_userinfoSignedResponseAlgorithm(ctx, field)
			case "loginBindings":
				return ec.fieldContext_OAuth2Client_loginBindings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OAuth2Client", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createOAuth2Client_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateOAuth2Client(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateOAuth2Client(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateOAuth2Client(rctx, fc.Args["allowedCorsOrigins"].([]string), fc.Args["audience"].([]string), fc.Args["authorizationCodeGrantAccessTokenLifespan"].(*string), fc.Args["authorizationCodeGrantIdTokenLifespan"].(*string), fc.Args["authorizationCodeGrantRefreshTokenLifespan"].(*string), fc.Args["backChannelLogoutSessionRequired"].(*bool), fc.Args["backChannelLogoutUri"].(*string), fc.Args["clientCredentialsGrantAccessTokenLifespan"].(*string), fc.Args["clientId"].(string), fc.Args["clientName"].(*string), fc.Args["clientSecret"].(*string), fc.Args["ClientSecretExpiresAt"].(*int64), fc.Args["clientUri"].(*string), fc.Args["contacts"].([]string), fc.Args["frontchannelLogoutSessionRequired"].(*bool), fc.Args["frontchannelLogoutUri"].(*string), fc.Args["grantTypes"].([]string), fc.Args["implicitGrantAccessTokenLifespan"].(*string), fc.Args["implicitGrantIdTokenLifespan"].(*string), fc.Args["jwks"].(map[string]interface{}), fc.Args["jwksUri"].(*string), fc.Args["jwtBearerGrantAccessTokenLifespan"].(*string), fc.Args["logoUri"].(*string), fc.Args["metadata"].(map[string]interface{}), fc.Args["policyUri"].(*string), fc.Args["postLogoutRedirectUris"].([]string), fc.Args["redirectUris"].([]string), fc.Args["responseTypes"].([]string), fc.Args["scope"].(*string), fc.Args["sectorIdentifierUri"].(*string), fc.Args["subjectType"].(*string), fc.Args["tokenEndpointAuthMethod"].(*string), fc.Args["tokenEndpointAuthSigningAlgorithm"].(*string), fc.Args["tosUri"].(*string), fc.Args["userinfoSignedResponseAlgorithm"].(*string), fc.Args["loginBindings"].(*model.LoginBindingsInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.OAuth2Client); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/trace-shield/graph/model.OAuth2Client`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.OAuth2Client)
	fc.Result = res
	return ec.marshalNOAuth2Client2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2Client(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateOAuth2Client(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "allowedCorsOrigins":
				return ec.fieldContext_OAuth2Client_allowedCorsOrigins(ctx, field)
			case "audience":
				return ec.fieldContext_OAuth2Client_audience(ctx, field)
			case "authorizationCodeGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantAccessTokenLifespan(ctx, field)
			case "authorizationCodeGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantIdTokenLifespan(ctx, field)
			case "authorizationCodeGrantRefreshTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantRefreshTokenLifespan(ctx, field)
			case "backChannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_backChannelLogoutSessionRequired(ctx, field)
			case "backChannelLogoutUri":
				return ec.fieldContext_OAuth2Client_backChannelLogoutUri(ctx, field)
			case "clientCredentialsGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_clientCredentialsGrantAccessTokenLifespan(ctx, field)
			case "clientId":
				return ec.fieldContext_OAuth2Client_clientId(ctx, field)
			case "clientName":
				return ec.fieldContext_OAuth2Client_clientName(ctx, field)
			case "clientSecret":
				return ec.fieldContext_OAuth2Client_clientSecret(ctx, field)
			case "ClientSecretExpiresAt":
				return ec.fieldContext_OAuth2Client_ClientSecretExpiresAt(ctx, field)
			case "clientUri":
				return ec.fieldContext_OAuth2Client_clientUri(ctx, field)
			case "contacts":
				return ec.fieldContext_OAuth2Client_contacts(ctx, field)
			case "createdAt":
				return ec.fieldContext_OAuth2Client_createdAt(ctx, field)
			case "frontchannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutSessionRequired(ctx, field)
			case "frontchannelLogoutUri":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutUri(ctx, field)
			case "grantTypes":
				return ec.fieldContext_OAuth2Client_grantTypes(ctx, field)
			case "implicitGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantAccessTokenLifespan(ctx, field)
			case "implicitGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantIdTokenLifespan(ctx, field)
			case "jwks":
				return ec.fieldContext_OAuth2Client_jwks(ctx, field)
			case "jwksUri":
				return ec.fieldContext_OAuth2Client_jwksUri(ctx, field)
			case "jwtBearerGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_jwtBearerGrantAccessTokenLifespan(ctx, field)
			case "logoUri":
				return ec.fieldContext_OAuth2Client_logoUri(ctx, field)
			case "metadata":
				return ec.fieldContext_OAuth2Client_metadata(ctx, field)
			case "owner":
				return ec.fieldContext_OAuth2Client_owner(ctx, field)
			case "policyUri":
				return ec.fieldContext_OAuth2Client_policyUri(ctx, field)
			case "postLogoutRedirectUris":
				return ec.fieldContext_OAuth2Client_postLogoutRedirectUris(ctx, field)
			case "redirectUris":
				return ec.fieldContext_OAuth2Client_redirectUris(ctx, field)
			case "responseTypes":
				return ec.fieldContext_OAuth2Client_responseTypes(ctx, field)
			case "scope":
				return ec.fieldContext_OAuth2Client_scope(ctx, field)
			case "sectorIdentifierUri":
				return ec.fieldContext_OAuth2Client_sectorIdentifierUri(ctx, field)
			case "subjectType":
				return ec.fieldContext_OAuth2Client_subjectType(ctx, field)
			case "tokenEndpointAuthMethod":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthMethod(ctx, field)
			case "tokenEndpointAuthSigningAlgorithm":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthSigningAlgorithm(ctx, field)
			case "tosUri":
				return ec.fieldContext_OAuth2Client_tosUri(ctx, field)
			case "updatedAt":
				return ec.fieldContext_OAuth2Client_updatedAt(ctx, field)
			case "userinfoSignedResponseAlgorithm":
				return ec.fieldContext_OAuth2Client_userinfoSignedResponseAlgorithm(ctx, field)
			case "loginBindings":
				return ec.fieldContext_OAuth2Client_loginBindings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OAuth2Client", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateOAuth2Client_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteOAuth2Client(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteOAuth2Client(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteOAuth2Client(rctx, fc.Args["clientId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.OAuth2Client); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/trace-shield/graph/model.OAuth2Client`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.OAuth2Client)
	fc.Result = res
	return ec.marshalNOAuth2Client2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2Client(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteOAuth2Client(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "allowedCorsOrigins":
				return ec.fieldContext_OAuth2Client_allowedCorsOrigins(ctx, field)
			case "audience":
				return ec.fieldContext_OAuth2Client_audience(ctx, field)
			case "authorizationCodeGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantAccessTokenLifespan(ctx, field)
			case "authorizationCodeGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantIdTokenLifespan(ctx, field)
			case "authorizationCodeGrantRefreshTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantRefreshTokenLifespan(ctx, field)
			case "backChannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_backChannelLogoutSessionRequired(ctx, field)
			case "backChannelLogoutUri":
				return ec.fieldContext_OAuth2Client_backChannelLogoutUri(ctx, field)
			case "clientCredentialsGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_clientCredentialsGrantAccessTokenLifespan(ctx, field)
			case "clientId":
				return ec.fieldContext_OAuth2Client_clientId(ctx, field)
			case "clientName":
				return ec.fieldContext_OAuth2Client_clientName(ctx, field)
			case "clientSecret":
				return ec.fieldContext_OAuth2Client_clientSecret(ctx, field)
			case "ClientSecretExpiresAt":
				return ec.fieldContext_OAuth2Client_ClientSecretExpiresAt(ctx, field)
			case "clientUri":
				return ec.fieldContext_OAuth2Client_clientUri(ctx, field)
			case "contacts":
				return ec.fieldContext_OAuth2Client_contacts(ctx, field)
			case "createdAt":
				return ec.fieldContext_OAuth2Client_createdAt(ctx, field)
			case "frontchannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutSessionRequired(ctx, field)
			case "frontchannelLogoutUri":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutUri(ctx, field)
			case "grantTypes":
				return ec.fieldContext_OAuth2Client_grantTypes(ctx, field)
			case "implicitGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantAccessTokenLifespan(ctx, field)
			case "implicitGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantIdTokenLifespan(ctx, field)
			case "jwks":
				return ec.fieldContext_OAuth2Client_jwks(ctx, field)
			case "jwksUri":
				return ec.fieldContext_OAuth2Client_jwksUri(ctx, field)
			case "jwtBearerGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_jwtBearerGrantAccessTokenLifespan(ctx, field)
			case "logoUri":
				return ec.fieldContext_OAuth2Client_logoUri(ctx, field)
			case "metadata":
				return ec.fieldContext_OAuth2Client_metadata(ctx, field)
			case "owner":
				return ec.fieldContext_OAuth2Client_owner(ctx, field)
			case "policyUri":
				return ec.fieldContext_OAuth2Client_policyUri(ctx, field)
			case "postLogoutRedirectUris":
				return ec.fieldContext_OAuth2Client_postLogoutRedirectUris(ctx, field)
			case "redirectUris":
				return ec.fieldContext_OAuth2Client_redirectUris(ctx, field)
			case "responseTypes":
				return ec.fieldContext_OAuth2Client_responseTypes(ctx, field)
			case "scope":
				return ec.fieldContext_OAuth2Client_scope(ctx, field)
			case "sectorIdentifierUri":
				return ec.fieldContext_OAuth2Client_sectorIdentifierUri(ctx, field)
			case "subjectType":
				return ec.fieldContext_OAuth2Client_subjectType(ctx, field)
			case "tokenEndpointAuthMethod":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthMethod(ctx, field)
			case "tokenEndpointAuthSigningAlgorithm":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthSigningAlgorithm(ctx, field)
			case "tosUri":
				return ec.fieldContext_OAuth2Client_tosUri(ctx, field)
			case "updatedAt":
				return ec.fieldContext_OAuth2Client_updatedAt(ctx, field)
			case "userinfoSignedResponseAlgorithm":
				return ec.fieldContext_OAuth2Client_userinfoSignedResponseAlgorithm(ctx, field)
			case "loginBindings":
				return ec.fieldContext_OAuth2Client_loginBindings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OAuth2Client", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteOAuth2Client_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_acceptOAuth2ConsentRequest(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_acceptOAuth2ConsentRequest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AcceptOAuth2ConsentRequest(rctx, fc.Args["challenge"].(string), fc.Args["grantAccessTokenAudience"].([]string), fc.Args["grantScope"].([]string), fc.Args["remember"].(*bool), fc.Args["rememberFor"].(*int64))
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.OAuth2RedirectTo)
	fc.Result = res
	return ec.marshalNOAuth2RedirectTo2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2RedirectTo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_acceptOAuth2ConsentRequest(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "redirectTo":
				return ec.fieldContext_OAuth2RedirectTo_redirectTo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OAuth2RedirectTo", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_acceptOAuth2ConsentRequest_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_rejectOAuth2ConsentRequest(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_rejectOAuth2ConsentRequest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RejectOAuth2ConsentRequest(rctx, fc.Args["challenge"].(string))
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.OAuth2RedirectTo)
	fc.Result = res
	return ec.marshalNOAuth2RedirectTo2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2RedirectTo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_rejectOAuth2ConsentRequest(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "redirectTo":
				return ec.fieldContext_OAuth2RedirectTo_redirectTo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OAuth2RedirectTo", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_rejectOAuth2ConsentRequest_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_acceptOAuth2LoginRequest(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_acceptOAuth2LoginRequest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AcceptOAuth2LoginRequest(rctx, fc.Args["challenge"].(string), fc.Args["acr"].(*string), fc.Args["amr"].([]string), fc.Args["context"].(map[string]interface{}), fc.Args["remember"].(*bool), fc.Args["rememberFor"].(*int64), fc.Args["subject"].(string))
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.OAuth2RedirectTo)
	fc.Result = res
	return ec.marshalNOAuth2RedirectTo2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2RedirectTo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_acceptOAuth2LoginRequest(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "redirectTo":
				return ec.fieldContext_OAuth2RedirectTo_redirectTo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OAuth2RedirectTo", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_acceptOAuth2LoginRequest_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_rejectOAuth2LoginRequest(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_rejectOAuth2LoginRequest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RejectOAuth2LoginRequest(rctx, fc.Args["challenge"].(string))
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.OAuth2RedirectTo)
	fc.Result = res
	return ec.marshalNOAuth2RedirectTo2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2RedirectTo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_rejectOAuth2LoginRequest(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "redirectTo":
				return ec.fieldContext_OAuth2RedirectTo_redirectTo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OAuth2RedirectTo", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_rejectOAuth2LoginRequest_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createObservabilityTenant(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createObservabilityTenant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateObservabilityTenant(rctx, fc.Args["id"].(string), fc.Args["name"].(*string), fc.Args["admins"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["metricsReaders"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["metricsWriters"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["metricsDeleters"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["metricsRulesReaders"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["metricsRulesWriters"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["metricsRulesDeleters"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["metricsAlertsReaders"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["metricsAlertsWriters"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["logsReaders"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["logsWriters"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["logsDeleters"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["logsRulesReaders"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["logsRulesWriters"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["logsRulesDeleters"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["tracesReaders"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["tracesWriters"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["limits"].(*model.ObservabilityTenantLimitsInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ObservabilityTenant); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/trace-shield/graph/model.ObservabilityTenant`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenant)
	fc.Result = res
	return ec.marshalNObservabilityTenant2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenant(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createObservabilityTenant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ObservabilityTenant_id(ctx, field)
			case "displayName":
				return ec.fieldContext_ObservabilityTenant_displayName(ctx, field)
			case "admins":
				return ec.fieldContext_ObservabilityTenant_admins(ctx, field)
			case "metricsReaders":
				return ec.fieldContext_ObservabilityTenant_metricsReaders(ctx, field)
			case "metricsWriters":
				return ec.fieldContext_ObservabilityTenant_metricsWriters(ctx, field)
			case "metricsDeleters":
				return ec.fieldContext_ObservabilityTenant_metricsDeleters(ctx, field)
			case "metricsRulesReaders":
				return ec.fieldContext_ObservabilityTenant_metricsRulesReaders(ctx, field)
			case "metricsRulesWriters":
				return ec.fieldContext_ObservabilityTenant_metricsRulesWriters(ctx, field)
			case "metricsRulesDeleters":
				return ec.fieldContext_ObservabilityTenant_metricsRulesDeleters(ctx, field)
			case "metricsAlertsReaders":
				return ec.fieldContext_ObservabilityTenant_metricsAlertsReaders(ctx, field)
			case "metricsAlertsWriters":
				return ec.fieldContext_ObservabilityTenant_metricsAlertsWriters(ctx, field)
			case "logsReaders":
				return ec.fieldContext_ObservabilityTenant_logsReaders(ctx, field)
			case "logsWriters":
				return ec.fieldContext_ObservabilityTenant_logsWriters(ctx, field)
			case "logsDeleters":
				return ec.fieldContext_ObservabilityTenant_logsDeleters(ctx, field)
			case "logsRulesReaders":
				return ec.fieldContext_ObservabilityTenant_logsRulesReaders(ctx, field)
			case "logsRulesWriters":
				return ec.fieldContext_ObservabilityTenant_logsRulesWriters(ctx, field)
			case "logsRulesDeleters":
				return ec.fieldContext_ObservabilityTenant_logsRulesDeleters(ctx, field)
			case "tracesReaders":
				return ec.fieldContext_ObservabilityTenant_tracesReaders(ctx, field)
			case "tracesWriters":
				return ec.fieldContext_ObservabilityTenant_tracesWriters(ctx, field)
			case "limits":
				return ec.fieldContext_ObservabilityTenant_limits(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenant", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createObservabilityTenant_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateObservabilityTenant(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateObservabilityTenant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateObservabilityTenant(rctx, fc.Args["id"].(string), fc.Args["name"].(*string), fc.Args["admins"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["metricsReaders"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["metricsWriters"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["metricsDeleters"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["metricsRulesReaders"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["metricsRulesWriters"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["metricsRulesDeleters"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["metricsAlertsReaders"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["metricsAlertsWriters"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["logsReaders"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["logsWriters"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["logsDeleters"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["logsRulesReaders"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["logsRulesWriters"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["logsRulesDeleters"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["tracesReaders"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["tracesWriters"].(*model.ObservabilityTenantPermissionBindingsInput), fc.Args["limits"].(*model.ObservabilityTenantLimitsInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ObservabilityTenant); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/trace-shield/graph/model.ObservabilityTenant`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenant)
	fc.Result = res
	return ec.marshalNObservabilityTenant2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenant(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateObservabilityTenant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ObservabilityTenant_id(ctx, field)
			case "displayName":
				return ec.fieldContext_ObservabilityTenant_displayName(ctx, field)
			case "admins":
				return ec.fieldContext_ObservabilityTenant_admins(ctx, field)
			case "metricsReaders":
				return ec.fieldContext_ObservabilityTenant_metricsReaders(ctx, field)
			case "metricsWriters":
				return ec.fieldContext_ObservabilityTenant_metricsWriters(ctx, field)
			case "metricsDeleters":
				return ec.fieldContext_ObservabilityTenant_metricsDeleters(ctx, field)
			case "metricsRulesReaders":
				return ec.fieldContext_ObservabilityTenant_metricsRulesReaders(ctx, field)
			case "metricsRulesWriters":
				return ec.fieldContext_ObservabilityTenant_metricsRulesWriters(ctx, field)
			case "metricsRulesDeleters":
				return ec.fieldContext_ObservabilityTenant_metricsRulesDeleters(ctx, field)
			case "metricsAlertsReaders":
				return ec.fieldContext_ObservabilityTenant_metricsAlertsReaders(ctx, field)
			case "metricsAlertsWriters":
				return ec.fieldContext_ObservabilityTenant_metricsAlertsWriters(ctx, field)
			case "logsReaders":
				return ec.fieldContext_ObservabilityTenant_logsReaders(ctx, field)
			case "logsWriters":
				return ec.fieldContext_ObservabilityTenant_logsWriters(ctx, field)
			case "logsDeleters":
				return ec.fieldContext_ObservabilityTenant_logsDeleters(ctx, field)
			case "logsRulesReaders":
				return ec.fieldContext_ObservabilityTenant_logsRulesReaders(ctx, field)
			case "logsRulesWriters":
				return ec.fieldContext_ObservabilityTenant_logsRulesWriters(ctx, field)
			case "logsRulesDeleters":
				return ec.fieldContext_ObservabilityTenant_logsRulesDeleters(ctx, field)
			case "tracesReaders":
				return ec.fieldContext_ObservabilityTenant_tracesReaders(ctx, field)
			case "tracesWriters":
				return ec.fieldContext_ObservabilityTenant_tracesWriters(ctx, field)
			case "limits":
				return ec.fieldContext_ObservabilityTenant_limits(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenant", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateObservabilityTenant_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteObservabilityTenant(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteObservabilityTenant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteObservabilityTenant(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ObservabilityTenant); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/trace-shield/graph/model.ObservabilityTenant`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenant)
	fc.Result = res
	return ec.marshalNObservabilityTenant2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenant(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteObservabilityTenant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ObservabilityTenant_id(ctx, field)
			case "displayName":
				return ec.fieldContext_ObservabilityTenant_displayName(ctx, field)
			case "admins":
				return ec.fieldContext_ObservabilityTenant_admins(ctx, field)
			case "metricsReaders":
				return ec.fieldContext_ObservabilityTenant_metricsReaders(ctx, field)
			case "metricsWriters":
				return ec.fieldContext_ObservabilityTenant_metricsWriters(ctx, field)
			case "metricsDeleters":
				return ec.fieldContext_ObservabilityTenant_metricsDeleters(ctx, field)
			case "metricsRulesReaders":
				return ec.fieldContext_ObservabilityTenant_metricsRulesReaders(ctx, field)
			case "metricsRulesWriters":
				return ec.fieldContext_ObservabilityTenant_metricsRulesWriters(ctx, field)
			case "metricsRulesDeleters":
				return ec.fieldContext_ObservabilityTenant_metricsRulesDeleters(ctx, field)
			case "metricsAlertsReaders":
				return ec.fieldContext_ObservabilityTenant_metricsAlertsReaders(ctx, field)
			case "metricsAlertsWriters":
				return ec.fieldContext_ObservabilityTenant_metricsAlertsWriters(ctx, field)
			case "logsReaders":
				return ec.fieldContext_ObservabilityTenant_logsReaders(ctx, field)
			case "logsWriters":
				return ec.fieldContext_ObservabilityTenant_logsWriters(ctx, field)
			case "logsDeleters":
				return ec.fieldContext_ObservabilityTenant_logsDeleters(ctx, field)
			case "logsRulesReaders":
				return ec.fieldContext_ObservabilityTenant_logsRulesReaders(ctx, field)
			case "logsRulesWriters":
				return ec.fieldContext_ObservabilityTenant_logsRulesWriters(ctx, field)
			case "logsRulesDeleters":
				return ec.fieldContext_ObservabilityTenant_logsRulesDeleters(ctx, field)
			case "tracesReaders":
				return ec.fieldContext_ObservabilityTenant_tracesReaders(ctx, field)
			case "tracesWriters":
				return ec.fieldContext_ObservabilityTenant_tracesWriters(ctx, field)
			case "limits":
				return ec.fieldContext_ObservabilityTenant_limits(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenant", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteObservabilityTenant_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_organization(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_organization(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().Organization(rctx, fc.Args["admins"].([]*model.UserInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Organization); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/trace-shield/graph/model.Organization`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Organization)
	fc.Result = res
	return ec.marshalNOrganization2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOrganization(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_organization(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "admins":
				return ec.fieldContext_Organization_admins(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Organization", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_organization_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Name_first(ctx context.Context, field graphql.CollectedField, obj *model.Name) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Name_first(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.First, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Name_first(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Name",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Name_last(ctx context.Context, field graphql.CollectedField, obj *model.Name) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Name_last(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Last, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Name_last(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Name",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotifierBasicAuth_username(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.NotifierBasicAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotifierBasicAuth_username(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Username, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotifierBasicAuth_username(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotifierBasicAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotifierBasicAuth_password(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.NotifierBasicAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotifierBasicAuth_password(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Password, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotifierBasicAuth_password(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotifierBasicAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotifierConfig_basicAuth(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.NotifierConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotifierConfig_basicAuth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BasicAuth, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1alpha1.NotifierBasicAuth)
	fc.Result = res
	return ec.marshalONotifierBasicAuth2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐNotifierBasicAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotifierConfig_basicAuth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotifierConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "username":
				return ec.fieldContext_NotifierBasicAuth_username(ctx, field)
			case "password":
				return ec.fieldContext_NotifierBasicAuth_password(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NotifierBasicAuth", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotifierConfig_headerAuth(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.NotifierConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotifierConfig_headerAuth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HeaderAuth, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1alpha1.NotifierHeaderAuth)
	fc.Result = res
	return ec.marshalONotifierHeaderAuth2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐNotifierHeaderAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotifierConfig_headerAuth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotifierConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "type":
				return ec.fieldContext_NotifierHeaderAuth_type(ctx, field)
			case "credentials":
				return ec.fieldContext_NotifierHeaderAuth_credentials(ctx, field)
			case "credentialsFile":
				return ec.fieldContext_NotifierHeaderAuth_credentialsFile(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NotifierHeaderAuth", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotifierConfig_tls(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.NotifierConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotifierConfig_tls(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TLS, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1alpha1.NotifierTLSClientConfig)
	fc.Result = res
	return ec.marshalONotifierTLSClientConfig2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐNotifierTLSClientConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotifierConfig_tls(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotifierConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "certPath":
				return ec.fieldContext_NotifierTLSClientConfig_certPath(ctx, field)
			case "keyPath":
				return ec.fieldContext_NotifierTLSClientConfig_keyPath(ctx, field)
			case "caPath":
				return ec.fieldContext_NotifierTLSClientConfig_caPath(ctx, field)
			case "serverName":
				return ec.fieldContext_NotifierTLSClientConfig_serverName(ctx, field)
			case "insecureSkipVerify":
				return ec.fieldContext_NotifierTLSClientConfig_insecureSkipVerify(ctx, field)
			case "cipherSuites":
				return ec.fieldContext_NotifierTLSClientConfig_cipherSuites(ctx, field)
			case "minVersion":
				return ec.fieldContext_NotifierTLSClientConfig_minVersion(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NotifierTLSClientConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotifierHeaderAuth_type(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.NotifierHeaderAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotifierHeaderAuth_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotifierHeaderAuth_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotifierHeaderAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotifierHeaderAuth_credentials(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.NotifierHeaderAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotifierHeaderAuth_credentials(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Credentials, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotifierHeaderAuth_credentials(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotifierHeaderAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotifierHeaderAuth_credentialsFile(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.NotifierHeaderAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotifierHeaderAuth_credentialsFile(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CredentialsFile, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotifierHeaderAuth_credentialsFile(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotifierHeaderAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotifierTLSClientConfig_certPath(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.NotifierTLSClientConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotifierTLSClientConfig_certPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CertPath, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotifierTLSClientConfig_certPath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotifierTLSClientConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotifierTLSClientConfig_keyPath(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.NotifierTLSClientConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotifierTLSClientConfig_keyPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.KeyPath, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotifierTLSClientConfig_keyPath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotifierTLSClientConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotifierTLSClientConfig_caPath(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.NotifierTLSClientConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotifierTLSClientConfig_caPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CAPath, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotifierTLSClientConfig_caPath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotifierTLSClientConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotifierTLSClientConfig_serverName(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.NotifierTLSClientConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotifierTLSClientConfig_serverName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServerName, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotifierTLSClientConfig_serverName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotifierTLSClientConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotifierTLSClientConfig_insecureSkipVerify(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.NotifierTLSClientConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotifierTLSClientConfig_insecureSkipVerify(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InsecureSkipVerify, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotifierTLSClientConfig_insecureSkipVerify(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotifierTLSClientConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotifierTLSClientConfig_cipherSuites(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.NotifierTLSClientConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotifierTLSClientConfig_cipherSuites(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CipherSuites, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotifierTLSClientConfig_cipherSuites(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotifierTLSClientConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotifierTLSClientConfig_minVersion(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.NotifierTLSClientConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotifierTLSClientConfig_minVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MinVersion, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotifierTLSClientConfig_minVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotifierTLSClientConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_allowedCorsOrigins(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_allowedCorsOrigins(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AllowedCorsOrigins, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_allowedCorsOrigins(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_audience(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_audience(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Audience, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_audience(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_authorizationCodeGrantAccessTokenLifespan(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_authorizationCodeGrantAccessTokenLifespan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthorizationCodeGrantAccessTokenLifespan, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_authorizationCodeGrantAccessTokenLifespan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_authorizationCodeGrantIdTokenLifespan(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_authorizationCodeGrantIdTokenLifespan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthorizationCodeGrantIDTokenLifespan, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_authorizationCodeGrantIdTokenLifespan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_authorizationCodeGrantRefreshTokenLifespan(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_authorizationCodeGrantRefreshTokenLifespan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthorizationCodeGrantRefreshTokenLifespan, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_authorizationCodeGrantRefreshTokenLifespan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_backChannelLogoutSessionRequired(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_backChannelLogoutSessionRequired(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BackChannelLogoutSessionRequired, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_backChannelLogoutSessionRequired(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_backChannelLogoutUri(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_backChannelLogoutUri(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BackChannelLogoutURI, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_backChannelLogoutUri(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_clientCredentialsGrantAccessTokenLifespan(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_clientCredentialsGrantAccessTokenLifespan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientCredentialsGrantAccessTokenLifespan, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_clientCredentialsGrantAccessTokenLifespan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_clientId(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_clientId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientID, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_clientId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_clientName(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_clientName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientName, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_clientName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_clientSecret(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_clientSecret(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientSecret, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_clientSecret(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_ClientSecretExpiresAt(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_ClientSecretExpiresAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientSecretExpiresAt, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int64)
	fc.Result = res
	return ec.marshalOInt2ᚖint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_ClientSecretExpiresAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_clientUri(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_clientUri(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientURI, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_clientUri(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_contacts(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_contacts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Contacts, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_contacts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_frontchannelLogoutSessionRequired(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_frontchannelLogoutSessionRequired(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FrontchannelLogoutSessionRequired, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_frontchannelLogoutSessionRequired(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_frontchannelLogoutUri(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_frontchannelLogoutUri(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FrontchannelLogoutURI, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_frontchannelLogoutUri(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_grantTypes(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_grantTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GrantTypes, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_grantTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_implicitGrantAccessTokenLifespan(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_implicitGrantAccessTokenLifespan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImplicitGrantAccessTokenLifespan, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_implicitGrantAccessTokenLifespan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_implicitGrantIdTokenLifespan(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_implicitGrantIdTokenLifespan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImplicitGrantIDTokenLifespan, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_implicitGrantIdTokenLifespan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_jwks(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_jwks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Jwks, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_jwks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_jwksUri(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_jwksUri(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JwksURI, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_jwksUri(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_jwtBearerGrantAccessTokenLifespan(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_jwtBearerGrantAccessTokenLifespan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JwtBearerGrantAccessTokenLifespan, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_jwtBearerGrantAccessTokenLifespan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_logoUri(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_logoUri(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LogoURI, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_logoUri(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_metadata(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_metadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_metadata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_owner(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_owner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.OAuth2Client().Owner(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_owner(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_policyUri(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_policyUri(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PolicyURI, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_policyUri(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_postLogoutRedirectUris(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_postLogoutRedirectUris(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PostLogoutRedirectUris, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_postLogoutRedirectUris(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_redirectUris(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_redirectUris(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RedirectUris, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_redirectUris(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_responseTypes(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_responseTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResponseTypes, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_responseTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_scope(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_scope(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Scope, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_scope(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_sectorIdentifierUri(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_sectorIdentifierUri(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SectorIdentifierURI, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_sectorIdentifierUri(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_subjectType(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_subjectType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubjectType, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_subjectType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_tokenEndpointAuthMethod(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_tokenEndpointAuthMethod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TokenEndpointAuthMethod, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_tokenEndpointAuthMethod(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_tokenEndpointAuthSigningAlgorithm(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_tokenEndpointAuthSigningAlgorithm(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TokenEndpointAuthSigningAlgorithm, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_tokenEndpointAuthSigningAlgorithm(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_tosUri(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_tosUri(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TosURI, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_tosUri(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_userinfoSignedResponseAlgorithm(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_userinfoSignedResponseAlgorithm(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserinfoSignedResponseAlgorithm, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_userinfoSignedResponseAlgorithm(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_loginBindings(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_loginBindings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.OAuth2Client().LoginBindings(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.LoginBindings)
	fc.Result = res
	return ec.marshalOLoginBindings2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐLoginBindings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_loginBindings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_LoginBindings_users(ctx, field)
			case "groups":
				return ec.fieldContext_LoginBindings_groups(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoginBindings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2ConsentRequest_acr(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2ConsentRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2ConsentRequest_acr(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Acr, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2ConsentRequest_acr(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2ConsentRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2ConsentRequest_amr(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2ConsentRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2ConsentRequest_amr(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Amr, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2ConsentRequest_amr(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2ConsentRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2ConsentRequest_challenge(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2ConsentRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2ConsentRequest_challenge(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Challenge, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2ConsentRequest_challenge(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2ConsentRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2ConsentRequest_client(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2ConsentRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2ConsentRequest_client(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Client, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.OAuth2Client)
	fc.Result = res
	return ec.marshalNOAuth2Client2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2Client(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2ConsentRequest_client(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2ConsentRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "allowedCorsOrigins":
				return ec.fieldContext_OAuth2Client_allowedCorsOrigins(ctx, field)
			case "audience":
				return ec.fieldContext_OAuth2Client_audience(ctx, field)
			case "authorizationCodeGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantAccessTokenLifespan(ctx, field)
			case "authorizationCodeGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantIdTokenLifespan(ctx, field)
			case "authorizationCodeGrantRefreshTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantRefreshTokenLifespan(ctx, field)
			case "backChannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_backChannelLogoutSessionRequired(ctx, field)
			case "backChannelLogoutUri":
				return ec.fieldContext_OAuth2Client_backChannelLogoutUri(ctx, field)
			case "clientCredentialsGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_clientCredentialsGrantAccessTokenLifespan(ctx, field)
			case "clientId":
				return ec.fieldContext_OAuth2Client_clientId(ctx, field)
			case "clientName":
				return ec.fieldContext_OAuth2Client_clientName(ctx, field)
			case "clientSecret":
				return ec.fieldContext_OAuth2Client_clientSecret(ctx, field)
			case "ClientSecretExpiresAt":
				return ec.fieldContext_OAuth2Client_ClientSecretExpiresAt(ctx, field)
			case "clientUri":
				return ec.fieldContext_OAuth2Client_clientUri(ctx, field)
			case "contacts":
				return ec.fieldContext_OAuth2Client_contacts(ctx, field)
			case "createdAt":
				return ec.fieldContext_OAuth2Client_createdAt(ctx, field)
			case "frontchannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutSessionRequired(ctx, field)
			case "frontchannelLogoutUri":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutUri(ctx, field)
			case "grantTypes":
				return ec.fieldContext_OAuth2Client_grantTypes(ctx, field)
			case "implicitGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantAccessTokenLifespan(ctx, field)
			case "implicitGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantIdTokenLifespan(ctx, field)
			case "jwks":
				return ec.fieldContext_OAuth2Client_jwks(ctx, field)
			case "jwksUri":
				return ec.fieldContext_OAuth2Client_jwksUri(ctx, field)
			case "jwtBearerGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_jwtBearerGrantAccessTokenLifespan(ctx, field)
			case "logoUri":
				return ec.fieldContext_OAuth2Client_logoUri(ctx, field)
			case "metadata":
				return ec.fieldContext_OAuth2Client_metadata(ctx, field)
			case "owner":
				return ec.fieldContext_OAuth2Client_owner(ctx, field)
			case "policyUri":
				return ec.fieldContext_OAuth2Client_policyUri(ctx, field)
			case "postLogoutRedirectUris":
				return ec.fieldContext_OAuth2Client_postLogoutRedirectUris(ctx, field)
			case "redirectUris":
				return ec.fieldContext_OAuth2Client_redirectUris(ctx, field)
			case "responseTypes":
				return ec.fieldContext_OAuth2Client_responseTypes(ctx, field)
			case "scope":
				return ec.fieldContext_OAuth2Client_scope(ctx, field)
			case "sectorIdentifierUri":
				return ec.fieldContext_OAuth2Client_sectorIdentifierUri(ctx, field)
			case "subjectType":
				return ec.fieldContext_OAuth2Client_subjectType(ctx, field)
			case "tokenEndpointAuthMethod":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthMethod(ctx, field)
			case "tokenEndpointAuthSigningAlgorithm":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthSigningAlgorithm(ctx, field)
			case "tosUri":
				return ec.fieldContext_OAuth2Client_tosUri(ctx, field)
			case "updatedAt":
				return ec.fieldContext_OAuth2Client_updatedAt(ctx, field)
			case "userinfoSignedResponseAlgorithm":
				return ec.fieldContext_OAuth2Client_userinfoSignedResponseAlgorithm(ctx, field)
			case "loginBindings":
				return ec.fieldContext_OAuth2Client_loginBindings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OAuth2Client", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2ConsentRequest_context(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2ConsentRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2ConsentRequest_context(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Context, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2ConsentRequest_context(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2ConsentRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2ConsentRequest_loginChallenge(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2ConsentRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2ConsentRequest_loginChallenge(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LoginChallenge, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2ConsentRequest_loginChallenge(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2ConsentRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2ConsentRequest_loginSessionId(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2ConsentRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2ConsentRequest_loginSessionId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LoginSessionID, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2ConsentRequest_loginSessionId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2ConsentRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2ConsentRequest_oidcContext(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2ConsentRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2ConsentRequest_oidcContext(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OidcContext, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.OidcContext)
	fc.Result = res
	return ec.marshalOOidcContext2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOidcContext(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2ConsentRequest_oidcContext(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2ConsentRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "acrValues":
				return ec.fieldContext_OidcContext_acrValues(ctx, field)
			case "display":
				return ec.fieldContext_OidcContext_display(ctx, field)
			case "idTokenHintClaims":
				return ec.fieldContext_OidcContext_idTokenHintClaims(ctx, field)
			case "loginHint":
				return ec.fieldContext_OidcContext_loginHint(ctx, field)
			case "uiLocales":
				return ec.fieldContext_OidcContext_uiLocales(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OidcContext", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2ConsentRequest_requestUrl(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2ConsentRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2ConsentRequest_requestUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestURL, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2ConsentRequest_requestUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2ConsentRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2ConsentRequest_requestedAccessTokenAudience(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2ConsentRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2ConsentRequest_requestedAccessTokenAudience(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestedAccessTokenAudience, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2ConsentRequest_requestedAccessTokenAudience(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2ConsentRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2ConsentRequest_requestedScope(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2ConsentRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2ConsentRequest_requestedScope(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestedScope, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2ConsentRequest_requestedScope(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2ConsentRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2ConsentRequest_skip(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2ConsentRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2ConsentRequest_skip(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Skip, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2ConsentRequest_skip(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2ConsentRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2ConsentRequest_subject(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2ConsentRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2ConsentRequest_subject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Subject, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2ConsentRequest_subject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2ConsentRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2ConsentRequest_redirectTo(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2ConsentRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2ConsentRequest_redirectTo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RedirectTo, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2ConsentRequest_redirectTo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2ConsentRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2LoginRequest_challenge(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2LoginRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2LoginRequest_challenge(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Challenge, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2LoginRequest_challenge(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2LoginRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2LoginRequest_client(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2LoginRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2LoginRequest_client(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Client, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.OAuth2Client)
	fc.Result = res
	return ec.marshalNOAuth2Client2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2Client(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2LoginRequest_client(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2LoginRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "allowedCorsOrigins":
				return ec.fieldContext_OAuth2Client_allowedCorsOrigins(ctx, field)
			case "audience":
				return ec.fieldContext_OAuth2Client_audience(ctx, field)
			case "authorizationCodeGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantAccessTokenLifespan(ctx, field)
			case "authorizationCodeGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantIdTokenLifespan(ctx, field)
			case "authorizationCodeGrantRefreshTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantRefreshTokenLifespan(ctx, field)
			case "backChannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_backChannelLogoutSessionRequired(ctx, field)
			case "backChannelLogoutUri":
				return ec.fieldContext_OAuth2Client_backChannelLogoutUri(ctx, field)
			case "clientCredentialsGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_clientCredentialsGrantAccessTokenLifespan(ctx, field)
			case "clientId":
				return ec.fieldContext_OAuth2Client_clientId(ctx, field)
			case "clientName":
				return ec.fieldContext_OAuth2Client_clientName(ctx, field)
			case "clientSecret":
				return ec.fieldContext_OAuth2Client_clientSecret(ctx, field)
			case "ClientSecretExpiresAt":
				return ec.fieldContext_OAuth2Client_ClientSecretExpiresAt(ctx, field)
			case "clientUri":
				return ec.fieldContext_OAuth2Client_clientUri(ctx, field)
			case "contacts":
				return ec.fieldContext_OAuth2Client_contacts(ctx, field)
			case "createdAt":
				return ec.fieldContext_OAuth2Client_createdAt(ctx, field)
			case "frontchannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutSessionRequired(ctx, field)
			case "frontchannelLogoutUri":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutUri(ctx, field)
			case "grantTypes":
				return ec.fieldContext_OAuth2Client_grantTypes(ctx, field)
			case "implicitGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantAccessTokenLifespan(ctx, field)
			case "implicitGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantIdTokenLifespan(ctx, field)
			case "jwks":
				return ec.fieldContext_OAuth2Client_jwks(ctx, field)
			case "jwksUri":
				return ec.fieldContext_OAuth2Client_jwksUri(ctx, field)
			case "jwtBearerGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_jwtBearerGrantAccessTokenLifespan(ctx, field)
			case "logoUri":
				return ec.fieldContext_OAuth2Client_logoUri(ctx, field)
			case "metadata":
				return ec.fieldContext_OAuth2Client_metadata(ctx, field)
			case "owner":
				return ec.fieldContext_OAuth2Client_owner(ctx, field)
			case "policyUri":
				return ec.fieldContext_OAuth2Client_policyUri(ctx, field)
			case "postLogoutRedirectUris":
				return ec.fieldContext_OAuth2Client_postLogoutRedirectUris(ctx, field)
			case "redirectUris":
				return ec.fieldContext_OAuth2Client_redirectUris(ctx, field)
			case "responseTypes":
				return ec.fieldContext_OAuth2Client_responseTypes(ctx, field)
			case "scope":
				return ec.fieldContext_OAuth2Client_scope(ctx, field)
			case "sectorIdentifierUri":
				return ec.fieldContext_OAuth2Client_sectorIdentifierUri(ctx, field)
			case "subjectType":
				return ec.fieldContext_OAuth2Client_subjectType(ctx, field)
			case "tokenEndpointAuthMethod":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthMethod(ctx, field)
			case "tokenEndpointAuthSigningAlgorithm":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthSigningAlgorithm(ctx, field)
			case "tosUri":
				return ec.fieldContext_OAuth2Client_tosUri(ctx, field)
			case "updatedAt":
				return ec.fieldContext_OAuth2Client_updatedAt(ctx, field)
			case "userinfoSignedResponseAlgorithm":
				return ec.fieldContext_OAuth2Client_userinfoSignedResponseAlgorithm(ctx, field)
			case "loginBindings":
				return ec.fieldContext_OAuth2Client_loginBindings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OAuth2Client", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2LoginRequest_oidcContext(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2LoginRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2LoginRequest_oidcContext(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OidcContext, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.OidcContext)
	fc.Result = res
	return ec.marshalOOidcContext2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOidcContext(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2LoginRequest_oidcContext(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2LoginRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "acrValues":
				return ec.fieldContext_OidcContext_acrValues(ctx, field)
			case "display":
				return ec.fieldContext_OidcContext_display(ctx, field)
			case "idTokenHintClaims":
				return ec.fieldContext_OidcContext_idTokenHintClaims(ctx, field)
			case "loginHint":
				return ec.fieldContext_OidcContext_loginHint(ctx, field)
			case "uiLocales":
				return ec.fieldContext_OidcContext_uiLocales(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OidcContext", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2LoginRequest_requestUrl(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2LoginRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2LoginRequest_requestUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestURL, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2LoginRequest_requestUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2LoginRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2LoginRequest_requestedAccessTokenAudience(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2LoginRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2LoginRequest_requestedAccessTokenAudience(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestedAccessTokenAudience, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2LoginRequest_requestedAccessTokenAudience(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2LoginRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2LoginRequest_requestedScope(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2LoginRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2LoginRequest_requestedScope(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestedScope, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2LoginRequest_requestedScope(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2LoginRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2LoginRequest_sessionId(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2LoginRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2LoginRequest_sessionId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SessionID, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2LoginRequest_sessionId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2LoginRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2LoginRequest_skip(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2LoginRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2LoginRequest_skip(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Skip, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2LoginRequest_skip(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2LoginRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2LoginRequest_subject(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2LoginRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2LoginRequest_subject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Subject, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2LoginRequest_subject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2LoginRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2LoginRequest_redirectTo(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2LoginRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2LoginRequest_redirectTo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RedirectTo, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2LoginRequest_redirectTo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2LoginRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2RedirectTo_redirectTo(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2RedirectTo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2RedirectTo_redirectTo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RedirectTo, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2RedirectTo_redirectTo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2RedirectTo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_id(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_displayName(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_admins(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_admins(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenant().Admins(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenantPermissionBindings)
	fc.Result = res
	return ec.marshalOObservabilityTenantPermissionBindings2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_admins(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_users(ctx, field)
			case "groups":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_groups(ctx, field)
			case "oauth2Clients":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_oauth2Clients(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenantPermissionBindings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_metricsReaders(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_metricsReaders(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenant().MetricsReaders(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenantPermissionBindings)
	fc.Result = res
	return ec.marshalOObservabilityTenantPermissionBindings2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_metricsReaders(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_users(ctx, field)
			case "groups":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_groups(ctx, field)
			case "oauth2Clients":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_oauth2Clients(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenantPermissionBindings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_metricsWriters(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_metricsWriters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenant().MetricsWriters(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenantPermissionBindings)
	fc.Result = res
	return ec.marshalOObservabilityTenantPermissionBindings2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_metricsWriters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_users(ctx, field)
			case "groups":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_groups(ctx, field)
			case "oauth2Clients":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_oauth2Clients(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenantPermissionBindings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_metricsDeleters(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_metricsDeleters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenant().MetricsDeleters(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenantPermissionBindings)
	fc.Result = res
	return ec.marshalOObservabilityTenantPermissionBindings2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_metricsDeleters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_users(ctx, field)
			case "groups":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_groups(ctx, field)
			case "oauth2Clients":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_oauth2Clients(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenantPermissionBindings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_metricsRulesReaders(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_metricsRulesReaders(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenant().MetricsRulesReaders(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenantPermissionBindings)
	fc.Result = res
	return ec.marshalOObservabilityTenantPermissionBindings2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_metricsRulesReaders(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_users(ctx, field)
			case "groups":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_groups(ctx, field)
			case "oauth2Clients":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_oauth2Clients(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenantPermissionBindings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_metricsRulesWriters(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_metricsRulesWriters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenant().MetricsRulesWriters(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenantPermissionBindings)
	fc.Result = res
	return ec.marshalOObservabilityTenantPermissionBindings2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_metricsRulesWriters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_users(ctx, field)
			case "groups":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_groups(ctx, field)
			case "oauth2Clients":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_oauth2Clients(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenantPermissionBindings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_metricsRulesDeleters(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_metricsRulesDeleters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenant().MetricsRulesDeleters(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenantPermissionBindings)
	fc.Result = res
	return ec.marshalOObservabilityTenantPermissionBindings2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_metricsRulesDeleters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_users(ctx, field)
			case "groups":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_groups(ctx, field)
			case "oauth2Clients":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_oauth2Clients(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenantPermissionBindings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_metricsAlertsReaders(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_metricsAlertsReaders(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenant().MetricsAlertsReaders(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenantPermissionBindings)
	fc.Result = res
	return ec.marshalOObservabilityTenantPermissionBindings2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_metricsAlertsReaders(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_users(ctx, field)
			case "groups":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_groups(ctx, field)
			case "oauth2Clients":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_oauth2Clients(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenantPermissionBindings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_metricsAlertsWriters(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_metricsAlertsWriters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenant().MetricsAlertsWriters(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenantPermissionBindings)
	fc.Result = res
	return ec.marshalOObservabilityTenantPermissionBindings2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_metricsAlertsWriters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_users(ctx, field)
			case "groups":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_groups(ctx, field)
			case "oauth2Clients":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_oauth2Clients(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenantPermissionBindings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_logsReaders(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_logsReaders(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenant().LogsReaders(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenantPermissionBindings)
	fc.Result = res
	return ec.marshalOObservabilityTenantPermissionBindings2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_logsReaders(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_users(ctx, field)
			case "groups":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_groups(ctx, field)
			case "oauth2Clients":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_oauth2Clients(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenantPermissionBindings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_logsWriters(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_logsWriters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenant().LogsWriters(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenantPermissionBindings)
	fc.Result = res
	return ec.marshalOObservabilityTenantPermissionBindings2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_logsWriters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_users(ctx, field)
			case "groups":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_groups(ctx, field)
			case "oauth2Clients":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_oauth2Clients(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenantPermissionBindings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_logsDeleters(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_logsDeleters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenant().LogsDeleters(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenantPermissionBindings)
	fc.Result = res
	return ec.marshalOObservabilityTenantPermissionBindings2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_logsDeleters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_users(ctx, field)
			case "groups":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_groups(ctx, field)
			case "oauth2Clients":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_oauth2Clients(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenantPermissionBindings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_logsRulesReaders(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_logsRulesReaders(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenant().LogsRulesReaders(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenantPermissionBindings)
	fc.Result = res
	return ec.marshalOObservabilityTenantPermissionBindings2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_logsRulesReaders(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_users(ctx, field)
			case "groups":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_groups(ctx, field)
			case "oauth2Clients":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_oauth2Clients(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenantPermissionBindings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_logsRulesWriters(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_logsRulesWriters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenant().LogsRulesWriters(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenantPermissionBindings)
	fc.Result = res
	return ec.marshalOObservabilityTenantPermissionBindings2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_logsRulesWriters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_users(ctx, field)
			case "groups":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_groups(ctx, field)
			case "oauth2Clients":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_oauth2Clients(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenantPermissionBindings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_logsRulesDeleters(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_logsRulesDeleters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenant().LogsRulesDeleters(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenantPermissionBindings)
	fc.Result = res
	return ec.marshalOObservabilityTenantPermissionBindings2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_logsRulesDeleters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_users(ctx, field)
			case "groups":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_groups(ctx, field)
			case "oauth2Clients":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_oauth2Clients(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenantPermissionBindings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_tracesReaders(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_tracesReaders(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenant().TracesReaders(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenantPermissionBindings)
	fc.Result = res
	return ec.marshalOObservabilityTenantPermissionBindings2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_tracesReaders(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_users(ctx, field)
			case "groups":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_groups(ctx, field)
			case "oauth2Clients":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_oauth2Clients(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenantPermissionBindings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_tracesWriters(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_tracesWriters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenant().TracesWriters(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenantPermissionBindings)
	fc.Result = res
	return ec.marshalOObservabilityTenantPermissionBindings2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_tracesWriters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_users(ctx, field)
			case "groups":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_groups(ctx, field)
			case "oauth2Clients":
				return ec.fieldContext_ObservabilityTenantPermissionBindings_oauth2Clients(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenantPermissionBindings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_limits(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_limits(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Limits, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenantLimits)
	fc.Result = res
	return ec.marshalOObservabilityTenantLimits2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantLimits(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_limits(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "mimir":
				return ec.fieldContext_ObservabilityTenantLimits_mimir(ctx, field)
			case "loki":
				return ec.fieldContext_ObservabilityTenantLimits_loki(ctx, field)
			case "tempo":
				return ec.fieldContext_ObservabilityTenantLimits_tempo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenantLimits", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenantLimits_mimir(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenantLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenantLimits_mimir(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mimir, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1alpha1.MimirLimits)
	fc.Result = res
	return ec.marshalOMimirLimits2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐMimirLimits(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenantLimits_mimir(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenantLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "requestRate":
				return ec.fieldContext_MimirLimits_requestRate(ctx, field)
			case "requestBurstSize":
				return ec.fieldContext_MimirLimits_requestBurstSize(ctx, field)
			case "ingestionRate":
				return ec.fieldContext_MimirLimits_ingestionRate(ctx, field)
			case "ingestionBurstSize":
				return ec.fieldContext_MimirLimits_ingestionBurstSize(ctx, field)
			case "acceptHASamples":
				return ec.fieldContext_MimirLimits_acceptHASamples(ctx, field)
			case "haClusterLabel":
				return ec.fieldContext_MimirLimits_haClusterLabel(ctx, field)
			case "haReplicaLabel":
				return ec.fieldContext_MimirLimits_haReplicaLabel(ctx, field)
			case "haMaxClusters":
				return ec.fieldContext_MimirLimits_haMaxClusters(ctx, field)
			case "dropLabels":
				return ec.fieldContext_MimirLimits_dropLabels(ctx, field)
			case "maxLabelNameLength":
				return ec.fieldContext_MimirLimits_maxLabelNameLength(ctx, field)
			case "maxLabelValueLength":
				return ec.fieldContext_MimirLimits_maxLabelValueLength(ctx, field)
			case "maxLabelNamesPerSeries":
				return ec.fieldContext_MimirLimits_maxLabelNamesPerSeries(ctx, field)
			case "maxMetadataLength":
				return ec.fieldContext_MimirLimits_maxMetadataLength(ctx, field)
			case "maxNativeHistogramBuckets":
				return ec.fieldContext_MimirLimits_maxNativeHistogramBuckets(ctx, field)
			case "creationGracePeriod":
				return ec.fieldContext_MimirLimits_creationGracePeriod(ctx, field)
			case "enforceMetadataMetricName":
				return ec.fieldContext_MimirLimits_enforceMetadataMetricName(ctx, field)
			case "ingestionTenantShardSize":
				return ec.fieldContext_MimirLimits_ingestionTenantShardSize(ctx, field)
			case "metricRelabelConfigs":
				return ec.fieldContext_MimirLimits_metricRelabelConfigs(ctx, field)
			case "maxGlobalSeriesPerUser":
				return ec.fieldContext_MimirLimits_maxGlobalSeriesPerUser(ctx, field)
			case "maxGlobalSeriesPerMetric":
				return ec.fieldContext_MimirLimits_maxGlobalSeriesPerMetric(ctx, field)
			case "maxGlobalMetricsWithMetadataPerUser":
				return ec.fieldContext_MimirLimits_maxGlobalMetricsWithMetadataPerUser(ctx, field)
			case "maxGlobalMetadataPerMetric":
				return ec.fieldContext_MimirLimits_maxGlobalMetadataPerMetric(ctx, field)
			case "maxGlobalExemplarsPerUser":
				return ec.fieldContext_MimirLimits_maxGlobalExemplarsPerUser(ctx, field)
			case "nativeHistogramsIngestionEnabled":
				return ec.fieldContext_MimirLimits_nativeHistogramsIngestionEnabled(ctx, field)
			case "activeSeriesCustomTrackersConfig":
				return ec.fieldContext_MimirLimits_activeSeriesCustomTrackersConfig(ctx, field)
			case "outOfOrderTimeWindow":
				return ec.fieldContext_MimirLimits_outOfOrderTimeWindow(ctx, field)
			case "outOfOrderBlocksExternalLabelEnabled":
				return ec.fieldContext_MimirLimits_outOfOrderBlocksExternalLabelEnabled(ctx, field)
			case "separateMetricsGroupLabel":
				return ec.fieldContext_MimirLimits_separateMetricsGroupLabel(ctx, field)
			case "maxChunksPerQuery":
				return ec.fieldContext_MimirLimits_maxChunksPerQuery(ctx, field)
			case "maxFetchedSeriesPerQuery":
				return ec.fieldContext_MimirLimits_maxFetchedSeriesPerQuery(ctx, field)
			case "maxFetchedChunkBytesPerQuery":
				return ec.fieldContext_MimirLimits_maxFetchedChunkBytesPerQuery(ctx, field)
			case "maxQueryLookback":
				return ec.fieldContext_MimirLimits_maxQueryLookback(ctx, field)
			case "maxPartialQueryLength":
				return ec.fieldContext_MimirLimits_maxPartialQueryLength(ctx, field)
			case "maxQueryParallelism":
				return ec.fieldContext_MimirLimits_maxQueryParallelism(ctx, field)
			case "maxLabelsQueryLength":
				return ec.fieldContext_MimirLimits_maxLabelsQueryLength(ctx, field)
			case "maxCacheFreshness":
				return ec.fieldContext_MimirLimits_maxCacheFreshness(ctx, field)
			case "maxQueriersPerTenant":
				return ec.fieldContext_MimirLimits_maxQueriersPerTenant(ctx, field)
			case "queryShardingTotalShards":
				return ec.fieldContext_MimirLimits_queryShardingTotalShards(ctx, field)
			case "queryShardingMaxShardedQueries":
				return ec.fieldContext_MimirLimits_queryShardingMaxShardedQueries(ctx, field)
			case "queryShardingMaxRegexpSizeBytes":
				return ec.fieldContext_MimirLimits_queryShardingMaxRegexpSizeBytes(ctx, field)
			case "splitInstantQueriesByInterval":
				return ec.fieldContext_MimirLimits_splitInstantQueriesByInterval(ctx, field)
			case "QueryIngestersWithin":
				return ec.fieldContext_MimirLimits_QueryIngestersWithin(ctx, field)
			case "maxTotalQueryLength":
				return ec.fieldContext_MimirLimits_maxTotalQueryLength(ctx, field)
			case "resultsCacheTTL":
				return ec.fieldContext_MimirLimits_resultsCacheTTL(ctx, field)
			case "resultsCacheTTLForOutOfOrderTimeWindow":
				return ec.fieldContext_MimirLimits_resultsCacheTTLForOutOfOrderTimeWindow(ctx, field)
			case "resultsCacheTTLForCardinalityQuery":
				return ec.fieldContext_MimirLimits_resultsCacheTTLForCardinalityQuery(ctx, field)
			case "resultsCacheTTLForLabelsQuery":
				return ec.fieldContext_MimirLimits_resultsCacheTTLForLabelsQuery(ctx, field)
			case "resultsCacheForUnalignedQueryEnabled":
				return ec.fieldContext_MimirLimits_resultsCacheForUnalignedQueryEnabled(ctx, field)
			case "maxQueryExpressionSizeBytes":
				return ec.fieldContext_MimirLimits_maxQueryExpressionSizeBytes(ctx, field)
			case "cardinalityAnalysisEnabled":
				return ec.fieldContext_MimirLimits_cardinalityAnalysisEnabled(ctx, field)
			case "labelNamesAndValuesResultsMaxSizeBytes":
				return ec.fieldContext_MimirLimits_labelNamesAndValuesResultsMaxSizeBytes(ctx, field)
			case "labelValuesMaxCardinalityLabelNamesPerRequest":
				return ec.fieldContext_MimirLimits_labelValuesMaxCardinalityLabelNamesPerRequest(ctx, field)
			case "rulerEvaluationDelay":
				return ec.fieldContext_MimirLimits_rulerEvaluationDelay(ctx, field)
			case "rulerTenantShardSize":
				return ec.fieldContext_MimirLimits_rulerTenantShardSize(ctx, field)
			case "rulerMaxRulesPerRuleGroup":
				return ec.fieldContext_MimirLimits_rulerMaxRulesPerRuleGroup(ctx, field)
			case "rulerMaxRuleGroupsPerTenant":
				return ec.fieldContext_MimirLimits_rulerMaxRuleGroupsPerTenant(ctx, field)
			case "rulerRecordingRulesEvaluationEnabled":
				return ec.fieldContext_MimirLimits_rulerRecordingRulesEvaluationEnabled(ctx, field)
			case "rulerAlertingRulesEvaluationEnabled":
				return ec.fieldContext_MimirLimits_rulerAlertingRulesEvaluationEnabled(ctx, field)
			case "rulerSyncRulesOnChangesEnabled":
				return ec.fieldContext_MimirLimits_rulerSyncRulesOnChangesEnabled(ctx, field)
			case "storeGatewayTenantShardSize":
				return ec.fieldContext_MimirLimits_storeGatewayTenantShardSize(ctx, field)
			case "compactorBlocksRetentionPeriod":
				return ec.fieldContext_MimirLimits_compactorBlocksRetentionPeriod(ctx, field)
			case "compactorSplitAndMergeShards":
				return ec.fieldContext_MimirLimits_compactorSplitAndMergeShards(ctx, field)
			case "compactorSplitGroups":
				return ec.fieldContext_MimirLimits_compactorSplitGroups(ctx, field)
			case "compactorTenantShardSize":
				return ec.fieldContext_MimirLimits_compactorTenantShardSize(ctx, field)
			case "compactorPartialBlockDeletionDelay":
				return ec.fieldContext_MimirLimits_compactorPartialBlockDeletionDelay(ctx, field)
			case "compactorBlockUploadEnabled":
				return ec.fieldContext_MimirLimits_compactorBlockUploadEnabled(ctx, field)
			case "compactorBlockUploadValidationEnabled":
				return ec.fieldContext_MimirLimits_compactorBlockUploadValidationEnabled(ctx, field)
			case "compactorBlockUploadVerifyChunks":
				return ec.fieldContext_MimirLimits_compactorBlockUploadVerifyChunks(ctx, field)
			case "compactorBlockUploadMaxBlockSizeBytes":
				return ec.fieldContext_MimirLimits_compactorBlockUploadMaxBlockSizeBytes(ctx, field)
			case "s3SSEType":
				return ec.fieldContext_MimirLimits_s3SSEType(ctx, field)
			case "s3SSEKMSKeyID":
				return ec.fieldContext_MimirLimits_s3SSEKMSKeyID(ctx, field)
			case "s3SSEKMSEncryptionContext":
				return ec.fieldContext_MimirLimits_s3SSEKMSEncryptionContext(ctx, field)
			case "alertmanagerReceiversBlockCIDRNetworks":
				return ec.fieldContext_MimirLimits_alertmanagerReceiversBlockCIDRNetworks(ctx, field)
			case "alertmanagerReceiversBlockPrivateAddresses":
				return ec.fieldContext_MimirLimits_alertmanagerReceiversBlockPrivateAddresses(ctx, field)
			case "notificationRateLimit":
				return ec.fieldContext_MimirLimits_notificationRateLimit(ctx, field)
			case "notificationRateLimitPerIntegration":
				return ec.fieldContext_MimirLimits_notificationRateLimitPerIntegration(ctx, field)
			case "alertmanagerMaxConfigSizeBytes":
				return ec.fieldContext_MimirLimits_alertmanagerMaxConfigSizeBytes(ctx, field)
			case "alertmanagerMaxTemplatesCount":
				return ec.fieldContext_MimirLimits_alertmanagerMaxTemplatesCount(ctx, field)
			case "alertmanagerMaxTemplateSizeBytes":
				return ec.fieldContext_MimirLimits_alertmanagerMaxTemplateSizeBytes(ctx, field)
			case "alertmanagerMaxDispatcherAggregationGroups":
				return ec.fieldContext_MimirLimits_alertmanagerMaxDispatcherAggregationGroups(ctx, field)
			case "alertmanagerMaxAlertsCount":
				return ec.fieldContext_MimirLimits_alertmanagerMaxAlertsCount(ctx, field)
			case "alertmanagerMaxAlertsSizeBytes":
				return ec.fieldContext_MimirLimits_alertmanagerMaxAlertsSizeBytes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MimirLimits", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenantLimits_loki(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenantLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenantLimits_loki(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Loki, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1alpha1.LokiLimits)
	fc.Result = res
	return ec.marshalOLokiLimits2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐLokiLimits(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenantLimits_loki(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenantLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ingestionRateStrategy":
				return ec.fieldContext_LokiLimits_ingestionRateStrategy(ctx, field)
			case "ingestionRateMB":
				return ec.fieldContext_LokiLimits_ingestionRateMB(ctx, field)
			case "ingestionBurstSizeMB":
				return ec.fieldContext_LokiLimits_ingestionBurstSizeMB(ctx, field)
			case "maxLabelNameLength":
				return ec.fieldContext_LokiLimits_maxLabelNameLength(ctx, field)
			case "maxLabelValueLength":
				return ec.fieldContext_LokiLimits_maxLabelValueLength(ctx, field)
			case "maxLabelNamesPerSeries":
				return ec.fieldContext_LokiLimits_maxLabelNamesPerSeries(ctx, field)
			case "rejectOldSamples":
				return ec.fieldContext_LokiLimits_rejectOldSamples(ctx, field)
			case "rejectOldSamplesMaxAge":
				return ec.fieldContext_LokiLimits_rejectOldSamplesMaxAge(ctx, field)
			case "creationGracePeriod":
				return ec.fieldContext_LokiLimits_creationGracePeriod(ctx, field)
			case "enforceMetricName":
				return ec.fieldContext_LokiLimits_enforceMetricName(ctx, field)
			case "maxLineSize":
				return ec.fieldContext_LokiLimits_maxLineSize(ctx, field)
			case "maxLineSizeTruncate":
				return ec.fieldContext_LokiLimits_maxLineSizeTruncate(ctx, field)
			case "incrementDuplicateTimestamp":
				return ec.fieldContext_LokiLimits_incrementDuplicateTimestamp(ctx, field)
			case "maxLocalStreamsPerUser":
				return ec.fieldContext_LokiLimits_maxLocalStreamsPerUser(ctx, field)
			case "maxGlobalStreamsPerUser":
				return ec.fieldContext_LokiLimits_maxGlobalStreamsPerUser(ctx, field)
			case "unorderedWrites":
				return ec.fieldContext_LokiLimits_unorderedWrites(ctx, field)
			case "perStreamRateLimit":
				return ec.fieldContext_LokiLimits_perStreamRateLimit(ctx, field)
			case "perStreamRateLimitBurst":
				return ec.fieldContext_LokiLimits_perStreamRateLimitBurst(ctx, field)
			case "maxChunksPerQuery":
				return ec.fieldContext_LokiLimits_maxChunksPerQuery(ctx, field)
			case "maxQuerySeries":
				return ec.fieldContext_LokiLimits_maxQuerySeries(ctx, field)
			case "maxQueryLookback":
				return ec.fieldContext_LokiLimits_maxQueryLookback(ctx, field)
			case "maxQueryLength":
				return ec.fieldContext_LokiLimits_maxQueryLength(ctx, field)
			case "maxQueryRange":
				return ec.fieldContext_LokiLimits_maxQueryRange(ctx, field)
			case "maxQueryParallelism":
				return ec.fieldContext_LokiLimits_maxQueryParallelism(ctx, field)
			case "tsdbMaxQueryParallelism":
				return ec.fieldContext_LokiLimits_tsdbMaxQueryParallelism(ctx, field)
			case "tsdbMaxBytesPerShard":
				return ec.fieldContext_LokiLimits_tsdbMaxBytesPerShard(ctx, field)
			case "cardinalityLimit":
				return ec.fieldContext_LokiLimits_cardinalityLimit(ctx, field)
			case "maxStreamsMatchersPerQuery":
				return ec.fieldContext_LokiLimits_maxStreamsMatchersPerQuery(ctx, field)
			case "maxConcurrentTailRequests":
				return ec.fieldContext_LokiLimits_maxConcurrentTailRequests(ctx, field)
			case "maxEntriesLimitPerQuery":
				return ec.fieldContext_LokiLimits_maxEntriesLimitPerQuery(ctx, field)
			case "maxCacheFreshness":
				return ec.fieldContext_LokiLimits_maxCacheFreshness(ctx, field)
			case "maxStatsCacheFreshness":
				return ec.fieldContext_LokiLimits_maxStatsCacheFreshness(ctx, field)
			case "maxQueriersPerTenant":
				return ec.fieldContext_LokiLimits_maxQueriersPerTenant(ctx, field)
			case "queryReadyIndexNumDays":
				return ec.fieldContext_LokiLimits_queryReadyIndexNumDays(ctx, field)
			case "queryTimeout":
				return ec.fieldContext_LokiLimits_queryTimeout(ctx, field)
			case "querySplitDuration":
				return ec.fieldContext_LokiLimits_querySplitDuration(ctx, field)
			case "minShardingLookback":
				return ec.fieldContext_LokiLimits_minShardingLookback(ctx, field)
			case "maxQueryBytesRead":
				return ec.fieldContext_LokiLimits_maxQueryBytesRead(ctx, field)
			case "maxQuerierBytesRead":
				return ec.fieldContext_LokiLimits_maxQuerierBytesRead(ctx, field)
			case "volumeEnabled":
				return ec.fieldContext_LokiLimits_volumeEnabled(ctx, field)
			case "volumeMaxSeries":
				return ec.fieldContext_LokiLimits_volumeMaxSeries(ctx, field)
			case "rulerEvaluationDelay":
				return ec.fieldContext_LokiLimits_rulerEvaluationDelay(ctx, field)
			case "rulerMaxRulesPerRuleGroup":
				return ec.fieldContext_LokiLimits_rulerMaxRulesPerRuleGroup(ctx, field)
			case "rulerMaxRuleGroupsPerTenant":
				return ec.fieldContext_LokiLimits_rulerMaxRuleGroupsPerTenant(ctx, field)
			case "rulerAlertManagerConfig":
				return ec.fieldContext_LokiLimits_rulerAlertManagerConfig(ctx, field)
			case "rulerTenantShardSize":
				return ec.fieldContext_LokiLimits_rulerTenantShardSize(ctx, field)
			case "rulerRemoteWriteDisabled":
				return ec.fieldContext_LokiLimits_rulerRemoteWriteDisabled(ctx, field)
			case "rulerRemoteEvaluationTimeout":
				return ec.fieldContext_LokiLimits_rulerRemoteEvaluationTimeout(ctx, field)
			case "rulerRemoteEvaluationMaxResponseSize":
				return ec.fieldContext_LokiLimits_rulerRemoteEvaluationMaxResponseSize(ctx, field)
			case "deletionMode":
				return ec.fieldContext_LokiLimits_deletionMode(ctx, field)
			case "retentionPeriod":
				return ec.fieldContext_LokiLimits_retentionPeriod(ctx, field)
			case "streamRetention":
				return ec.fieldContext_LokiLimits_streamRetention(ctx, field)
			case "shardStreams":
				return ec.fieldContext_LokiLimits_shardStreams(ctx, field)
			case "blockedQueries":
				return ec.fieldContext_LokiLimits_blockedQueries(ctx, field)
			case "requiredLabels":
				return ec.fieldContext_LokiLimits_requiredLabels(ctx, field)
			case "requiredNumberLabels":
				return ec.fieldContext_LokiLimits_requiredNumberLabels(ctx, field)
			case "indexGatewayShardSize":
				return ec.fieldContext_LokiLimits_indexGatewayShardSize(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LokiLimits", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenantLimits_tempo(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenantLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenantLimits_tempo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tempo, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1alpha1.TempoLimits)
	fc.Result = res
	return ec.marshalOTempoLimits2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐTempoLimits(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenantLimits_tempo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenantLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ingestionRateStrategy":
				return ec.fieldContext_TempoLimits_ingestionRateStrategy(ctx, field)
			case "ingestionRateLimitBytes":
				return ec.fieldContext_TempoLimits_ingestionRateLimitBytes(ctx, field)
			case "ingestionBurstSizeBytes":
				return ec.fieldContext_TempoLimits_ingestionBurstSizeBytes(ctx, field)
			case "maxLocalTracesPerUser":
				return ec.fieldContext_TempoLimits_maxLocalTracesPerUser(ctx, field)
			case "maxGlobalTracesPerUser":
				return ec.fieldContext_TempoLimits_maxGlobalTracesPerUser(ctx, field)
			case "forwarders":
				return ec.fieldContext_TempoLimits_forwarders(ctx, field)
			case "metricsGeneratorRingSize":
				return ec.fieldContext_TempoLimits_metricsGeneratorRingSize(ctx, field)
			case "metricsGeneratorProcessors":
				return ec.fieldContext_TempoLimits_metricsGeneratorProcessors(ctx, field)
			case "metricsGeneratorMaxActiveSeries":
				return ec.fieldContext_TempoLimits_metricsGeneratorMaxActiveSeries(ctx, field)
			case "metricsGeneratorCollectionInterval":
				return ec.fieldContext_TempoLimits_metricsGeneratorCollectionInterval(ctx, field)
			case "metricsGeneratorDisableCollection":
				return ec.fieldContext_TempoLimits_metricsGeneratorDisableCollection(ctx, field)
			case "metricsGeneratorForwarderQueueSize":
				return ec.fieldContext_TempoLimits_metricsGeneratorForwarderQueueSize(ctx, field)
			case "metricsGeneratorForwarderWorkers":
				return ec.fieldContext_TempoLimits_metricsGeneratorForwarderWorkers(ctx, field)
			case "metricsGeneratorProcessorServiceGraphsHistogramBuckets":
				return ec.fieldContext_TempoLimits_metricsGeneratorProcessorServiceGraphsHistogramBuckets(ctx, field)
			case "metricsGeneratorProcessorServiceGraphsDimensions":
				return ec.fieldContext_TempoLimits_metricsGeneratorProcessorServiceGraphsDimensions(ctx, field)
			case "metricsGeneratorProcessorServiceGraphsPeerAttributes":
				return ec.fieldContext_TempoLimits_metricsGeneratorProcessorServiceGraphsPeerAttributes(ctx, field)
			case "metricsGeneratorProcessorServiceGraphsEnableClientServerPrefix":
				return ec.fieldContext_TempoLimits_metricsGeneratorProcessorServiceGraphsEnableClientServerPrefix(ctx, field)
			case "metricsGeneratorProcessorSpanMetricsHistogramBuckets":
				return ec.fieldContext_TempoLimits_metricsGeneratorProcessorSpanMetricsHistogramBuckets(ctx, field)
			case "metricsGeneratorProcessorSpanMetricsDimensions":
				return ec.fieldContext_TempoLimits_metricsGeneratorProcessorSpanMetricsDimensions(ctx, field)
			case "metricsGeneratorProcessorSpanMetricsIntrinsicDimensions":
				return ec.fieldContext_TempoLimits_metricsGeneratorProcessorSpanMetricsIntrinsicDimensions(ctx, field)
			case "metricsGeneratorProcessorSpanMetricsFilterPolicies":
				return ec.fieldContext_TempoLimits_metricsGeneratorProcessorSpanMetricsFilterPolicies(ctx, field)
			case "metricsGeneratorProcessorSpanMetricsDimensionMappings":
				return ec.fieldContext_TempoLimits_metricsGeneratorProcessorSpanMetricsDimensionMappings(ctx, field)
			case "metricsGeneratorProcessorSpanMetricsEnableTargetInfo":
				return ec.fieldContext_TempoLimits_metricsGeneratorProcessorSpanMetricsEnableTargetInfo(ctx, field)
			case "metricsGeneratorProcessorLocalBlocksMaxLiveTraces":
				return ec.fieldContext_TempoLimits_metricsGeneratorProcessorLocalBlocksMaxLiveTraces(ctx, field)
			case "metricsGeneratorProcessorLocalBlocksMaxBlockDuration":
				return ec.fieldContext_TempoLimits_metricsGeneratorProcessorLocalBlocksMaxBlockDuration(ctx, field)
			case "metricsGeneratorProcessorLocalBlocksMaxBlockBytes":
				return ec.fieldContext_TempoLimits_metricsGeneratorProcessorLocalBlocksMaxBlockBytes(ctx, field)
			case "metricsGeneratorProcessorLocalBlocksFlushCheckPeriod":
				return ec.fieldContext_TempoLimits_metricsGeneratorProcessorLocalBlocksFlushCheckPeriod(ctx, field)
			case "metricsGeneratorProcessorLocalBlocksTraceIdlePeriod":
				return ec.fieldContext_TempoLimits_metricsGeneratorProcessorLocalBlocksTraceIdlePeriod(ctx, field)
			case "metricsGeneratorProcessorLocalBlocksCompleteBlockTimeout":
				return ec.fieldContext_TempoLimits_metricsGeneratorProcessorLocalBlocksCompleteBlockTimeout(ctx, field)
			case "blockRetention":
				return ec.fieldContext_TempoLimits_blockRetention(ctx, field)
			case "maxBytesPerTagValuesQuery":
				return ec.fieldContext_TempoLimits_maxBytesPerTagValuesQuery(ctx, field)
			case "maxBlocksPerTagValuesQuery":
				return ec.fieldContext_TempoLimits_maxBlocksPerTagValuesQuery(ctx, field)
			case "maxSearchDuration":
				return ec.fieldContext_TempoLimits_maxSearchDuration(ctx, field)
			case "maxBytesPerTrace":
				return ec.fieldContext_TempoLimits_maxBytesPerTrace(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TempoLimits", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenantPermissionBindings_users(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenantPermissionBindings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenantPermissionBindings_users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenantPermissionBindings().Users(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.User)
	fc.Result = res
	return ec.marshalOUser2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐUserᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenantPermissionBindings_users(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenantPermissionBindings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "recoveryLink":
				return ec.fieldContext_User_recoveryLink(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenantPermissionBindings_groups(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenantPermissionBindings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenantPermissionBindings_groups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenantPermissionBindings().Groups(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Group)
	fc.Result = res
	return ec.marshalOGroup2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐGroupᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenantPermissionBindings_groups(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenantPermissionBindings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Group_name(ctx, field)
			case "members":
				return ec.fieldContext_Group_members(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Group", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenantPermissionBindings_oauth2Clients(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenantPermissionBindings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenantPermissionBindings_oauth2Clients(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenantPermissionBindings().Oauth2Clients(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.OAuth2Client)
	fc.Result = res
	return ec.marshalOOAuth2Client2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2Clientᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenantPermissionBindings_oauth2Clients(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenantPermissionBindings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "allowedCorsOrigins":
				return ec.fieldContext_OAuth2Client_allowedCorsOrigins(ctx, field)
			case "audience":
				return ec.fieldContext_OAuth2Client_audience(ctx, field)
			case "authorizationCodeGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantAccessTokenLifespan(ctx, field)
			case "authorizationCodeGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantIdTokenLifespan(ctx, field)
			case "authorizationCodeGrantRefreshTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantRefreshTokenLifespan(ctx, field)
			case "backChannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_backChannelLogoutSessionRequired(ctx, field)
			case "backChannelLogoutUri":
				return ec.fieldContext_OAuth2Client_backChannelLogoutUri(ctx, field)
			case "clientCredentialsGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_clientCredentialsGrantAccessTokenLifespan(ctx, field)
			case "clientId":
				return ec.fieldContext_OAuth2Client_clientId(ctx, field)
			case "clientName":
				return ec.fieldContext_OAuth2Client_clientName(ctx, field)
			case "clientSecret":
				return ec.fieldContext_OAuth2Client_clientSecret(ctx, field)
			case "ClientSecretExpiresAt":
				return ec.fieldContext_OAuth2Client_ClientSecretExpiresAt(ctx, field)
			case "clientUri":
				return ec.fieldContext_OAuth2Client_clientUri(ctx, field)
			case "contacts":
				return ec.fieldContext_OAuth2Client_contacts(ctx, field)
			case "createdAt":
				return ec.fieldContext_OAuth2Client_createdAt(ctx, field)
			case "frontchannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutSessionRequired(ctx, field)
			case "frontchannelLogoutUri":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutUri(ctx, field)
			case "grantTypes":
				return ec.fieldContext_OAuth2Client_grantTypes(ctx, field)
			case "implicitGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantAccessTokenLifespan(ctx, field)
			case "implicitGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantIdTokenLifespan(ctx, field)
			case "jwks":
				return ec.fieldContext_OAuth2Client_jwks(ctx, field)
			case "jwksUri":
				return ec.fieldContext_OAuth2Client_jwksUri(ctx, field)
			case "jwtBearerGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_jwtBearerGrantAccessTokenLifespan(ctx, field)
			case "logoUri":
				return ec.fieldContext_OAuth2Client_logoUri(ctx, field)
			case "metadata":
				return ec.fieldContext_OAuth2Client_metadata(ctx, field)
			case "owner":
				return ec.fieldContext_OAuth2Client_owner(ctx, field)
			case "policyUri":
				return ec.fieldContext_OAuth2Client_policyUri(ctx, field)
			case "postLogoutRedirectUris":
				return ec.fieldContext_OAuth2Client_postLogoutRedirectUris(ctx, field)
			case "redirectUris":
				return ec.fieldContext_OAuth2Client_redirectUris(ctx, field)
			case "responseTypes":
				return ec.fieldContext_OAuth2Client_responseTypes(ctx, field)
			case "scope":
				return ec.fieldContext_OAuth2Client_scope(ctx, field)
			case "sectorIdentifierUri":
				return ec.fieldContext_OAuth2Client_sectorIdentifierUri(ctx, field)
			case "subjectType":
				return ec.fieldContext_OAuth2Client_subjectType(ctx, field)
			case "tokenEndpointAuthMethod":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthMethod(ctx, field)
			case "tokenEndpointAuthSigningAlgorithm":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthSigningAlgorithm(ctx, field)
			case "tosUri":
				return ec.fieldContext_OAuth2Client_tosUri(ctx, field)
			case "updatedAt":
				return ec.fieldContext_OAuth2Client_updatedAt(ctx, field)
			case "userinfoSignedResponseAlgorithm":
				return ec.fieldContext_OAuth2Client_userinfoSignedResponseAlgorithm(ctx, field)
			case "loginBindings":
				return ec.fieldContext_OAuth2Client_loginBindings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OAuth2Client", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OidcContext_acrValues(ctx context.Context, field graphql.CollectedField, obj *model.OidcContext) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OidcContext_acrValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AcrValues, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OidcContext_acrValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OidcContext",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OidcContext_display(ctx context.Context, field graphql.CollectedField, obj *model.OidcContext) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OidcContext_display(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Display, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OidcContext_display(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OidcContext",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OidcContext_idTokenHintClaims(ctx context.Context, field graphql.CollectedField, obj *model.OidcContext) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OidcContext_idTokenHintClaims(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IDTokenHintClaims, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OidcContext_idTokenHintClaims(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OidcContext",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OidcContext_loginHint(ctx context.Context, field graphql.CollectedField, obj *model.OidcContext) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OidcContext_loginHint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LoginHint, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OidcContext_loginHint(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OidcContext",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OidcContext_uiLocales(ctx context.Context, field graphql.CollectedField, obj *model.OidcContext) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OidcContext_uiLocales(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UILocales, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OidcContext_uiLocales(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OidcContext",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_admins(ctx context.Context, field graphql.CollectedField, obj *model.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_admins(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Organization().Admins(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.User)
	fc.Result = res
	return ec.marshalOUser2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐUserᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_admins(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "recoveryLink":
				return ec.fieldContext_User_recoveryLink(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PolicyMatch_matchType(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.PolicyMatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PolicyMatch_matchType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MatchType, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(v1alpha1.MatchType)
	fc.Result = res
	return ec.marshalOMatchType2githubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐMatchType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PolicyMatch_matchType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PolicyMatch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MatchType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PolicyMatch_attributes(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.PolicyMatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PolicyMatch_attributes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Attributes, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]v1alpha1.MatchPolicyAttribute)
	fc.Result = res
	return ec.marshalOMatchPolicyAttribute2ᚕgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐMatchPolicyAttributeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PolicyMatch_attributes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PolicyMatch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_MatchPolicyAttribute_key(ctx, field)
			case "value":
				return ec.fieldContext_MatchPolicyAttribute_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchPolicyAttribute", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_listUsers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_listUsers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListUsers(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/pluralsh/trace-shield/graph/model.User`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.User)
	fc.Result = res
	return ec.marshalNUser2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐUserᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_listUsers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "recoveryLink":
				return ec.fieldContext_User_recoveryLink(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetUser(rctx, fc.Args["id"].(*string), fc.Args["email"].(*string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/trace-shield/graph/model.User`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	fc.Result = res
	return ec.marshalNUser2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "recoveryLink":
				return ec.fieldContext_User_recoveryLink(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_listGroups(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_listGroups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListGroups(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.Group); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/pluralsh/trace-shield/graph/model.Group`, tmp)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Group)
	fc.Result = res
	return ec.marshalOGroup2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐGroupᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_listGroups(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Group_name(ctx, field)
			case "members":
				return ec.fieldContext_Group_members(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Group", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_listOAuth2Clients(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_listOAuth2Clients(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListOAuth2Clients(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.OAuth2Client); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/pluralsh/trace-shield/graph/model.OAuth2Client`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.OAuth2Client)
	fc.Result = res
	return ec.marshalNOAuth2Client2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2Clientᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_listOAuth2Clients(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "allowedCorsOrigins":
				return ec.fieldContext_OAuth2Client_allowedCorsOrigins(ctx, field)
			case "audience":
				return ec.fieldContext_OAuth2Client_audience(ctx, field)
			case "authorizationCodeGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantAccessTokenLifespan(ctx, field)
			case "authorizationCodeGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantIdTokenLifespan(ctx, field)
			case "authorizationCodeGrantRefreshTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantRefreshTokenLifespan(ctx, field)
			case "backChannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_backChannelLogoutSessionRequired(ctx, field)
			case "backChannelLogoutUri":
				return ec.fieldContext_OAuth2Client_backChannelLogoutUri(ctx, field)
			case "clientCredentialsGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_clientCredentialsGrantAccessTokenLifespan(ctx, field)
			case "clientId":
				return ec.fieldContext_OAuth2Client_clientId(ctx, field)
			case "clientName":
				return ec.fieldContext_OAuth2Client_clientName(ctx, field)
			case "clientSecret":
				return ec.fieldContext_OAuth2Client_clientSecret(ctx, field)
			case "ClientSecretExpiresAt":
				return ec.fieldContext_OAuth2Client_ClientSecretExpiresAt(ctx, field)
			case "clientUri":
				return ec.fieldContext_OAuth2Client_clientUri(ctx, field)
			case "contacts":
				return ec.fieldContext_OAuth2Client_contacts(ctx, field)
			case "createdAt":
				return ec.fieldContext_OAuth2Client_createdAt(ctx, field)
			case "frontchannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutSessionRequired(ctx, field)
			case "frontchannelLogoutUri":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutUri(ctx, field)
			case "grantTypes":
				return ec.fieldContext_OAuth2Client_grantTypes(ctx, field)
			case "implicitGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantAccessTokenLifespan(ctx, field)
			case "implicitGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantIdTokenLifespan(ctx, field)
			case "jwks":
				return ec.fieldContext_OAuth2Client_jwks(ctx, field)
			case "jwksUri":
				return ec.fieldContext_OAuth2Client_jwksUri(ctx, field)
			case "jwtBearerGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_jwtBearerGrantAccessTokenLifespan(ctx, field)
			case "logoUri":
				return ec.fieldContext_OAuth2Client_logoUri(ctx, field)
			case "metadata":
				return ec.fieldContext_OAuth2Client_metadata(ctx, field)
			case "owner":
				return ec.fieldContext_OAuth2Client_owner(ctx, field)
			case "policyUri":
				return ec.fieldContext_OAuth2Client_policyUri(ctx, field)
			case "postLogoutRedirectUris":
				return ec.fieldContext_OAuth2Client_postLogoutRedirectUris(ctx, field)
			case "redirectUris":
				return ec.fieldContext_OAuth2Client_redirectUris(ctx, field)
			case "responseTypes":
				return ec.fieldContext_OAuth2Client_responseTypes(ctx, field)
			case "scope":
				return ec.fieldContext_OAuth2Client_scope(ctx, field)
			case "sectorIdentifierUri":
				return ec.fieldContext_OAuth2Client_sectorIdentifierUri(ctx, field)
			case "subjectType":
				return ec.fieldContext_OAuth2Client_subjectType(ctx, field)
			case "tokenEndpointAuthMethod":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthMethod(ctx, field)
			case "tokenEndpointAuthSigningAlgorithm":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthSigningAlgorithm(ctx, field)
			case "tosUri":
				return ec.fieldContext_OAuth2Client_tosUri(ctx, field)
			case "updatedAt":
				return ec.fieldContext_OAuth2Client_updatedAt(ctx, field)
			case "userinfoSignedResponseAlgorithm":
				return ec.fieldContext_OAuth2Client_userinfoSignedResponseAlgorithm(ctx, field)
			case "loginBindings":
				return ec.fieldContext_OAuth2Client_loginBindings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OAuth2Client", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getOAuth2Client(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getOAuth2Client(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetOAuth2Client(rctx, fc.Args["clientId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.OAuth2Client); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/trace-shield/graph/model.OAuth2Client`, tmp)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.OAuth2Client)
	fc.Result = res
	return ec.marshalOOAuth2Client2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2Client(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getOAuth2Client(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "allowedCorsOrigins":
				return ec.fieldContext_OAuth2Client_allowedCorsOrigins(ctx, field)
			case "audience":
				return ec.fieldContext_OAuth2Client_audience(ctx, field)
			case "authorizationCodeGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantAccessTokenLifespan(ctx, field)
			case "authorizationCodeGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantIdTokenLifespan(ctx, field)
			case "authorizationCodeGrantRefreshTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantRefreshTokenLifespan(ctx, field)
			case "backChannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_backChannelLogoutSessionRequired(ctx, field)
			case "backChannelLogoutUri":
				return ec.fieldContext_OAuth2Client_backChannelLogoutUri(ctx, field)
			case "clientCredentialsGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_clientCredentialsGrantAccessTokenLifespan(ctx, field)
			case "clientId":
				return ec.fieldContext_OAuth2Client_clientId(ctx, field)
			case "clientName":
				return ec.fieldContext_OAuth2Client_clientName(ctx, field)
			case "clientSecret":
				return ec.fieldContext_OAuth2Client_clientSecret(ctx, field)
			case "ClientSecretExpiresAt":
				return ec.fieldContext_OAuth2Client_ClientSecretExpiresAt(ctx, field)
			case "clientUri":
				return ec.fieldContext_OAuth2Client_clientUri(ctx, field)
			case "contacts":
				return ec.fieldContext_OAuth2Client_contacts(ctx, field)
			case "createdAt":
				return ec.fieldContext_OAuth2Client_createdAt(ctx, field)
			case "frontchannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutSessionRequired(ctx, field)
			case "frontchannelLogoutUri":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutUri(ctx, field)
			case "grantTypes":
				return ec.fieldContext_OAuth2Client_grantTypes(ctx, field)
			case "implicitGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantAccessTokenLifespan(ctx, field)
			case "implicitGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantIdTokenLifespan(ctx, field)
			case "jwks":
				return ec.fieldContext_OAuth2Client_jwks(ctx, field)
			case "jwksUri":
				return ec.fieldContext_OAuth2Client_jwksUri(ctx, field)
			case "jwtBearerGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_jwtBearerGrantAccessTokenLifespan(ctx, field)
			case "logoUri":
				return ec.fieldContext_OAuth2Client_logoUri(ctx, field)
			case "metadata":
				return ec.fieldContext_OAuth2Client_metadata(ctx, field)
			case "owner":
				return ec.fieldContext_OAuth2Client_owner(ctx, field)
			case "policyUri":
				return ec.fieldContext_OAuth2Client_policyUri(ctx, field)
			case "postLogoutRedirectUris":
				return ec.fieldContext_OAuth2Client_postLogoutRedirectUris(ctx, field)
			case "redirectUris":
				return ec.fieldContext_OAuth2Client_redirectUris(ctx, field)
			case "responseTypes":
				return ec.fieldContext_OAuth2Client_responseTypes(ctx, field)
			case "scope":
				return ec.fieldContext_OAuth2Client_scope(ctx, field)
			case "sectorIdentifierUri":
				return ec.fieldContext_OAuth2Client_sectorIdentifierUri(ctx, field)
			case "subjectType":
				return ec.fieldContext_OAuth2Client_subjectType(ctx, field)
			case "tokenEndpointAuthMethod":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthMethod(ctx, field)
			case "tokenEndpointAuthSigningAlgorithm":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthSigningAlgorithm(ctx, field)
			case "tosUri":
				return ec.fieldContext_OAuth2Client_tosUri(ctx, field)
			case "updatedAt":
				return ec.fieldContext_OAuth2Client_updatedAt(ctx, field)
			case "userinfoSignedResponseAlgorithm":
				return ec.fieldContext_OAuth2Client_userinfoSignedResponseAlgorithm(ctx, field)
			case "loginBindings":
				return ec.fieldContext_OAuth2Client_loginBindings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OAuth2Client", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getOAuth2Client_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_oauth2ConsentRequest(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_oauth2ConsentRequest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Oauth2ConsentRequest(rctx, fc.Args["challenge"].(string))
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.OAuth2ConsentRequest)
	fc.Result = res
	return ec.marshalOOAuth2ConsentRequest2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2ConsentRequest(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_oauth2ConsentRequest(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "acr":
				return ec.fieldContext_OAuth2ConsentRequest_acr(ctx, field)
			case "amr":
				return ec.fieldContext_OAuth2ConsentRequest_amr(ctx, field)
			case "challenge":
				return ec.fieldContext_OAuth2ConsentRequest_challenge(ctx, field)
			case "client":
				return ec.fieldContext_OAuth2ConsentRequest_client(ctx, field)
			case "context":
				return ec.fieldContext_OAuth2ConsentRequest_context(ctx, field)
			case "loginChallenge":
				return ec.fieldContext_OAuth2ConsentRequest_loginChallenge(ctx, field)
			case "loginSessionId":
				return ec.fieldContext_OAuth2ConsentRequest_loginSessionId(ctx, field)
			case "oidcContext":
				return ec.fieldContext_OAuth2ConsentRequest_oidcContext(ctx, field)
			case "requestUrl":
				return ec.fieldContext_OAuth2ConsentRequest_requestUrl(ctx, field)
			case "requestedAccessTokenAudience":
				return ec.fieldContext_OAuth2ConsentRequest_requestedAccessTokenAudience(ctx, field)
			case "requestedScope":
				return ec.fieldContext_OAuth2ConsentRequest_requestedScope(ctx, field)
			case "skip":
				return ec.fieldContext_OAuth2ConsentRequest_skip(ctx, field)
			case "subject":
				return ec.fieldContext_OAuth2ConsentRequest_subject(ctx, field)
			case "redirectTo":
				return ec.fieldContext_OAuth2ConsentRequest_redirectTo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OAuth2ConsentRequest", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_oauth2ConsentRequest_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_oauth2LoginRequest(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_oauth2LoginRequest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Oauth2LoginRequest(rctx, fc.Args["challenge"].(string))
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.OAuth2LoginRequest)
	fc.Result = res
	return ec.marshalOOAuth2LoginRequest2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2LoginRequest(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_oauth2LoginRequest(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "challenge":
				return ec.fieldContext_OAuth2LoginRequest_challenge(ctx, field)
			case "client":
				return ec.fieldContext_OAuth2LoginRequest_client(ctx, field)
			case "oidcContext":
				return ec.fieldContext_OAuth2LoginRequest_oidcContext(ctx, field)
			case "requestUrl":
				return ec.fieldContext_OAuth2LoginRequest_requestUrl(ctx, field)
			case "requestedAccessTokenAudience":
				return ec.fieldContext_OAuth2LoginRequest_requestedAccessTokenAudience(ctx, field)
			case "requestedScope":
				return ec.fieldContext_OAuth2LoginRequest_requestedScope(ctx, field)
			case "sessionId":
				return ec.fieldContext_OAuth2LoginRequest_sessionId(ctx, field)
			case "skip":
				return ec.fieldContext_OAuth2LoginRequest_skip(ctx, field)
			case "subject":
				return ec.fieldContext_OAuth2LoginRequest_subject(ctx, field)
			case "redirectTo":
				return ec.fieldContext_OAuth2LoginRequest_redirectTo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OAuth2LoginRequest", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_oauth2LoginRequest_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_listObservabilityTenants(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_listObservabilityTenants(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListObservabilityTenants(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.ObservabilityTenant); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/pluralsh/trace-shield/graph/model.ObservabilityTenant`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ObservabilityTenant)
	fc.Result = res
	return ec.marshalNObservabilityTenant2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_listObservabilityTenants(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ObservabilityTenant_id(ctx, field)
			case "displayName":
				return ec.fieldContext_ObservabilityTenant_displayName(ctx, field)
			case "admins":
				return ec.fieldContext_ObservabilityTenant_admins(ctx, field)
			case "metricsReaders":
				return ec.fieldContext_ObservabilityTenant_metricsReaders(ctx, field)
			case "metricsWriters":
				return ec.fieldContext_ObservabilityTenant_metricsWriters(ctx, field)
			case "metricsDeleters":
				return ec.fieldContext_ObservabilityTenant_metricsDeleters(ctx, field)
			case "metricsRulesReaders":
				return ec.fieldContext_ObservabilityTenant_metricsRulesReaders(ctx, field)
			case "metricsRulesWriters":
				return ec.fieldContext_ObservabilityTenant_metricsRulesWriters(ctx, field)
			case "metricsRulesDeleters":
				return ec.fieldContext_ObservabilityTenant_metricsRulesDeleters(ctx, field)
			case "metricsAlertsReaders":
				return ec.fieldContext_ObservabilityTenant_metricsAlertsReaders(ctx, field)
			case "metricsAlertsWriters":
				return ec.fieldContext_ObservabilityTenant_metricsAlertsWriters(ctx, field)
			case "logsReaders":
				return ec.fieldContext_ObservabilityTenant_logsReaders(ctx, field)
			case "logsWriters":
				return ec.fieldContext_ObservabilityTenant_logsWriters(ctx, field)
			case "logsDeleters":
				return ec.fieldContext_ObservabilityTenant_logsDeleters(ctx, field)
			case "logsRulesReaders":
				return ec.fieldContext_ObservabilityTenant_logsRulesReaders(ctx, field)
			case "logsRulesWriters":
				return ec.fieldContext_ObservabilityTenant_logsRulesWriters(ctx, field)
			case "logsRulesDeleters":
				return ec.fieldContext_ObservabilityTenant_logsRulesDeleters(ctx, field)
			case "tracesReaders":
				return ec.fieldContext_ObservabilityTenant_tracesReaders(ctx, field)
			case "tracesWriters":
				return ec.fieldContext_ObservabilityTenant_tracesWriters(ctx, field)
			case "limits":
				return ec.fieldContext_ObservabilityTenant_limits(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenant", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getObservabilityTenant(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getObservabilityTenant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetObservabilityTenant(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ObservabilityTenant); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/trace-shield/graph/model.ObservabilityTenant`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenant)
	fc.Result = res
	return ec.marshalNObservabilityTenant2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenant(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getObservabilityTenant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ObservabilityTenant_id(ctx, field)
			case "displayName":
				return ec.fieldContext_ObservabilityTenant_displayName(ctx, field)
			case "admins":
				return ec.fieldContext_ObservabilityTenant_admins(ctx, field)
			case "metricsReaders":
				return ec.fieldContext_ObservabilityTenant_metricsReaders(ctx, field)
			case "metricsWriters":
				return ec.fieldContext_ObservabilityTenant_metricsWriters(ctx, field)
			case "metricsDeleters":
				return ec.fieldContext_ObservabilityTenant_metricsDeleters(ctx, field)
			case "metricsRulesReaders":
				return ec.fieldContext_ObservabilityTenant_metricsRulesReaders(ctx, field)
			case "metricsRulesWriters":
				return ec.fieldContext_ObservabilityTenant_metricsRulesWriters(ctx, field)
			case "metricsRulesDeleters":
				return ec.fieldContext_ObservabilityTenant_metricsRulesDeleters(ctx, field)
			case "metricsAlertsReaders":
				return ec.fieldContext_ObservabilityTenant_metricsAlertsReaders(ctx, field)
			case "metricsAlertsWriters":
				return ec.fieldContext_ObservabilityTenant_metricsAlertsWriters(ctx, field)
			case "logsReaders":
				return ec.fieldContext_ObservabilityTenant_logsReaders(ctx, field)
			case "logsWriters":
				return ec.fieldContext_ObservabilityTenant_logsWriters(ctx, field)
			case "logsDeleters":
				return ec.fieldContext_ObservabilityTenant_logsDeleters(ctx, field)
			case "logsRulesReaders":
				return ec.fieldContext_ObservabilityTenant_logsRulesReaders(ctx, field)
			case "logsRulesWriters":
				return ec.fieldContext_ObservabilityTenant_logsRulesWriters(ctx, field)
			case "logsRulesDeleters":
				return ec.fieldContext_ObservabilityTenant_logsRulesDeleters(ctx, field)
			case "tracesReaders":
				return ec.fieldContext_ObservabilityTenant_tracesReaders(ctx, field)
			case "tracesWriters":
				return ec.fieldContext_ObservabilityTenant_tracesWriters(ctx, field)
			case "limits":
				return ec.fieldContext_ObservabilityTenant_limits(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenant", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getObservabilityTenant_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_organization(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_organization(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Organization(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Organization); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/trace-shield/graph/model.Organization`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Organization)
	fc.Result = res
	return ec.marshalNOrganization2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOrganization(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_organization(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "admins":
				return ec.fieldContext_Organization_admins(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Organization", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RelabelConfig_sourceLabels(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.RelabelConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RelabelConfig_sourceLabels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RelabelConfig().SourceLabels(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2ᚕᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RelabelConfig_sourceLabels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RelabelConfig",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RelabelConfig_separator(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.RelabelConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RelabelConfig_separator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Separator, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RelabelConfig_separator(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RelabelConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RelabelConfig_regex(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.RelabelConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RelabelConfig_regex(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Regex, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RelabelConfig_regex(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RelabelConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RelabelConfig_modulus(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.RelabelConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RelabelConfig_modulus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Modulus, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUInt2ᚖuint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RelabelConfig_modulus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RelabelConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RelabelConfig_targetLabel(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.RelabelConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RelabelConfig_targetLabel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TargetLabel, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RelabelConfig_targetLabel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RelabelConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RelabelConfig_replacement(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.RelabelConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RelabelConfig_replacement(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Replacement, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RelabelConfig_replacement(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RelabelConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RelabelConfig_action(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.RelabelConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RelabelConfig_action(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RelabelConfig().Action(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.RelabelAction)
	fc.Result = res
	return ec.marshalORelabelAction2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐRelabelAction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RelabelConfig_action(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RelabelConfig",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RelabelAction does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RulerAlertManagerConfig_alertmanagerURL(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.RulerAlertManagerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RulerAlertManagerConfig_alertmanagerURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AlertmanagerURL, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RulerAlertManagerConfig_alertmanagerURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RulerAlertManagerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RulerAlertManagerConfig_alertmanagerDiscovery(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.RulerAlertManagerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RulerAlertManagerConfig_alertmanagerDiscovery(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AlertmanagerDiscovery, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RulerAlertManagerConfig_alertmanagerDiscovery(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RulerAlertManagerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RulerAlertManagerConfig_alertmanagerRefreshInterval(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.RulerAlertManagerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RulerAlertManagerConfig_alertmanagerRefreshInterval(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AlertmanagerRefreshInterval, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RulerAlertManagerConfig_alertmanagerRefreshInterval(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RulerAlertManagerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RulerAlertManagerConfig_alertmanangerEnableV2API(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.RulerAlertManagerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RulerAlertManagerConfig_alertmanangerEnableV2API(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AlertmanangerEnableV2API, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RulerAlertManagerConfig_alertmanangerEnableV2API(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RulerAlertManagerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RulerAlertManagerConfig_alertRelabelConfigs(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.RulerAlertManagerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RulerAlertManagerConfig_alertRelabelConfigs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AlertRelabelConfigs, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*v1alpha1.RelabelConfig)
	fc.Result = res
	return ec.marshalORelabelConfig2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐRelabelConfigᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RulerAlertManagerConfig_alertRelabelConfigs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RulerAlertManagerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "sourceLabels":
				return ec.fieldContext_RelabelConfig_sourceLabels(ctx, field)
			case "separator":
				return ec.fieldContext_RelabelConfig_separator(ctx, field)
			case "regex":
				return ec.fieldContext_RelabelConfig_regex(ctx, field)
			case "modulus":
				return ec.fieldContext_RelabelConfig_modulus(ctx, field)
			case "targetLabel":
				return ec.fieldContext_RelabelConfig_targetLabel(ctx, field)
			case "replacement":
				return ec.fieldContext_RelabelConfig_replacement(ctx, field)
			case "action":
				return ec.fieldContext_RelabelConfig_action(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RelabelConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RulerAlertManagerConfig_notificationQueueCapacity(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.RulerAlertManagerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RulerAlertManagerConfig_notificationQueueCapacity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NotificationQueueCapacity, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RulerAlertManagerConfig_notificationQueueCapacity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RulerAlertManagerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RulerAlertManagerConfig_notificationTimeout(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.RulerAlertManagerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RulerAlertManagerConfig_notificationTimeout(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NotificationTimeout, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RulerAlertManagerConfig_notificationTimeout(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RulerAlertManagerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RulerAlertManagerConfig_notifier(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.RulerAlertManagerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RulerAlertManagerConfig_notifier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Notifier, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(v1alpha1.NotifierConfig)
	fc.Result = res
	return ec.marshalONotifierConfig2githubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐNotifierConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RulerAlertManagerConfig_notifier(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RulerAlertManagerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "basicAuth":
				return ec.fieldContext_NotifierConfig_basicAuth(ctx, field)
			case "headerAuth":
				return ec.fieldContext_NotifierConfig_headerAuth(ctx, field)
			case "tls":
				return ec.fieldContext_NotifierConfig_tls(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NotifierConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ShardstreamsConfig_enabled(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.ShardstreamsConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ShardstreamsConfig_enabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enabled, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ShardstreamsConfig_enabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ShardstreamsConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ShardstreamsConfig_loggingEnabled(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.ShardstreamsConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ShardstreamsConfig_loggingEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LoggingEnabled, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ShardstreamsConfig_loggingEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ShardstreamsConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ShardstreamsConfig_desiredRate(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.ShardstreamsConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ShardstreamsConfig_desiredRate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DesiredRate, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUInt2ᚖuint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ShardstreamsConfig_desiredRate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ShardstreamsConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StreamRetention_period(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.StreamRetention) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StreamRetention_period(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Period, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(v1.Duration)
	fc.Result = res
	return ec.marshalODuration2k8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StreamRetention_period(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StreamRetention",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StreamRetention_priority(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.StreamRetention) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StreamRetention_priority(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Priority, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StreamRetention_priority(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StreamRetention",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StreamRetention_selector(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.StreamRetention) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StreamRetention_selector(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Selector, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StreamRetention_selector(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StreamRetention",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TempoLimits_ingestionRateStrategy(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.TempoLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TempoLimits_ingestionRateStrategy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IngestionRateStrategy, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TempoLimits_ingestionRateStrategy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TempoLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TempoLimits_ingestionRateLimitBytes(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.TempoLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TempoLimits_ingestionRateLimitBytes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IngestionRateLimitBytes, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TempoLimits_ingestionRateLimitBytes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TempoLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TempoLimits_ingestionBurstSizeBytes(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.TempoLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TempoLimits_ingestionBurstSizeBytes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IngestionBurstSizeBytes, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TempoLimits_ingestionBurstSizeBytes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TempoLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TempoLimits_maxLocalTracesPerUser(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.TempoLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TempoLimits_maxLocalTracesPerUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxLocalTracesPerUser, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TempoLimits_maxLocalTracesPerUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TempoLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TempoLimits_maxGlobalTracesPerUser(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.TempoLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TempoLimits_maxGlobalTracesPerUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxGlobalTracesPerUser, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TempoLimits_maxGlobalTracesPerUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TempoLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TempoLimits_forwarders(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.TempoLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TempoLimits_forwarders(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Forwarders, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TempoLimits_forwarders(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TempoLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TempoLimits_metricsGeneratorRingSize(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.TempoLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TempoLimits_metricsGeneratorRingSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MetricsGeneratorRingSize, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TempoLimits_metricsGeneratorRingSize(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TempoLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TempoLimits_metricsGeneratorProcessors(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.TempoLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TempoLimits_metricsGeneratorProcessors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MetricsGeneratorProcessors, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2ᚕᚖstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TempoLimits_metricsGeneratorProcessors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TempoLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TempoLimits_metricsGeneratorMaxActiveSeries(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.TempoLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TempoLimits_metricsGeneratorMaxActiveSeries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MetricsGeneratorMaxActiveSeries, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint32)
	fc.Result = res
	return ec.marshalOUInt2ᚖuint32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TempoLimits_metricsGeneratorMaxActiveSeries(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TempoLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TempoLimits_metricsGeneratorCollectionInterval(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.TempoLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TempoLimits_metricsGeneratorCollectionInterval(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MetricsGeneratorCollectionInterval, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TempoLimits_metricsGeneratorCollectionInterval(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TempoLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TempoLimits_metricsGeneratorDisableCollection(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.TempoLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TempoLimits_metricsGeneratorDisableCollection(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MetricsGeneratorDisableCollection, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TempoLimits_metricsGeneratorDisableCollection(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TempoLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TempoLimits_metricsGeneratorForwarderQueueSize(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.TempoLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TempoLimits_metricsGeneratorForwarderQueueSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MetricsGeneratorForwarderQueueSize, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TempoLimits_metricsGeneratorForwarderQueueSize(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TempoLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TempoLimits_metricsGeneratorForwarderWorkers(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.TempoLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TempoLimits_metricsGeneratorForwarderWorkers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MetricsGeneratorForwarderWorkers, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TempoLimits_metricsGeneratorForwarderWorkers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TempoLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TempoLimits_metricsGeneratorProcessorServiceGraphsHistogramBuckets(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.TempoLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TempoLimits_metricsGeneratorProcessorServiceGraphsHistogramBuckets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MetricsGeneratorProcessorServiceGraphsHistogramBuckets, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]float64)
	fc.Result = res
	return ec.marshalOFloat2ᚕfloat64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TempoLimits_metricsGeneratorProcessorServiceGraphsHistogramBuckets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TempoLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TempoLimits_metricsGeneratorProcessorServiceGraphsDimensions(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.TempoLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TempoLimits_metricsGeneratorProcessorServiceGraphsDimensions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MetricsGeneratorProcessorServiceGraphsDimensions, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TempoLimits_metricsGeneratorProcessorServiceGraphsDimensions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TempoLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TempoLimits_metricsGeneratorProcessorServiceGraphsPeerAttributes(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.TempoLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TempoLimits_metricsGeneratorProcessorServiceGraphsPeerAttributes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MetricsGeneratorProcessorServiceGraphsPeerAttributes, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TempoLimits_metricsGeneratorProcessorServiceGraphsPeerAttributes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TempoLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TempoLimits_metricsGeneratorProcessorServiceGraphsEnableClientServerPrefix(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.TempoLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TempoLimits_metricsGeneratorProcessorServiceGraphsEnableClientServerPrefix(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MetricsGeneratorProcessorServiceGraphsEnableClientServerPrefix, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TempoLimits_metricsGeneratorProcessorServiceGraphsEnableClientServerPrefix(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TempoLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TempoLimits_metricsGeneratorProcessorSpanMetricsHistogramBuckets(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.TempoLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TempoLimits_metricsGeneratorProcessorSpanMetricsHistogramBuckets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MetricsGeneratorProcessorSpanMetricsHistogramBuckets, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]float64)
	fc.Result = res
	return ec.marshalOFloat2ᚕfloat64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TempoLimits_metricsGeneratorProcessorSpanMetricsHistogramBuckets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TempoLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TempoLimits_metricsGeneratorProcessorSpanMetricsDimensions(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.TempoLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TempoLimits_metricsGeneratorProcessorSpanMetricsDimensions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MetricsGeneratorProcessorSpanMetricsDimensions, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TempoLimits_metricsGeneratorProcessorSpanMetricsDimensions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TempoLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TempoLimits_metricsGeneratorProcessorSpanMetricsIntrinsicDimensions(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.TempoLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TempoLimits_metricsGeneratorProcessorSpanMetricsIntrinsicDimensions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MetricsGeneratorProcessorSpanMetricsIntrinsicDimensions, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]bool)
	fc.Result = res
	return ec.marshalOBoolMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TempoLimits_metricsGeneratorProcessorSpanMetricsIntrinsicDimensions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TempoLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BoolMap does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TempoLimits_metricsGeneratorProcessorSpanMetricsFilterPolicies(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.TempoLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TempoLimits_metricsGeneratorProcessorSpanMetricsFilterPolicies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MetricsGeneratorProcessorSpanMetricsFilterPolicies, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]v1alpha1.FilterPolicy)
	fc.Result = res
	return ec.marshalOFilterPolicy2ᚕgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐFilterPolicyᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TempoLimits_metricsGeneratorProcessorSpanMetricsFilterPolicies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TempoLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "include":
				return ec.fieldContext_FilterPolicy_include(ctx, field)
			case "exclude":
				return ec.fieldContext_FilterPolicy_exclude(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FilterPolicy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TempoLimits_metricsGeneratorProcessorSpanMetricsDimensionMappings(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.TempoLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TempoLimits_metricsGeneratorProcessorSpanMetricsDimensionMappings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MetricsGeneratorProcessorSpanMetricsDimensionMappings, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]v1alpha1.DimensionMappings)
	fc.Result = res
	return ec.marshalODimensionMappings2ᚕgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐDimensionMappingsᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TempoLimits_metricsGeneratorProcessorSpanMetricsDimensionMappings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TempoLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_DimensionMappings_name(ctx, field)
			case "sourceLabel":
				return ec.fieldContext_DimensionMappings_sourceLabel(ctx, field)
			case "join":
				return ec.fieldContext_DimensionMappings_join(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DimensionMappings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TempoLimits_metricsGeneratorProcessorSpanMetricsEnableTargetInfo(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.TempoLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TempoLimits_metricsGeneratorProcessorSpanMetricsEnableTargetInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MetricsGeneratorProcessorSpanMetricsEnableTargetInfo, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TempoLimits_metricsGeneratorProcessorSpanMetricsEnableTargetInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TempoLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TempoLimits_metricsGeneratorProcessorLocalBlocksMaxLiveTraces(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.TempoLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TempoLimits_metricsGeneratorProcessorLocalBlocksMaxLiveTraces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MetricsGeneratorProcessorLocalBlocksMaxLiveTraces, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUInt2ᚖuint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TempoLimits_metricsGeneratorProcessorLocalBlocksMaxLiveTraces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TempoLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TempoLimits_metricsGeneratorProcessorLocalBlocksMaxBlockDuration(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.TempoLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TempoLimits_metricsGeneratorProcessorLocalBlocksMaxBlockDuration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MetricsGeneratorProcessorLocalBlocksMaxBlockDuration, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TempoLimits_metricsGeneratorProcessorLocalBlocksMaxBlockDuration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TempoLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TempoLimits_metricsGeneratorProcessorLocalBlocksMaxBlockBytes(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.TempoLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TempoLimits_metricsGeneratorProcessorLocalBlocksMaxBlockBytes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MetricsGeneratorProcessorLocalBlocksMaxBlockBytes, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUInt2ᚖuint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TempoLimits_metricsGeneratorProcessorLocalBlocksMaxBlockBytes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TempoLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TempoLimits_metricsGeneratorProcessorLocalBlocksFlushCheckPeriod(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.TempoLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TempoLimits_metricsGeneratorProcessorLocalBlocksFlushCheckPeriod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MetricsGeneratorProcessorLocalBlocksFlushCheckPeriod, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TempoLimits_metricsGeneratorProcessorLocalBlocksFlushCheckPeriod(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TempoLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TempoLimits_metricsGeneratorProcessorLocalBlocksTraceIdlePeriod(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.TempoLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TempoLimits_metricsGeneratorProcessorLocalBlocksTraceIdlePeriod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MetricsGeneratorProcessorLocalBlocksTraceIdlePeriod, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TempoLimits_metricsGeneratorProcessorLocalBlocksTraceIdlePeriod(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TempoLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TempoLimits_metricsGeneratorProcessorLocalBlocksCompleteBlockTimeout(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.TempoLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TempoLimits_metricsGeneratorProcessorLocalBlocksCompleteBlockTimeout(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MetricsGeneratorProcessorLocalBlocksCompleteBlockTimeout, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TempoLimits_metricsGeneratorProcessorLocalBlocksCompleteBlockTimeout(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TempoLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TempoLimits_blockRetention(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.TempoLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TempoLimits_blockRetention(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BlockRetention, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TempoLimits_blockRetention(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TempoLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TempoLimits_maxBytesPerTagValuesQuery(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.TempoLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TempoLimits_maxBytesPerTagValuesQuery(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxBytesPerTagValuesQuery, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TempoLimits_maxBytesPerTagValuesQuery(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TempoLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TempoLimits_maxBlocksPerTagValuesQuery(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.TempoLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TempoLimits_maxBlocksPerTagValuesQuery(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxBlocksPerTagValuesQuery, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TempoLimits_maxBlocksPerTagValuesQuery(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TempoLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TempoLimits_maxSearchDuration(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.TempoLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TempoLimits_maxSearchDuration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxSearchDuration, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*v1.Duration)
	fc.Result = res
	return ec.marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TempoLimits_maxSearchDuration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TempoLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TempoLimits_maxBytesPerTrace(ctx context.Context, field graphql.CollectedField, obj *v1alpha1.TempoLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TempoLimits_maxBytesPerTrace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxBytesPerTrace, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TempoLimits_maxBytesPerTrace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TempoLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_name(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Name)
	fc.Result = res
	return ec.marshalOName2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐName(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "first":
				return ec.fieldContext_Name_first(ctx, field)
			case "last":
				return ec.fieldContext_Name_last(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Name", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_email(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_email(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_groups(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_groups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().Groups(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Group)
	fc.Result = res
	return ec.marshalOGroup2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐGroupᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_groups(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Group_name(ctx, field)
			case "members":
				return ec.fieldContext_Group_members(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Group", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_recoveryLink(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_recoveryLink(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RecoveryLink, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_recoveryLink(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAcceptOAuth2ConsentRequestSession(ctx context.Context, obj interface{}) (model.AcceptOAuth2ConsentRequestSession, error) {
	var it model.AcceptOAuth2ConsentRequestSession
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"accessToken", "idToken"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "accessToken":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accessToken"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.AccessToken = data
		case "idToken":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idToken"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDToken = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBlockedQueryInput(ctx context.Context, obj interface{}) (model.BlockedQueryInput, error) {
	var it model.BlockedQueryInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"pattern", "regex", "hash", "types"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "pattern":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pattern"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Pattern = data
		case "regex":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("regex"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Regex = data
		case "hash":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hash"))
			data, err := ec.unmarshalOUInt2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Hash = data
		case "types":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("types"))
			data, err := ec.unmarshalOBlockedQueryType2ᚕgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐBlockedQueryTypeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Types = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDimensionMappingsInput(ctx context.Context, obj interface{}) (model.DimensionMappingsInput, error) {
	var it model.DimensionMappingsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "sourceLabel", "join"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "sourceLabel":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceLabel"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceLabel = data
		case "join":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("join"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Join = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFilterPolicyInput(ctx context.Context, obj interface{}) (model.FilterPolicyInput, error) {
	var it model.FilterPolicyInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"include", "exclude"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "include":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("include"))
			data, err := ec.unmarshalOPolicyMatchInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐPolicyMatchInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Include = data
		case "exclude":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("exclude"))
			data, err := ec.unmarshalOPolicyMatchInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐPolicyMatchInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Exclude = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGroupInput(ctx context.Context, obj interface{}) (model.GroupInput, error) {
	var it model.GroupInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLoginBindingsInput(ctx context.Context, obj interface{}) (model.LoginBindingsInput, error) {
	var it model.LoginBindingsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"users", "groups"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "users":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("users"))
			data, err := ec.unmarshalOUserInput2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐUserInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Users = data
		case "groups":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("groups"))
			data, err := ec.unmarshalOGroupInput2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐGroupInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Groups = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLokiLimitsInput(ctx context.Context, obj interface{}) (v1alpha1.LokiLimitsInput, error) {
	var it v1alpha1.LokiLimitsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ingestionRateStrategy", "ingestionRateMB", "ingestionBurstSizeMB", "maxLabelNameLength", "maxLabelValueLength", "maxLabelNamesPerSeries", "rejectOldSamples", "rejectOldSamplesMaxAge", "creationGracePeriod", "enforceMetricName", "maxLineSize", "maxLineSizeTruncate", "incrementDuplicateTimestamp", "maxLocalStreamsPerUser", "maxGlobalStreamsPerUser", "unorderedWrites", "perStreamRateLimit", "perStreamRateLimitBurst", "maxChunksPerQuery", "maxQuerySeries", "maxQueryLookback", "maxQueryLength", "maxQueryRange", "maxQueryParallelism", "tsdbMaxQueryParallelism", "tsdbMaxBytesPerShard", "cardinalityLimit", "maxStreamsMatchersPerQuery", "maxConcurrentTailRequests", "maxEntriesLimitPerQuery", "maxCacheFreshness", "maxStatsCacheFreshness", "maxQueriersPerTenant", "queryReadyIndexNumDays", "queryTimeout", "querySplitDuration", "minShardingLookback", "maxQueryBytesRead", "maxQuerierBytesRead", "volumeEnabled", "volumeMaxSeries", "rulerEvaluationDelay", "rulerMaxRulesPerRuleGroup", "rulerMaxRuleGroupsPerTenant", "rulerAlertManagerConfig", "rulerTenantShardSize", "rulerRemoteWriteDisabled", "rulerRemoteEvaluationTimeout", "rulerRemoteEvaluationMaxResponseSize", "deletionMode", "retentionPeriod", "streamRetention", "shardStreams", "blockedQueries", "requiredLabels", "requiredNumberLabels", "indexGatewayShardSize"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ingestionRateStrategy":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ingestionRateStrategy"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IngestionRateStrategy = data
		case "ingestionRateMB":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ingestionRateMB"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.IngestionRateMB = data
		case "ingestionBurstSizeMB":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ingestionBurstSizeMB"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.IngestionBurstSizeMB = data
		case "maxLabelNameLength":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxLabelNameLength"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxLabelNameLength = data
		case "maxLabelValueLength":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxLabelValueLength"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxLabelValueLength = data
		case "maxLabelNamesPerSeries":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxLabelNamesPerSeries"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxLabelNamesPerSeries = data
		case "rejectOldSamples":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rejectOldSamples"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.RejectOldSamples = data
		case "rejectOldSamplesMaxAge":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rejectOldSamplesMaxAge"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.RejectOldSamplesMaxAge = data
		case "creationGracePeriod":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("creationGracePeriod"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreationGracePeriod = data
		case "enforceMetricName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("enforceMetricName"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.EnforceMetricName = data
		case "maxLineSize":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxLineSize"))
			data, err := ec.unmarshalOUInt2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxLineSize = data
		case "maxLineSizeTruncate":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxLineSizeTruncate"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxLineSizeTruncate = data
		case "incrementDuplicateTimestamp":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("incrementDuplicateTimestamp"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IncrementDuplicateTimestamp = data
		case "maxLocalStreamsPerUser":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxLocalStreamsPerUser"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxLocalStreamsPerUser = data
		case "maxGlobalStreamsPerUser":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxGlobalStreamsPerUser"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxGlobalStreamsPerUser = data
		case "unorderedWrites":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unorderedWrites"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UnorderedWrites = data
		case "perStreamRateLimit":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("perStreamRateLimit"))
			data, err := ec.unmarshalOUInt2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.PerStreamRateLimit = data
		case "perStreamRateLimitBurst":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("perStreamRateLimitBurst"))
			data, err := ec.unmarshalOUInt2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.PerStreamRateLimitBurst = data
		case "maxChunksPerQuery":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxChunksPerQuery"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxChunksPerQuery = data
		case "maxQuerySeries":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxQuerySeries"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxQuerySeries = data
		case "maxQueryLookback":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxQueryLookback"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxQueryLookback = data
		case "maxQueryLength":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxQueryLength"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxQueryLength = data
		case "maxQueryRange":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxQueryRange"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxQueryRange = data
		case "maxQueryParallelism":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxQueryParallelism"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxQueryParallelism = data
		case "tsdbMaxQueryParallelism":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tsdbMaxQueryParallelism"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.TSDBMaxQueryParallelism = data
		case "tsdbMaxBytesPerShard":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tsdbMaxBytesPerShard"))
			data, err := ec.unmarshalOUInt2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.TSDBMaxBytesPerShard = data
		case "cardinalityLimit":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardinalityLimit"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardinalityLimit = data
		case "maxStreamsMatchersPerQuery":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxStreamsMatchersPerQuery"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxStreamsMatchersPerQuery = data
		case "maxConcurrentTailRequests":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxConcurrentTailRequests"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxConcurrentTailRequests = data
		case "maxEntriesLimitPerQuery":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxEntriesLimitPerQuery"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxEntriesLimitPerQuery = data
		case "maxCacheFreshness":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxCacheFreshness"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxCacheFreshness = data
		case "maxStatsCacheFreshness":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxStatsCacheFreshness"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxStatsCacheFreshness = data
		case "maxQueriersPerTenant":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxQueriersPerTenant"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxQueriersPerTenant = data
		case "queryReadyIndexNumDays":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("queryReadyIndexNumDays"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.QueryReadyIndexNumDays = data
		case "queryTimeout":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("queryTimeout"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.QueryTimeout = data
		case "querySplitDuration":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("querySplitDuration"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.QuerySplitDuration = data
		case "minShardingLookback":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minShardingLookback"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.MinShardingLookback = data
		case "maxQueryBytesRead":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxQueryBytesRead"))
			data, err := ec.unmarshalOUInt2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxQueryBytesRead = data
		case "maxQuerierBytesRead":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxQuerierBytesRead"))
			data, err := ec.unmarshalOUInt2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxQuerierBytesRead = data
		case "volumeEnabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("volumeEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.VolumeEnabled = data
		case "volumeMaxSeries":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("volumeMaxSeries"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.VolumeMaxSeries = data
		case "rulerEvaluationDelay":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rulerEvaluationDelay"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.RulerEvaluationDelay = data
		case "rulerMaxRulesPerRuleGroup":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rulerMaxRulesPerRuleGroup"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.RulerMaxRulesPerRuleGroup = data
		case "rulerMaxRuleGroupsPerTenant":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rulerMaxRuleGroupsPerTenant"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.RulerMaxRuleGroupsPerTenant = data
		case "rulerAlertManagerConfig":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rulerAlertManagerConfig"))
			data, err := ec.unmarshalORulerAlertManagerConfigInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐRulerAlertManagerConfigInput(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LokiLimitsInput().RulerAlertManagerConfig(ctx, &it, data); err != nil {
				return it, err
			}
		case "rulerTenantShardSize":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rulerTenantShardSize"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.RulerTenantShardSize = data
		case "rulerRemoteWriteDisabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rulerRemoteWriteDisabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.RulerRemoteWriteDisabled = data
		case "rulerRemoteEvaluationTimeout":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rulerRemoteEvaluationTimeout"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.RulerRemoteEvaluationTimeout = data
		case "rulerRemoteEvaluationMaxResponseSize":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rulerRemoteEvaluationMaxResponseSize"))
			data, err := ec.unmarshalOInt2ᚖint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.RulerRemoteEvaluationMaxResponseSize = data
		case "deletionMode":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletionMode"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletionMode = data
		case "retentionPeriod":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("retentionPeriod"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.RetentionPeriod = data
		case "streamRetention":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("streamRetention"))
			data, err := ec.unmarshalOStreamRetentionInput2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐStreamRetentionInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LokiLimitsInput().StreamRetention(ctx, &it, data); err != nil {
				return it, err
			}
		case "shardStreams":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("shardStreams"))
			data, err := ec.unmarshalOShardstreamsConfigInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐShardstreamsConfigInput(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LokiLimitsInput().ShardStreams(ctx, &it, data); err != nil {
				return it, err
			}
		case "blockedQueries":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockedQueries"))
			data, err := ec.unmarshalOBlockedQueryInput2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐBlockedQueryInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LokiLimitsInput().BlockedQueries(ctx, &it, data); err != nil {
				return it, err
			}
		case "requiredLabels":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requiredLabels"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.RequiredLabels = data
		case "requiredNumberLabels":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requiredNumberLabels"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.RequiredNumberLabels = data
		case "indexGatewayShardSize":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indexGatewayShardSize"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndexGatewayShardSize = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMatchPolicyAttributeInput(ctx context.Context, obj interface{}) (model.MatchPolicyAttributeInput, error) {
	var it model.MatchPolicyAttributeInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "value":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMimirLimitsInput(ctx context.Context, obj interface{}) (v1alpha1.MimirLimitsInput, error) {
	var it v1alpha1.MimirLimitsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"requestRate", "requestBurstSize", "ingestionRate", "ingestionBurstSize", "acceptHASamples", "haClusterLabel", "haReplicaLabel", "haMaxClusters", "dropLabels", "maxLabelNameLength", "maxLabelValueLength", "maxLabelNamesPerSeries", "maxMetadataLength", "maxNativeHistogramBuckets", "creationGracePeriod", "enforceMetadataMetricName", "ingestionTenantShardSize", "metricRelabelConfigs", "maxGlobalSeriesPerUser", "maxGlobalSeriesPerMetric", "maxGlobalMetricsWithMetadataPerUser", "maxGlobalMetadataPerMetric", "maxGlobalExemplarsPerUser", "nativeHistogramsIngestionEnabled", "activeSeriesCustomTrackersConfig", "outOfOrderTimeWindow", "outOfOrderBlocksExternalLabelEnabled", "separateMetricsGroupLabel", "maxChunksPerQuery", "maxFetchedSeriesPerQuery", "maxFetchedChunkBytesPerQuery", "maxQueryLookback", "maxPartialQueryLength", "maxQueryParallelism", "maxLabelsQueryLength", "maxCacheFreshness", "maxQueriersPerTenant", "queryShardingTotalShards", "queryShardingMaxShardedQueries", "queryShardingMaxRegexpSizeBytes", "splitInstantQueriesByInterval", "QueryIngestersWithin", "maxTotalQueryLength", "resultsCacheTTL", "resultsCacheTTLForOutOfOrderTimeWindow", "resultsCacheTTLForCardinalityQuery", "resultsCacheTTLForLabelsQuery", "resultsCacheForUnalignedQueryEnabled", "maxQueryExpressionSizeBytes", "cardinalityAnalysisEnabled", "labelNamesAndValuesResultsMaxSizeBytes", "labelValuesMaxCardinalityLabelNamesPerRequest", "rulerEvaluationDelay", "rulerTenantShardSize", "rulerMaxRulesPerRuleGroup", "rulerMaxRuleGroupsPerTenant", "rulerRecordingRulesEvaluationEnabled", "rulerAlertingRulesEvaluationEnabled", "rulerSyncRulesOnChangesEnabled", "storeGatewayTenantShardSize", "compactorBlocksRetentionPeriod", "compactorSplitAndMergeShards", "compactorSplitGroups", "compactorTenantShardSize", "compactorPartialBlockDeletionDelay", "compactorBlockUploadEnabled", "compactorBlockUploadValidationEnabled", "compactorBlockUploadVerifyChunks", "compactorBlockUploadMaxBlockSizeBytes", "s3SSEType", "s3SSEKMSKeyID", "s3SSEKMSEncryptionContext", "alertmanagerReceiversBlockCIDRNetworks", "alertmanagerReceiversBlockPrivateAddresses", "notificationRateLimit", "notificationRateLimitPerIntegration", "alertmanagerMaxConfigSizeBytes", "alertmanagerMaxTemplatesCount", "alertmanagerMaxTemplateSizeBytes", "alertmanagerMaxDispatcherAggregationGroups", "alertmanagerMaxAlertsCount", "alertmanagerMaxAlertsSizeBytes"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "requestRate":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requestRate"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.RequestRate = data
		case "requestBurstSize":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requestBurstSize"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.RequestBurstSize = data
		case "ingestionRate":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ingestionRate"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.IngestionRate = data
		case "ingestionBurstSize":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ingestionBurstSize"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IngestionBurstSize = data
		case "acceptHASamples":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("acceptHASamples"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AcceptHASamples = data
		case "haClusterLabel":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("haClusterLabel"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.HAClusterLabel = data
		case "haReplicaLabel":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("haReplicaLabel"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.HAReplicaLabel = data
		case "haMaxClusters":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("haMaxClusters"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.HAMaxClusters = data
		case "dropLabels":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dropLabels"))
			data, err := ec.unmarshalOString2ᚕᚖstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.DropLabels = data
		case "maxLabelNameLength":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxLabelNameLength"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxLabelNameLength = data
		case "maxLabelValueLength":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxLabelValueLength"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxLabelValueLength = data
		case "maxLabelNamesPerSeries":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxLabelNamesPerSeries"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxLabelNamesPerSeries = data
		case "maxMetadataLength":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxMetadataLength"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxMetadataLength = data
		case "maxNativeHistogramBuckets":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxNativeHistogramBuckets"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxNativeHistogramBuckets = data
		case "creationGracePeriod":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("creationGracePeriod"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreationGracePeriod = data
		case "enforceMetadataMetricName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("enforceMetadataMetricName"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.EnforceMetadataMetricName = data
		case "ingestionTenantShardSize":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ingestionTenantShardSize"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IngestionTenantShardSize = data
		case "metricRelabelConfigs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricRelabelConfigs"))
			data, err := ec.unmarshalORelabelConfigInput2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐRelabelConfigInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.MimirLimitsInput().MetricRelabelConfigs(ctx, &it, data); err != nil {
				return it, err
			}
		case "maxGlobalSeriesPerUser":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxGlobalSeriesPerUser"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxGlobalSeriesPerUser = data
		case "maxGlobalSeriesPerMetric":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxGlobalSeriesPerMetric"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxGlobalSeriesPerMetric = data
		case "maxGlobalMetricsWithMetadataPerUser":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxGlobalMetricsWithMetadataPerUser"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxGlobalMetricsWithMetadataPerUser = data
		case "maxGlobalMetadataPerMetric":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxGlobalMetadataPerMetric"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxGlobalMetadataPerMetric = data
		case "maxGlobalExemplarsPerUser":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxGlobalExemplarsPerUser"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxGlobalExemplarsPerUser = data
		case "nativeHistogramsIngestionEnabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nativeHistogramsIngestionEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.NativeHistogramsIngestionEnabled = data
		case "activeSeriesCustomTrackersConfig":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("activeSeriesCustomTrackersConfig"))
			data, err := ec.unmarshalOStringMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.ActiveSeriesCustomTrackersConfig = data
		case "outOfOrderTimeWindow":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("outOfOrderTimeWindow"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.OutOfOrderTimeWindow = data
		case "outOfOrderBlocksExternalLabelEnabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("outOfOrderBlocksExternalLabelEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.OutOfOrderBlocksExternalLabelEnabled = data
		case "separateMetricsGroupLabel":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("separateMetricsGroupLabel"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SeparateMetricsGroupLabel = data
		case "maxChunksPerQuery":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxChunksPerQuery"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxChunksPerQuery = data
		case "maxFetchedSeriesPerQuery":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxFetchedSeriesPerQuery"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxFetchedSeriesPerQuery = data
		case "maxFetchedChunkBytesPerQuery":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxFetchedChunkBytesPerQuery"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxFetchedChunkBytesPerQuery = data
		case "maxQueryLookback":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxQueryLookback"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxQueryLookback = data
		case "maxPartialQueryLength":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxPartialQueryLength"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxPartialQueryLength = data
		case "maxQueryParallelism":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxQueryParallelism"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxQueryParallelism = data
		case "maxLabelsQueryLength":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxLabelsQueryLength"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxLabelsQueryLength = data
		case "maxCacheFreshness":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxCacheFreshness"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxCacheFreshness = data
		case "maxQueriersPerTenant":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxQueriersPerTenant"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxQueriersPerTenant = data
		case "queryShardingTotalShards":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("queryShardingTotalShards"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.QueryShardingTotalShards = data
		case "queryShardingMaxShardedQueries":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("queryShardingMaxShardedQueries"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.QueryShardingMaxShardedQueries = data
		case "queryShardingMaxRegexpSizeBytes":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("queryShardingMaxRegexpSizeBytes"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.QueryShardingMaxRegexpSizeBytes = data
		case "splitInstantQueriesByInterval":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("splitInstantQueriesByInterval"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.SplitInstantQueriesByInterval = data
		case "QueryIngestersWithin":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("QueryIngestersWithin"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.QueryIngestersWithin = data
		case "maxTotalQueryLength":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxTotalQueryLength"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxTotalQueryLength = data
		case "resultsCacheTTL":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resultsCacheTTL"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.ResultsCacheTTL = data
		case "resultsCacheTTLForOutOfOrderTimeWindow":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resultsCacheTTLForOutOfOrderTimeWindow"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.ResultsCacheTTLForOutOfOrderTimeWindow = data
		case "resultsCacheTTLForCardinalityQuery":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resultsCacheTTLForCardinalityQuery"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.ResultsCacheTTLForCardinalityQuery = data
		case "resultsCacheTTLForLabelsQuery":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resultsCacheTTLForLabelsQuery"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.ResultsCacheTTLForLabelsQuery = data
		case "resultsCacheForUnalignedQueryEnabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resultsCacheForUnalignedQueryEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ResultsCacheForUnalignedQueryEnabled = data
		case "maxQueryExpressionSizeBytes":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxQueryExpressionSizeBytes"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxQueryExpressionSizeBytes = data
		case "cardinalityAnalysisEnabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardinalityAnalysisEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardinalityAnalysisEnabled = data
		case "labelNamesAndValuesResultsMaxSizeBytes":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labelNamesAndValuesResultsMaxSizeBytes"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.LabelNamesAndValuesResultsMaxSizeBytes = data
		case "labelValuesMaxCardinalityLabelNamesPerRequest":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labelValuesMaxCardinalityLabelNamesPerRequest"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.LabelValuesMaxCardinalityLabelNamesPerRequest = data
		case "rulerEvaluationDelay":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rulerEvaluationDelay"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.RulerEvaluationDelay = data
		case "rulerTenantShardSize":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rulerTenantShardSize"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.RulerTenantShardSize = data
		case "rulerMaxRulesPerRuleGroup":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rulerMaxRulesPerRuleGroup"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.RulerMaxRulesPerRuleGroup = data
		case "rulerMaxRuleGroupsPerTenant":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rulerMaxRuleGroupsPerTenant"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.RulerMaxRuleGroupsPerTenant = data
		case "rulerRecordingRulesEvaluationEnabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rulerRecordingRulesEvaluationEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.RulerRecordingRulesEvaluationEnabled = data
		case "rulerAlertingRulesEvaluationEnabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rulerAlertingRulesEvaluationEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.RulerAlertingRulesEvaluationEnabled = data
		case "rulerSyncRulesOnChangesEnabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rulerSyncRulesOnChangesEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.RulerSyncRulesOnChangesEnabled = data
		case "storeGatewayTenantShardSize":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("storeGatewayTenantShardSize"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.StoreGatewayTenantShardSize = data
		case "compactorBlocksRetentionPeriod":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("compactorBlocksRetentionPeriod"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.CompactorBlocksRetentionPeriod = data
		case "compactorSplitAndMergeShards":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("compactorSplitAndMergeShards"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.CompactorSplitAndMergeShards = data
		case "compactorSplitGroups":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("compactorSplitGroups"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.CompactorSplitGroups = data
		case "compactorTenantShardSize":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("compactorTenantShardSize"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.CompactorTenantShardSize = data
		case "compactorPartialBlockDeletionDelay":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("compactorPartialBlockDeletionDelay"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.CompactorPartialBlockDeletionDelay = data
		case "compactorBlockUploadEnabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("compactorBlockUploadEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CompactorBlockUploadEnabled = data
		case "compactorBlockUploadValidationEnabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("compactorBlockUploadValidationEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CompactorBlockUploadValidationEnabled = data
		case "compactorBlockUploadVerifyChunks":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("compactorBlockUploadVerifyChunks"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CompactorBlockUploadVerifyChunks = data
		case "compactorBlockUploadMaxBlockSizeBytes":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("compactorBlockUploadMaxBlockSizeBytes"))
			data, err := ec.unmarshalOInt2ᚖint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CompactorBlockUploadMaxBlockSizeBytes = data
		case "s3SSEType":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("s3SSEType"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.S3SSEType = data
		case "s3SSEKMSKeyID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("s3SSEKMSKeyID"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.S3SSEKMSKeyID = data
		case "s3SSEKMSEncryptionContext":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("s3SSEKMSEncryptionContext"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.S3SSEKMSEncryptionContext = data
		case "alertmanagerReceiversBlockCIDRNetworks":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alertmanagerReceiversBlockCIDRNetworks"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.AlertmanagerReceiversBlockCIDRNetworks = data
		case "alertmanagerReceiversBlockPrivateAddresses":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alertmanagerReceiversBlockPrivateAddresses"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AlertmanagerReceiversBlockPrivateAddresses = data
		case "notificationRateLimit":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("notificationRateLimit"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.NotificationRateLimit = data
		case "notificationRateLimitPerIntegration":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("notificationRateLimitPerIntegration"))
			data, err := ec.unmarshalOFloatMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.NotificationRateLimitPerIntegration = data
		case "alertmanagerMaxConfigSizeBytes":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alertmanagerMaxConfigSizeBytes"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.AlertmanagerMaxConfigSizeBytes = data
		case "alertmanagerMaxTemplatesCount":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alertmanagerMaxTemplatesCount"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.AlertmanagerMaxTemplatesCount = data
		case "alertmanagerMaxTemplateSizeBytes":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alertmanagerMaxTemplateSizeBytes"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.AlertmanagerMaxTemplateSizeBytes = data
		case "alertmanagerMaxDispatcherAggregationGroups":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alertmanagerMaxDispatcherAggregationGroups"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.AlertmanagerMaxDispatcherAggregationGroups = data
		case "alertmanagerMaxAlertsCount":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alertmanagerMaxAlertsCount"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.AlertmanagerMaxAlertsCount = data
		case "alertmanagerMaxAlertsSizeBytes":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alertmanagerMaxAlertsSizeBytes"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.AlertmanagerMaxAlertsSizeBytes = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNameInput(ctx context.Context, obj interface{}) (model.NameInput, error) {
	var it model.NameInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"first", "last"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "first":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.First = data
		case "last":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Last = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNotifierBasicAuthInput(ctx context.Context, obj interface{}) (model.NotifierBasicAuthInput, error) {
	var it model.NotifierBasicAuthInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"username", "password"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "username":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Username = data
		case "password":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Password = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNotifierConfigInput(ctx context.Context, obj interface{}) (model.NotifierConfigInput, error) {
	var it model.NotifierConfigInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"basicAuth", "headerAuth", "tls"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "basicAuth":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("basicAuth"))
			data, err := ec.unmarshalONotifierBasicAuthInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐNotifierBasicAuthInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.BasicAuth = data
		case "headerAuth":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("headerAuth"))
			data, err := ec.unmarshalONotifierHeaderAuthInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐNotifierHeaderAuthInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HeaderAuth = data
		case "tls":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tls"))
			data, err := ec.unmarshalONotifierTLSClientConfigInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐNotifierTLSClientConfigInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.TLS = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNotifierHeaderAuthInput(ctx context.Context, obj interface{}) (model.NotifierHeaderAuthInput, error) {
	var it model.NotifierHeaderAuthInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"type", "credentials", "credentialsFile"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "credentials":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("credentials"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Credentials = data
		case "credentialsFile":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("credentialsFile"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CredentialsFile = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNotifierTLSClientConfigInput(ctx context.Context, obj interface{}) (model.NotifierTLSClientConfigInput, error) {
	var it model.NotifierTLSClientConfigInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"certPath", "keyPath", "caPath", "serverName", "insecureSkipVerify", "cipherSuites", "minVersion"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "certPath":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("certPath"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CertPath = data
		case "keyPath":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyPath"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.KeyPath = data
		case "caPath":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("caPath"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CaPath = data
		case "serverName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("serverName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ServerName = data
		case "insecureSkipVerify":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("insecureSkipVerify"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.InsecureSkipVerify = data
		case "cipherSuites":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cipherSuites"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CipherSuites = data
		case "minVersion":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minVersion"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.MinVersion = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOAuth2ClientInput(ctx context.Context, obj interface{}) (model.OAuth2ClientInput, error) {
	var it model.OAuth2ClientInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"clientId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "clientId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputObservabilityTenantLimitsInput(ctx context.Context, obj interface{}) (model.ObservabilityTenantLimitsInput, error) {
	var it model.ObservabilityTenantLimitsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"mimir", "loki", "tempo"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "mimir":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mimir"))
			data, err := ec.unmarshalOMimirLimitsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐMimirLimitsInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Mimir = data
		case "loki":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("loki"))
			data, err := ec.unmarshalOLokiLimitsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐLokiLimitsInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Loki = data
		case "tempo":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tempo"))
			data, err := ec.unmarshalOTempoLimitsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐTempoLimitsInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tempo = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputObservabilityTenantPermissionBindingsInput(ctx context.Context, obj interface{}) (model.ObservabilityTenantPermissionBindingsInput, error) {
	var it model.ObservabilityTenantPermissionBindingsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"users", "groups", "oauth2Clients"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "users":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("users"))
			data, err := ec.unmarshalOUserInput2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐUserInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Users = data
		case "groups":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("groups"))
			data, err := ec.unmarshalOGroupInput2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐGroupInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Groups = data
		case "oauth2Clients":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("oauth2Clients"))
			data, err := ec.unmarshalOOAuth2ClientInput2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2ClientInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Oauth2Clients = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPolicyMatchInput(ctx context.Context, obj interface{}) (model.PolicyMatchInput, error) {
	var it model.PolicyMatchInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"matchType", "attributes"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "matchType":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchType"))
			data, err := ec.unmarshalOMatchType2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐMatchType(ctx, v)
			if err != nil {
				return it, err
			}
			it.MatchType = data
		case "attributes":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("attributes"))
			data, err := ec.unmarshalOMatchPolicyAttributeInput2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐMatchPolicyAttributeInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Attributes = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRelabelConfigInput(ctx context.Context, obj interface{}) (model.RelabelConfigInput, error) {
	var it model.RelabelConfigInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"sourceLabels", "separator", "regex", "modulus", "targetLabel", "replacement", "action"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "sourceLabels":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceLabels"))
			data, err := ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceLabels = data
		case "separator":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("separator"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Separator = data
		case "regex":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("regex"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Regex = data
		case "modulus":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modulus"))
			data, err := ec.unmarshalOUInt2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Modulus = data
		case "targetLabel":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetLabel"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.TargetLabel = data
		case "replacement":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("replacement"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Replacement = data
		case "action":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("action"))
			data, err := ec.unmarshalORelabelAction2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐRelabelAction(ctx, v)
			if err != nil {
				return it, err
			}
			it.Action = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRulerAlertManagerConfigInput(ctx context.Context, obj interface{}) (model.RulerAlertManagerConfigInput, error) {
	var it model.RulerAlertManagerConfigInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"alertmanagerURL", "alertmanagerDiscovery", "alertmanagerRefreshInterval", "alertmanangerEnableV2API", "alertRelabelConfigs", "notificationQueueCapacity", "notificationTimeout", "notifier"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "alertmanagerURL":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alertmanagerURL"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AlertmanagerURL = data
		case "alertmanagerDiscovery":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alertmanagerDiscovery"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AlertmanagerDiscovery = data
		case "alertmanagerRefreshInterval":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alertmanagerRefreshInterval"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.AlertmanagerRefreshInterval = data
		case "alertmanangerEnableV2API":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alertmanangerEnableV2API"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AlertmanangerEnableV2api = data
		case "alertRelabelConfigs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alertRelabelConfigs"))
			data, err := ec.unmarshalORelabelConfigInput2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐRelabelConfigInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.AlertRelabelConfigs = data
		case "notificationQueueCapacity":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("notificationQueueCapacity"))
			data, err := ec.unmarshalOInt2ᚖint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.NotificationQueueCapacity = data
		case "notificationTimeout":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("notificationTimeout"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.NotificationTimeout = data
		case "notifier":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("notifier"))
			data, err := ec.unmarshalONotifierConfigInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐNotifierConfigInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Notifier = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputShardstreamsConfigInput(ctx context.Context, obj interface{}) (model.ShardstreamsConfigInput, error) {
	var it model.ShardstreamsConfigInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"enabled", "loggingEnabled", "desiredRate"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "enabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("enabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Enabled = data
		case "loggingEnabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("loggingEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.LoggingEnabled = data
		case "desiredRate":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("desiredRate"))
			data, err := ec.unmarshalOUInt2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.DesiredRate = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputStreamRetentionInput(ctx context.Context, obj interface{}) (model.StreamRetentionInput, error) {
	var it model.StreamRetentionInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"period", "priority", "selector"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "period":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("period"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.Period = data
		case "priority":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("priority"))
			data, err := ec.unmarshalOInt2ᚖint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Priority = data
		case "selector":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("selector"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Selector = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTempoLimitsInput(ctx context.Context, obj interface{}) (v1alpha1.TempoLimitsInput, error) {
	var it v1alpha1.TempoLimitsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ingestionRateStrategy", "ingestionRateLimitBytes", "ingestionBurstSizeBytes", "maxLocalTracesPerUser", "maxGlobalTracesPerUser", "forwarders", "metricsGeneratorRingSize", "metricsGeneratorProcessors", "metricsGeneratorMaxActiveSeries", "metricsGeneratorCollectionInterval", "metricsGeneratorDisableCollection", "metricsGeneratorForwarderQueueSize", "metricsGeneratorForwarderWorkers", "metricsGeneratorProcessorServiceGraphsHistogramBuckets", "metricsGeneratorProcessorServiceGraphsDimensions", "metricsGeneratorProcessorServiceGraphsPeerAttributes", "metricsGeneratorProcessorServiceGraphsEnableClientServerPrefix", "metricsGeneratorProcessorSpanMetricsHistogramBuckets", "metricsGeneratorProcessorSpanMetricsDimensions", "metricsGeneratorProcessorSpanMetricsIntrinsicDimensions", "metricsGeneratorProcessorSpanMetricsFilterPolicies", "metricsGeneratorProcessorSpanMetricsDimensionMappings", "metricsGeneratorProcessorSpanMetricsEnableTargetInfo", "metricsGeneratorProcessorLocalBlocksMaxLiveTraces", "metricsGeneratorProcessorLocalBlocksMaxBlockDuration", "metricsGeneratorProcessorLocalBlocksMaxBlockBytes", "metricsGeneratorProcessorLocalBlocksFlushCheckPeriod", "metricsGeneratorProcessorLocalBlocksTraceIdlePeriod", "metricsGeneratorProcessorLocalBlocksCompleteBlockTimeout", "blockRetention", "maxBytesPerTagValuesQuery", "maxBlocksPerTagValuesQuery", "maxSearchDuration", "maxBytesPerTrace"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ingestionRateStrategy":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ingestionRateStrategy"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IngestionRateStrategy = data
		case "ingestionRateLimitBytes":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ingestionRateLimitBytes"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IngestionRateLimitBytes = data
		case "ingestionBurstSizeBytes":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ingestionBurstSizeBytes"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IngestionBurstSizeBytes = data
		case "maxLocalTracesPerUser":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxLocalTracesPerUser"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxLocalTracesPerUser = data
		case "maxGlobalTracesPerUser":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxGlobalTracesPerUser"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxGlobalTracesPerUser = data
		case "forwarders":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("forwarders"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Forwarders = data
		case "metricsGeneratorRingSize":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsGeneratorRingSize"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MetricsGeneratorRingSize = data
		case "metricsGeneratorProcessors":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsGeneratorProcessors"))
			data, err := ec.unmarshalOString2ᚕᚖstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.MetricsGeneratorProcessors = data
		case "metricsGeneratorMaxActiveSeries":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsGeneratorMaxActiveSeries"))
			data, err := ec.unmarshalOUInt2ᚖuint32(ctx, v)
			if err != nil {
				return it, err
			}
			it.MetricsGeneratorMaxActiveSeries = data
		case "metricsGeneratorCollectionInterval":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsGeneratorCollectionInterval"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.MetricsGeneratorCollectionInterval = data
		case "metricsGeneratorDisableCollection":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsGeneratorDisableCollection"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.MetricsGeneratorDisableCollection = data
		case "metricsGeneratorForwarderQueueSize":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsGeneratorForwarderQueueSize"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MetricsGeneratorForwarderQueueSize = data
		case "metricsGeneratorForwarderWorkers":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsGeneratorForwarderWorkers"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MetricsGeneratorForwarderWorkers = data
		case "metricsGeneratorProcessorServiceGraphsHistogramBuckets":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsGeneratorProcessorServiceGraphsHistogramBuckets"))
			data, err := ec.unmarshalOFloat2ᚕfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.MetricsGeneratorProcessorServiceGraphsHistogramBuckets = data
		case "metricsGeneratorProcessorServiceGraphsDimensions":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsGeneratorProcessorServiceGraphsDimensions"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.MetricsGeneratorProcessorServiceGraphsDimensions = data
		case "metricsGeneratorProcessorServiceGraphsPeerAttributes":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsGeneratorProcessorServiceGraphsPeerAttributes"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.MetricsGeneratorProcessorServiceGraphsPeerAttributes = data
		case "metricsGeneratorProcessorServiceGraphsEnableClientServerPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsGeneratorProcessorServiceGraphsEnableClientServerPrefix"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.MetricsGeneratorProcessorServiceGraphsEnableClientServerPrefix = data
		case "metricsGeneratorProcessorSpanMetricsHistogramBuckets":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsGeneratorProcessorSpanMetricsHistogramBuckets"))
			data, err := ec.unmarshalOFloat2ᚕfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.MetricsGeneratorProcessorSpanMetricsHistogramBuckets = data
		case "metricsGeneratorProcessorSpanMetricsDimensions":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsGeneratorProcessorSpanMetricsDimensions"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.MetricsGeneratorProcessorSpanMetricsDimensions = data
		case "metricsGeneratorProcessorSpanMetricsIntrinsicDimensions":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsGeneratorProcessorSpanMetricsIntrinsicDimensions"))
			data, err := ec.unmarshalOBoolMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.MetricsGeneratorProcessorSpanMetricsIntrinsicDimensions = data
		case "metricsGeneratorProcessorSpanMetricsFilterPolicies":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsGeneratorProcessorSpanMetricsFilterPolicies"))
			data, err := ec.unmarshalOFilterPolicyInput2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐFilterPolicyInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.TempoLimitsInput().MetricsGeneratorProcessorSpanMetricsFilterPolicies(ctx, &it, data); err != nil {
				return it, err
			}
		case "metricsGeneratorProcessorSpanMetricsDimensionMappings":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsGeneratorProcessorSpanMetricsDimensionMappings"))
			data, err := ec.unmarshalODimensionMappingsInput2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐDimensionMappingsInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.TempoLimitsInput().MetricsGeneratorProcessorSpanMetricsDimensionMappings(ctx, &it, data); err != nil {
				return it, err
			}
		case "metricsGeneratorProcessorSpanMetricsEnableTargetInfo":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsGeneratorProcessorSpanMetricsEnableTargetInfo"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.MetricsGeneratorProcessorSpanMetricsEnableTargetInfo = data
		case "metricsGeneratorProcessorLocalBlocksMaxLiveTraces":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsGeneratorProcessorLocalBlocksMaxLiveTraces"))
			data, err := ec.unmarshalOUInt2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.MetricsGeneratorProcessorLocalBlocksMaxLiveTraces = data
		case "metricsGeneratorProcessorLocalBlocksMaxBlockDuration":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsGeneratorProcessorLocalBlocksMaxBlockDuration"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.MetricsGeneratorProcessorLocalBlocksMaxBlockDuration = data
		case "metricsGeneratorProcessorLocalBlocksMaxBlockBytes":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsGeneratorProcessorLocalBlocksMaxBlockBytes"))
			data, err := ec.unmarshalOUInt2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.MetricsGeneratorProcessorLocalBlocksMaxBlockBytes = data
		case "metricsGeneratorProcessorLocalBlocksFlushCheckPeriod":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsGeneratorProcessorLocalBlocksFlushCheckPeriod"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.MetricsGeneratorProcessorLocalBlocksFlushCheckPeriod = data
		case "metricsGeneratorProcessorLocalBlocksTraceIdlePeriod":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsGeneratorProcessorLocalBlocksTraceIdlePeriod"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.MetricsGeneratorProcessorLocalBlocksTraceIdlePeriod = data
		case "metricsGeneratorProcessorLocalBlocksCompleteBlockTimeout":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricsGeneratorProcessorLocalBlocksCompleteBlockTimeout"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.MetricsGeneratorProcessorLocalBlocksCompleteBlockTimeout = data
		case "blockRetention":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockRetention"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.BlockRetention = data
		case "maxBytesPerTagValuesQuery":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxBytesPerTagValuesQuery"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxBytesPerTagValuesQuery = data
		case "maxBlocksPerTagValuesQuery":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxBlocksPerTagValuesQuery"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxBlocksPerTagValuesQuery = data
		case "maxSearchDuration":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxSearchDuration"))
			data, err := ec.unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxSearchDuration = data
		case "maxBytesPerTrace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxBytesPerTrace"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxBytesPerTrace = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserInput(ctx context.Context, obj interface{}) (model.UserInput, error) {
	var it model.UserInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "email"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "email":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Email = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var blockedQueryImplementors = []string{"BlockedQuery"}

func (ec *executionContext) _BlockedQuery(ctx context.Context, sel ast.SelectionSet, obj *v1alpha1.BlockedQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, blockedQueryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BlockedQuery")
		case "pattern":
			out.Values[i] = ec._BlockedQuery_pattern(ctx, field, obj)
		case "regex":
			out.Values[i] = ec._BlockedQuery_regex(ctx, field, obj)
		case "hash":
			out.Values[i] = ec._BlockedQuery_hash(ctx, field, obj)
		case "types":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BlockedQuery_types(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dimensionMappingsImplementors = []string{"DimensionMappings"}

func (ec *executionContext) _DimensionMappings(ctx context.Context, sel ast.SelectionSet, obj *v1alpha1.DimensionMappings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dimensionMappingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DimensionMappings")
		case "name":
			out.Values[i] = ec._DimensionMappings_name(ctx, field, obj)
		case "sourceLabel":
			out.Values[i] = ec._DimensionMappings_sourceLabel(ctx, field, obj)
		case "join":
			out.Values[i] = ec._DimensionMappings_join(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var filterPolicyImplementors = []string{"FilterPolicy"}

func (ec *executionContext) _FilterPolicy(ctx context.Context, sel ast.SelectionSet, obj *v1alpha1.FilterPolicy) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, filterPolicyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FilterPolicy")
		case "include":
			out.Values[i] = ec._FilterPolicy_include(ctx, field, obj)
		case "exclude":
			out.Values[i] = ec._FilterPolicy_exclude(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var groupImplementors = []string{"Group"}

func (ec *executionContext) _Group(ctx context.Context, sel ast.SelectionSet, obj *model.Group) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Group")
		case "name":
			out.Values[i] = ec._Group_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "members":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Group_members(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var loginBindingsImplementors = []string{"LoginBindings"}

func (ec *executionContext) _LoginBindings(ctx context.Context, sel ast.SelectionSet, obj *model.LoginBindings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, loginBindingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LoginBindings")
		case "users":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LoginBindings_users(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "groups":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LoginBindings_groups(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var lokiLimitsImplementors = []string{"LokiLimits"}

func (ec *executionContext) _LokiLimits(ctx context.Context, sel ast.SelectionSet, obj *v1alpha1.LokiLimits) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, lokiLimitsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LokiLimits")
		case "ingestionRateStrategy":
			out.Values[i] = ec._LokiLimits_ingestionRateStrategy(ctx, field, obj)
		case "ingestionRateMB":
			out.Values[i] = ec._LokiLimits_ingestionRateMB(ctx, field, obj)
		case "ingestionBurstSizeMB":
			out.Values[i] = ec._LokiLimits_ingestionBurstSizeMB(ctx, field, obj)
		case "maxLabelNameLength":
			out.Values[i] = ec._LokiLimits_maxLabelNameLength(ctx, field, obj)
		case "maxLabelValueLength":
			out.Values[i] = ec._LokiLimits_maxLabelValueLength(ctx, field, obj)
		case "maxLabelNamesPerSeries":
			out.Values[i] = ec._LokiLimits_maxLabelNamesPerSeries(ctx, field, obj)
		case "rejectOldSamples":
			out.Values[i] = ec._LokiLimits_rejectOldSamples(ctx, field, obj)
		case "rejectOldSamplesMaxAge":
			out.Values[i] = ec._LokiLimits_rejectOldSamplesMaxAge(ctx, field, obj)
		case "creationGracePeriod":
			out.Values[i] = ec._LokiLimits_creationGracePeriod(ctx, field, obj)
		case "enforceMetricName":
			out.Values[i] = ec._LokiLimits_enforceMetricName(ctx, field, obj)
		case "maxLineSize":
			out.Values[i] = ec._LokiLimits_maxLineSize(ctx, field, obj)
		case "maxLineSizeTruncate":
			out.Values[i] = ec._LokiLimits_maxLineSizeTruncate(ctx, field, obj)
		case "incrementDuplicateTimestamp":
			out.Values[i] = ec._LokiLimits_incrementDuplicateTimestamp(ctx, field, obj)
		case "maxLocalStreamsPerUser":
			out.Values[i] = ec._LokiLimits_maxLocalStreamsPerUser(ctx, field, obj)
		case "maxGlobalStreamsPerUser":
			out.Values[i] = ec._LokiLimits_maxGlobalStreamsPerUser(ctx, field, obj)
		case "unorderedWrites":
			out.Values[i] = ec._LokiLimits_unorderedWrites(ctx, field, obj)
		case "perStreamRateLimit":
			out.Values[i] = ec._LokiLimits_perStreamRateLimit(ctx, field, obj)
		case "perStreamRateLimitBurst":
			out.Values[i] = ec._LokiLimits_perStreamRateLimitBurst(ctx, field, obj)
		case "maxChunksPerQuery":
			out.Values[i] = ec._LokiLimits_maxChunksPerQuery(ctx, field, obj)
		case "maxQuerySeries":
			out.Values[i] = ec._LokiLimits_maxQuerySeries(ctx, field, obj)
		case "maxQueryLookback":
			out.Values[i] = ec._LokiLimits_maxQueryLookback(ctx, field, obj)
		case "maxQueryLength":
			out.Values[i] = ec._LokiLimits_maxQueryLength(ctx, field, obj)
		case "maxQueryRange":
			out.Values[i] = ec._LokiLimits_maxQueryRange(ctx, field, obj)
		case "maxQueryParallelism":
			out.Values[i] = ec._LokiLimits_maxQueryParallelism(ctx, field, obj)
		case "tsdbMaxQueryParallelism":
			out.Values[i] = ec._LokiLimits_tsdbMaxQueryParallelism(ctx, field, obj)
		case "tsdbMaxBytesPerShard":
			out.Values[i] = ec._LokiLimits_tsdbMaxBytesPerShard(ctx, field, obj)
		case "cardinalityLimit":
			out.Values[i] = ec._LokiLimits_cardinalityLimit(ctx, field, obj)
		case "maxStreamsMatchersPerQuery":
			out.Values[i] = ec._LokiLimits_maxStreamsMatchersPerQuery(ctx, field, obj)
		case "maxConcurrentTailRequests":
			out.Values[i] = ec._LokiLimits_maxConcurrentTailRequests(ctx, field, obj)
		case "maxEntriesLimitPerQuery":
			out.Values[i] = ec._LokiLimits_maxEntriesLimitPerQuery(ctx, field, obj)
		case "maxCacheFreshness":
			out.Values[i] = ec._LokiLimits_maxCacheFreshness(ctx, field, obj)
		case "maxStatsCacheFreshness":
			out.Values[i] = ec._LokiLimits_maxStatsCacheFreshness(ctx, field, obj)
		case "maxQueriersPerTenant":
			out.Values[i] = ec._LokiLimits_maxQueriersPerTenant(ctx, field, obj)
		case "queryReadyIndexNumDays":
			out.Values[i] = ec._LokiLimits_queryReadyIndexNumDays(ctx, field, obj)
		case "queryTimeout":
			out.Values[i] = ec._LokiLimits_queryTimeout(ctx, field, obj)
		case "querySplitDuration":
			out.Values[i] = ec._LokiLimits_querySplitDuration(ctx, field, obj)
		case "minShardingLookback":
			out.Values[i] = ec._LokiLimits_minShardingLookback(ctx, field, obj)
		case "maxQueryBytesRead":
			out.Values[i] = ec._LokiLimits_maxQueryBytesRead(ctx, field, obj)
		case "maxQuerierBytesRead":
			out.Values[i] = ec._LokiLimits_maxQuerierBytesRead(ctx, field, obj)
		case "volumeEnabled":
			out.Values[i] = ec._LokiLimits_volumeEnabled(ctx, field, obj)
		case "volumeMaxSeries":
			out.Values[i] = ec._LokiLimits_volumeMaxSeries(ctx, field, obj)
		case "rulerEvaluationDelay":
			out.Values[i] = ec._LokiLimits_rulerEvaluationDelay(ctx, field, obj)
		case "rulerMaxRulesPerRuleGroup":
			out.Values[i] = ec._LokiLimits_rulerMaxRulesPerRuleGroup(ctx, field, obj)
		case "rulerMaxRuleGroupsPerTenant":
			out.Values[i] = ec._LokiLimits_rulerMaxRuleGroupsPerTenant(ctx, field, obj)
		case "rulerAlertManagerConfig":
			out.Values[i] = ec._LokiLimits_rulerAlertManagerConfig(ctx, field, obj)
		case "rulerTenantShardSize":
			out.Values[i] = ec._LokiLimits_rulerTenantShardSize(ctx, field, obj)
		case "rulerRemoteWriteDisabled":
			out.Values[i] = ec._LokiLimits_rulerRemoteWriteDisabled(ctx, field, obj)
		case "rulerRemoteEvaluationTimeout":
			out.Values[i] = ec._LokiLimits_rulerRemoteEvaluationTimeout(ctx, field, obj)
		case "rulerRemoteEvaluationMaxResponseSize":
			out.Values[i] = ec._LokiLimits_rulerRemoteEvaluationMaxResponseSize(ctx, field, obj)
		case "deletionMode":
			out.Values[i] = ec._LokiLimits_deletionMode(ctx, field, obj)
		case "retentionPeriod":
			out.Values[i] = ec._LokiLimits_retentionPeriod(ctx, field, obj)
		case "streamRetention":
			out.Values[i] = ec._LokiLimits_streamRetention(ctx, field, obj)
		case "shardStreams":
			out.Values[i] = ec._LokiLimits_shardStreams(ctx, field, obj)
		case "blockedQueries":
			out.Values[i] = ec._LokiLimits_blockedQueries(ctx, field, obj)
		case "requiredLabels":
			out.Values[i] = ec._LokiLimits_requiredLabels(ctx, field, obj)
		case "requiredNumberLabels":
			out.Values[i] = ec._LokiLimits_requiredNumberLabels(ctx, field, obj)
		case "indexGatewayShardSize":
			out.Values[i] = ec._LokiLimits_indexGatewayShardSize(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var matchPolicyAttributeImplementors = []string{"MatchPolicyAttribute"}

func (ec *executionContext) _MatchPolicyAttribute(ctx context.Context, sel ast.SelectionSet, obj *v1alpha1.MatchPolicyAttribute) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, matchPolicyAttributeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MatchPolicyAttribute")
		case "key":
			out.Values[i] = ec._MatchPolicyAttribute_key(ctx, field, obj)
		case "value":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchPolicyAttribute_value(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mimirLimitsImplementors = []string{"MimirLimits"}

func (ec *executionContext) _MimirLimits(ctx context.Context, sel ast.SelectionSet, obj *v1alpha1.MimirLimits) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mimirLimitsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MimirLimits")
		case "requestRate":
			out.Values[i] = ec._MimirLimits_requestRate(ctx, field, obj)
		case "requestBurstSize":
			out.Values[i] = ec._MimirLimits_requestBurstSize(ctx, field, obj)
		case "ingestionRate":
			out.Values[i] = ec._MimirLimits_ingestionRate(ctx, field, obj)
		case "ingestionBurstSize":
			out.Values[i] = ec._MimirLimits_ingestionBurstSize(ctx, field, obj)
		case "acceptHASamples":
			out.Values[i] = ec._MimirLimits_acceptHASamples(ctx, field, obj)
		case "haClusterLabel":
			out.Values[i] = ec._MimirLimits_haClusterLabel(ctx, field, obj)
		case "haReplicaLabel":
			out.Values[i] = ec._MimirLimits_haReplicaLabel(ctx, field, obj)
		case "haMaxClusters":
			out.Values[i] = ec._MimirLimits_haMaxClusters(ctx, field, obj)
		case "dropLabels":
			out.Values[i] = ec._MimirLimits_dropLabels(ctx, field, obj)
		case "maxLabelNameLength":
			out.Values[i] = ec._MimirLimits_maxLabelNameLength(ctx, field, obj)
		case "maxLabelValueLength":
			out.Values[i] = ec._MimirLimits_maxLabelValueLength(ctx, field, obj)
		case "maxLabelNamesPerSeries":
			out.Values[i] = ec._MimirLimits_maxLabelNamesPerSeries(ctx, field, obj)
		case "maxMetadataLength":
			out.Values[i] = ec._MimirLimits_maxMetadataLength(ctx, field, obj)
		case "maxNativeHistogramBuckets":
			out.Values[i] = ec._MimirLimits_maxNativeHistogramBuckets(ctx, field, obj)
		case "creationGracePeriod":
			out.Values[i] = ec._MimirLimits_creationGracePeriod(ctx, field, obj)
		case "enforceMetadataMetricName":
			out.Values[i] = ec._MimirLimits_enforceMetadataMetricName(ctx, field, obj)
		case "ingestionTenantShardSize":
			out.Values[i] = ec._MimirLimits_ingestionTenantShardSize(ctx, field, obj)
		case "metricRelabelConfigs":
			out.Values[i] = ec._MimirLimits_metricRelabelConfigs(ctx, field, obj)
		case "maxGlobalSeriesPerUser":
			out.Values[i] = ec._MimirLimits_maxGlobalSeriesPerUser(ctx, field, obj)
		case "maxGlobalSeriesPerMetric":
			out.Values[i] = ec._MimirLimits_maxGlobalSeriesPerMetric(ctx, field, obj)
		case "maxGlobalMetricsWithMetadataPerUser":
			out.Values[i] = ec._MimirLimits_maxGlobalMetricsWithMetadataPerUser(ctx, field, obj)
		case "maxGlobalMetadataPerMetric":
			out.Values[i] = ec._MimirLimits_maxGlobalMetadataPerMetric(ctx, field, obj)
		case "maxGlobalExemplarsPerUser":
			out.Values[i] = ec._MimirLimits_maxGlobalExemplarsPerUser(ctx, field, obj)
		case "nativeHistogramsIngestionEnabled":
			out.Values[i] = ec._MimirLimits_nativeHistogramsIngestionEnabled(ctx, field, obj)
		case "activeSeriesCustomTrackersConfig":
			out.Values[i] = ec._MimirLimits_activeSeriesCustomTrackersConfig(ctx, field, obj)
		case "outOfOrderTimeWindow":
			out.Values[i] = ec._MimirLimits_outOfOrderTimeWindow(ctx, field, obj)
		case "outOfOrderBlocksExternalLabelEnabled":
			out.Values[i] = ec._MimirLimits_outOfOrderBlocksExternalLabelEnabled(ctx, field, obj)
		case "separateMetricsGroupLabel":
			out.Values[i] = ec._MimirLimits_separateMetricsGroupLabel(ctx, field, obj)
		case "maxChunksPerQuery":
			out.Values[i] = ec._MimirLimits_maxChunksPerQuery(ctx, field, obj)
		case "maxFetchedSeriesPerQuery":
			out.Values[i] = ec._MimirLimits_maxFetchedSeriesPerQuery(ctx, field, obj)
		case "maxFetchedChunkBytesPerQuery":
			out.Values[i] = ec._MimirLimits_maxFetchedChunkBytesPerQuery(ctx, field, obj)
		case "maxQueryLookback":
			out.Values[i] = ec._MimirLimits_maxQueryLookback(ctx, field, obj)
		case "maxPartialQueryLength":
			out.Values[i] = ec._MimirLimits_maxPartialQueryLength(ctx, field, obj)
		case "maxQueryParallelism":
			out.Values[i] = ec._MimirLimits_maxQueryParallelism(ctx, field, obj)
		case "maxLabelsQueryLength":
			out.Values[i] = ec._MimirLimits_maxLabelsQueryLength(ctx, field, obj)
		case "maxCacheFreshness":
			out.Values[i] = ec._MimirLimits_maxCacheFreshness(ctx, field, obj)
		case "maxQueriersPerTenant":
			out.Values[i] = ec._MimirLimits_maxQueriersPerTenant(ctx, field, obj)
		case "queryShardingTotalShards":
			out.Values[i] = ec._MimirLimits_queryShardingTotalShards(ctx, field, obj)
		case "queryShardingMaxShardedQueries":
			out.Values[i] = ec._MimirLimits_queryShardingMaxShardedQueries(ctx, field, obj)
		case "queryShardingMaxRegexpSizeBytes":
			out.Values[i] = ec._MimirLimits_queryShardingMaxRegexpSizeBytes(ctx, field, obj)
		case "splitInstantQueriesByInterval":
			out.Values[i] = ec._MimirLimits_splitInstantQueriesByInterval(ctx, field, obj)
		case "QueryIngestersWithin":
			out.Values[i] = ec._MimirLimits_QueryIngestersWithin(ctx, field, obj)
		case "maxTotalQueryLength":
			out.Values[i] = ec._MimirLimits_maxTotalQueryLength(ctx, field, obj)
		case "resultsCacheTTL":
			out.Values[i] = ec._MimirLimits_resultsCacheTTL(ctx, field, obj)
		case "resultsCacheTTLForOutOfOrderTimeWindow":
			out.Values[i] = ec._MimirLimits_resultsCacheTTLForOutOfOrderTimeWindow(ctx, field, obj)
		case "resultsCacheTTLForCardinalityQuery":
			out.Values[i] = ec._MimirLimits_resultsCacheTTLForCardinalityQuery(ctx, field, obj)
		case "resultsCacheTTLForLabelsQuery":
			out.Values[i] = ec._MimirLimits_resultsCacheTTLForLabelsQuery(ctx, field, obj)
		case "resultsCacheForUnalignedQueryEnabled":
			out.Values[i] = ec._MimirLimits_resultsCacheForUnalignedQueryEnabled(ctx, field, obj)
		case "maxQueryExpressionSizeBytes":
			out.Values[i] = ec._MimirLimits_maxQueryExpressionSizeBytes(ctx, field, obj)
		case "cardinalityAnalysisEnabled":
			out.Values[i] = ec._MimirLimits_cardinalityAnalysisEnabled(ctx, field, obj)
		case "labelNamesAndValuesResultsMaxSizeBytes":
			out.Values[i] = ec._MimirLimits_labelNamesAndValuesResultsMaxSizeBytes(ctx, field, obj)
		case "labelValuesMaxCardinalityLabelNamesPerRequest":
			out.Values[i] = ec._MimirLimits_labelValuesMaxCardinalityLabelNamesPerRequest(ctx, field, obj)
		case "rulerEvaluationDelay":
			out.Values[i] = ec._MimirLimits_rulerEvaluationDelay(ctx, field, obj)
		case "rulerTenantShardSize":
			out.Values[i] = ec._MimirLimits_rulerTenantShardSize(ctx, field, obj)
		case "rulerMaxRulesPerRuleGroup":
			out.Values[i] = ec._MimirLimits_rulerMaxRulesPerRuleGroup(ctx, field, obj)
		case "rulerMaxRuleGroupsPerTenant":
			out.Values[i] = ec._MimirLimits_rulerMaxRuleGroupsPerTenant(ctx, field, obj)
		case "rulerRecordingRulesEvaluationEnabled":
			out.Values[i] = ec._MimirLimits_rulerRecordingRulesEvaluationEnabled(ctx, field, obj)
		case "rulerAlertingRulesEvaluationEnabled":
			out.Values[i] = ec._MimirLimits_rulerAlertingRulesEvaluationEnabled(ctx, field, obj)
		case "rulerSyncRulesOnChangesEnabled":
			out.Values[i] = ec._MimirLimits_rulerSyncRulesOnChangesEnabled(ctx, field, obj)
		case "storeGatewayTenantShardSize":
			out.Values[i] = ec._MimirLimits_storeGatewayTenantShardSize(ctx, field, obj)
		case "compactorBlocksRetentionPeriod":
			out.Values[i] = ec._MimirLimits_compactorBlocksRetentionPeriod(ctx, field, obj)
		case "compactorSplitAndMergeShards":
			out.Values[i] = ec._MimirLimits_compactorSplitAndMergeShards(ctx, field, obj)
		case "compactorSplitGroups":
			out.Values[i] = ec._MimirLimits_compactorSplitGroups(ctx, field, obj)
		case "compactorTenantShardSize":
			out.Values[i] = ec._MimirLimits_compactorTenantShardSize(ctx, field, obj)
		case "compactorPartialBlockDeletionDelay":
			out.Values[i] = ec._MimirLimits_compactorPartialBlockDeletionDelay(ctx, field, obj)
		case "compactorBlockUploadEnabled":
			out.Values[i] = ec._MimirLimits_compactorBlockUploadEnabled(ctx, field, obj)
		case "compactorBlockUploadValidationEnabled":
			out.Values[i] = ec._MimirLimits_compactorBlockUploadValidationEnabled(ctx, field, obj)
		case "compactorBlockUploadVerifyChunks":
			out.Values[i] = ec._MimirLimits_compactorBlockUploadVerifyChunks(ctx, field, obj)
		case "compactorBlockUploadMaxBlockSizeBytes":
			out.Values[i] = ec._MimirLimits_compactorBlockUploadMaxBlockSizeBytes(ctx, field, obj)
		case "s3SSEType":
			out.Values[i] = ec._MimirLimits_s3SSEType(ctx, field, obj)
		case "s3SSEKMSKeyID":
			out.Values[i] = ec._MimirLimits_s3SSEKMSKeyID(ctx, field, obj)
		case "s3SSEKMSEncryptionContext":
			out.Values[i] = ec._MimirLimits_s3SSEKMSEncryptionContext(ctx, field, obj)
		case "alertmanagerReceiversBlockCIDRNetworks":
			out.Values[i] = ec._MimirLimits_alertmanagerReceiversBlockCIDRNetworks(ctx, field, obj)
		case "alertmanagerReceiversBlockPrivateAddresses":
			out.Values[i] = ec._MimirLimits_alertmanagerReceiversBlockPrivateAddresses(ctx, field, obj)
		case "notificationRateLimit":
			out.Values[i] = ec._MimirLimits_notificationRateLimit(ctx, field, obj)
		case "notificationRateLimitPerIntegration":
			out.Values[i] = ec._MimirLimits_notificationRateLimitPerIntegration(ctx, field, obj)
		case "alertmanagerMaxConfigSizeBytes":
			out.Values[i] = ec._MimirLimits_alertmanagerMaxConfigSizeBytes(ctx, field, obj)
		case "alertmanagerMaxTemplatesCount":
			out.Values[i] = ec._MimirLimits_alertmanagerMaxTemplatesCount(ctx, field, obj)
		case "alertmanagerMaxTemplateSizeBytes":
			out.Values[i] = ec._MimirLimits_alertmanagerMaxTemplateSizeBytes(ctx, field, obj)
		case "alertmanagerMaxDispatcherAggregationGroups":
			out.Values[i] = ec._MimirLimits_alertmanagerMaxDispatcherAggregationGroups(ctx, field, obj)
		case "alertmanagerMaxAlertsCount":
			out.Values[i] = ec._MimirLimits_alertmanagerMaxAlertsCount(ctx, field, obj)
		case "alertmanagerMaxAlertsSizeBytes":
			out.Values[i] = ec._MimirLimits_alertmanagerMaxAlertsSizeBytes(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createUser(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteUser(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "group":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_group(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteGroup":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteGroup(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createOAuth2Client":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createOAuth2Client(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateOAuth2Client":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateOAuth2Client(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteOAuth2Client":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteOAuth2Client(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "acceptOAuth2ConsentRequest":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_acceptOAuth2ConsentRequest(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rejectOAuth2ConsentRequest":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_rejectOAuth2ConsentRequest(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "acceptOAuth2LoginRequest":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_acceptOAuth2LoginRequest(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rejectOAuth2LoginRequest":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_rejectOAuth2LoginRequest(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createObservabilityTenant":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createObservabilityTenant(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateObservabilityTenant":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateObservabilityTenant(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteObservabilityTenant":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteObservabilityTenant(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "organization":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_organization(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var nameImplementors = []string{"Name"}

func (ec *executionContext) _Name(ctx context.Context, sel ast.SelectionSet, obj *model.Name) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, nameImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Name")
		case "first":
			out.Values[i] = ec._Name_first(ctx, field, obj)
		case "last":
			out.Values[i] = ec._Name_last(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var notifierBasicAuthImplementors = []string{"NotifierBasicAuth"}

func (ec *executionContext) _NotifierBasicAuth(ctx context.Context, sel ast.SelectionSet, obj *v1alpha1.NotifierBasicAuth) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, notifierBasicAuthImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NotifierBasicAuth")
		case "username":
			out.Values[i] = ec._NotifierBasicAuth_username(ctx, field, obj)
		case "password":
			out.Values[i] = ec._NotifierBasicAuth_password(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var notifierConfigImplementors = []string{"NotifierConfig"}

func (ec *executionContext) _NotifierConfig(ctx context.Context, sel ast.SelectionSet, obj *v1alpha1.NotifierConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, notifierConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NotifierConfig")
		case "basicAuth":
			out.Values[i] = ec._NotifierConfig_basicAuth(ctx, field, obj)
		case "headerAuth":
			out.Values[i] = ec._NotifierConfig_headerAuth(ctx, field, obj)
		case "tls":
			out.Values[i] = ec._NotifierConfig_tls(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var notifierHeaderAuthImplementors = []string{"NotifierHeaderAuth"}

func (ec *executionContext) _NotifierHeaderAuth(ctx context.Context, sel ast.SelectionSet, obj *v1alpha1.NotifierHeaderAuth) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, notifierHeaderAuthImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NotifierHeaderAuth")
		case "type":
			out.Values[i] = ec._NotifierHeaderAuth_type(ctx, field, obj)
		case "credentials":
			out.Values[i] = ec._NotifierHeaderAuth_credentials(ctx, field, obj)
		case "credentialsFile":
			out.Values[i] = ec._NotifierHeaderAuth_credentialsFile(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var notifierTLSClientConfigImplementors = []string{"NotifierTLSClientConfig"}

func (ec *executionContext) _NotifierTLSClientConfig(ctx context.Context, sel ast.SelectionSet, obj *v1alpha1.NotifierTLSClientConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, notifierTLSClientConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NotifierTLSClientConfig")
		case "certPath":
			out.Values[i] = ec._NotifierTLSClientConfig_certPath(ctx, field, obj)
		case "keyPath":
			out.Values[i] = ec._NotifierTLSClientConfig_keyPath(ctx, field, obj)
		case "caPath":
			out.Values[i] = ec._NotifierTLSClientConfig_caPath(ctx, field, obj)
		case "serverName":
			out.Values[i] = ec._NotifierTLSClientConfig_serverName(ctx, field, obj)
		case "insecureSkipVerify":
			out.Values[i] = ec._NotifierTLSClientConfig_insecureSkipVerify(ctx, field, obj)
		case "cipherSuites":
			out.Values[i] = ec._NotifierTLSClientConfig_cipherSuites(ctx, field, obj)
		case "minVersion":
			out.Values[i] = ec._NotifierTLSClientConfig_minVersion(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var oAuth2ClientImplementors = []string{"OAuth2Client"}

func (ec *executionContext) _OAuth2Client(ctx context.Context, sel ast.SelectionSet, obj *model.OAuth2Client) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oAuth2ClientImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OAuth2Client")
		case "allowedCorsOrigins":
			out.Values[i] = ec._OAuth2Client_allowedCorsOrigins(ctx, field, obj)
		case "audience":
			out.Values[i] = ec._OAuth2Client_audience(ctx, field, obj)
		case "authorizationCodeGrantAccessTokenLifespan":
			out.Values[i] = ec._OAuth2Client_authorizationCodeGrantAccessTokenLifespan(ctx, field, obj)
		case "authorizationCodeGrantIdTokenLifespan":
			out.Values[i] = ec._OAuth2Client_authorizationCodeGrantIdTokenLifespan(ctx, field, obj)
		case "authorizationCodeGrantRefreshTokenLifespan":
			out.Values[i] = ec._OAuth2Client_authorizationCodeGrantRefreshTokenLifespan(ctx, field, obj)
		case "backChannelLogoutSessionRequired":
			out.Values[i] = ec._OAuth2Client_backChannelLogoutSessionRequired(ctx, field, obj)
		case "backChannelLogoutUri":
			out.Values[i] = ec._OAuth2Client_backChannelLogoutUri(ctx, field, obj)
		case "clientCredentialsGrantAccessTokenLifespan":
			out.Values[i] = ec._OAuth2Client_clientCredentialsGrantAccessTokenLifespan(ctx, field, obj)
		case "clientId":
			out.Values[i] = ec._OAuth2Client_clientId(ctx, field, obj)
		case "clientName":
			out.Values[i] = ec._OAuth2Client_clientName(ctx, field, obj)
		case "clientSecret":
			out.Values[i] = ec._OAuth2Client_clientSecret(ctx, field, obj)
		case "ClientSecretExpiresAt":
			out.Values[i] = ec._OAuth2Client_ClientSecretExpiresAt(ctx, field, obj)
		case "clientUri":
			out.Values[i] = ec._OAuth2Client_clientUri(ctx, field, obj)
		case "contacts":
			out.Values[i] = ec._OAuth2Client_contacts(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._OAuth2Client_createdAt(ctx, field, obj)
		case "frontchannelLogoutSessionRequired":
			out.Values[i] = ec._OAuth2Client_frontchannelLogoutSessionRequired(ctx, field, obj)
		case "frontchannelLogoutUri":
			out.Values[i] = ec._OAuth2Client_frontchannelLogoutUri(ctx, field, obj)
		case "grantTypes":
			out.Values[i] = ec._OAuth2Client_grantTypes(ctx, field, obj)
		case "implicitGrantAccessTokenLifespan":
			out.Values[i] = ec._OAuth2Client_implicitGrantAccessTokenLifespan(ctx, field, obj)
		case "implicitGrantIdTokenLifespan":
			out.Values[i] = ec._OAuth2Client_implicitGrantIdTokenLifespan(ctx, field, obj)
		case "jwks":
			out.Values[i] = ec._OAuth2Client_jwks(ctx, field, obj)
		case "jwksUri":
			out.Values[i] = ec._OAuth2Client_jwksUri(ctx, field, obj)
		case "jwtBearerGrantAccessTokenLifespan":
			out.Values[i] = ec._OAuth2Client_jwtBearerGrantAccessTokenLifespan(ctx, field, obj)
		case "logoUri":
			out.Values[i] = ec._OAuth2Client_logoUri(ctx, field, obj)
		case "metadata":
			out.Values[i] = ec._OAuth2Client_metadata(ctx, field, obj)
		case "owner":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._OAuth2Client_owner(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "policyUri":
			out.Values[i] = ec._OAuth2Client_policyUri(ctx, field, obj)
		case "postLogoutRedirectUris":
			out.Values[i] = ec._OAuth2Client_postLogoutRedirectUris(ctx, field, obj)
		case "redirectUris":
			out.Values[i] = ec._OAuth2Client_redirectUris(ctx, field, obj)
		case "responseTypes":
			out.Values[i] = ec._OAuth2Client_responseTypes(ctx, field, obj)
		case "scope":
			out.Values[i] = ec._OAuth2Client_scope(ctx, field, obj)
		case "sectorIdentifierUri":
			out.Values[i] = ec._OAuth2Client_sectorIdentifierUri(ctx, field, obj)
		case "subjectType":
			out.Values[i] = ec._OAuth2Client_subjectType(ctx, field, obj)
		case "tokenEndpointAuthMethod":
			out.Values[i] = ec._OAuth2Client_tokenEndpointAuthMethod(ctx, field, obj)
		case "tokenEndpointAuthSigningAlgorithm":
			out.Values[i] = ec._OAuth2Client_tokenEndpointAuthSigningAlgorithm(ctx, field, obj)
		case "tosUri":
			out.Values[i] = ec._OAuth2Client_tosUri(ctx, field, obj)
		case "updatedAt":
			out.Values[i] = ec._OAuth2Client_updatedAt(ctx, field, obj)
		case "userinfoSignedResponseAlgorithm":
			out.Values[i] = ec._OAuth2Client_userinfoSignedResponseAlgorithm(ctx, field, obj)
		case "loginBindings":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._OAuth2Client_loginBindings(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var oAuth2ConsentRequestImplementors = []string{"OAuth2ConsentRequest"}

func (ec *executionContext) _OAuth2ConsentRequest(ctx context.Context, sel ast.SelectionSet, obj *model.OAuth2ConsentRequest) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oAuth2ConsentRequestImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OAuth2ConsentRequest")
		case "acr":
			out.Values[i] = ec._OAuth2ConsentRequest_acr(ctx, field, obj)
		case "amr":
			out.Values[i] = ec._OAuth2ConsentRequest_amr(ctx, field, obj)
		case "challenge":
			out.Values[i] = ec._OAuth2ConsentRequest_challenge(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "client":
			out.Values[i] = ec._OAuth2ConsentRequest_client(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "context":
			out.Values[i] = ec._OAuth2ConsentRequest_context(ctx, field, obj)
		case "loginChallenge":
			out.Values[i] = ec._OAuth2ConsentRequest_loginChallenge(ctx, field, obj)
		case "loginSessionId":
			out.Values[i] = ec._OAuth2ConsentRequest_loginSessionId(ctx, field, obj)
		case "oidcContext":
			out.Values[i] = ec._OAuth2ConsentRequest_oidcContext(ctx, field, obj)
		case "requestUrl":
			out.Values[i] = ec._OAuth2ConsentRequest_requestUrl(ctx, field, obj)
		case "requestedAccessTokenAudience":
			out.Values[i] = ec._OAuth2ConsentRequest_requestedAccessTokenAudience(ctx, field, obj)
		case "requestedScope":
			out.Values[i] = ec._OAuth2ConsentRequest_requestedScope(ctx, field, obj)
		case "skip":
			out.Values[i] = ec._OAuth2ConsentRequest_skip(ctx, field, obj)
		case "subject":
			out.Values[i] = ec._OAuth2ConsentRequest_subject(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "redirectTo":
			out.Values[i] = ec._OAuth2ConsentRequest_redirectTo(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var oAuth2LoginRequestImplementors = []string{"OAuth2LoginRequest"}

func (ec *executionContext) _OAuth2LoginRequest(ctx context.Context, sel ast.SelectionSet, obj *model.OAuth2LoginRequest) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oAuth2LoginRequestImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OAuth2LoginRequest")
		case "challenge":
			out.Values[i] = ec._OAuth2LoginRequest_challenge(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "client":
			out.Values[i] = ec._OAuth2LoginRequest_client(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "oidcContext":
			out.Values[i] = ec._OAuth2LoginRequest_oidcContext(ctx, field, obj)
		case "requestUrl":
			out.Values[i] = ec._OAuth2LoginRequest_requestUrl(ctx, field, obj)
		case "requestedAccessTokenAudience":
			out.Values[i] = ec._OAuth2LoginRequest_requestedAccessTokenAudience(ctx, field, obj)
		case "requestedScope":
			out.Values[i] = ec._OAuth2LoginRequest_requestedScope(ctx, field, obj)
		case "sessionId":
			out.Values[i] = ec._OAuth2LoginRequest_sessionId(ctx, field, obj)
		case "skip":
			out.Values[i] = ec._OAuth2LoginRequest_skip(ctx, field, obj)
		case "subject":
			out.Values[i] = ec._OAuth2LoginRequest_subject(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "redirectTo":
			out.Values[i] = ec._OAuth2LoginRequest_redirectTo(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var oAuth2RedirectToImplementors = []string{"OAuth2RedirectTo"}

func (ec *executionContext) _OAuth2RedirectTo(ctx context.Context, sel ast.SelectionSet, obj *model.OAuth2RedirectTo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oAuth2RedirectToImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OAuth2RedirectTo")
		case "redirectTo":
			out.Values[i] = ec._OAuth2RedirectTo_redirectTo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var observabilityTenantImplementors = []string{"ObservabilityTenant"}

func (ec *executionContext) _ObservabilityTenant(ctx context.Context, sel ast.SelectionSet, obj *model.ObservabilityTenant) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, observabilityTenantImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ObservabilityTenant")
		case "id":
			out.Values[i] = ec._ObservabilityTenant_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "displayName":
			out.Values[i] = ec._ObservabilityTenant_displayName(ctx, field, obj)
		case "admins":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenant_admins(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "metricsReaders":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenant_metricsReaders(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "metricsWriters":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenant_metricsWriters(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "metricsDeleters":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenant_metricsDeleters(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "metricsRulesReaders":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenant_metricsRulesReaders(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "metricsRulesWriters":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenant_metricsRulesWriters(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "metricsRulesDeleters":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenant_metricsRulesDeleters(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "metricsAlertsReaders":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenant_metricsAlertsReaders(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "metricsAlertsWriters":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenant_metricsAlertsWriters(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "logsReaders":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenant_logsReaders(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "logsWriters":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenant_logsWriters(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "logsDeleters":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenant_logsDeleters(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "logsRulesReaders":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenant_logsRulesReaders(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "logsRulesWriters":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenant_logsRulesWriters(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "logsRulesDeleters":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenant_logsRulesDeleters(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "tracesReaders":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenant_tracesReaders(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "tracesWriters":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenant_tracesWriters(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "limits":
			out.Values[i] = ec._ObservabilityTenant_limits(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var observabilityTenantLimitsImplementors = []string{"ObservabilityTenantLimits"}

func (ec *executionContext) _ObservabilityTenantLimits(ctx context.Context, sel ast.SelectionSet, obj *model.ObservabilityTenantLimits) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, observabilityTenantLimitsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ObservabilityTenantLimits")
		case "mimir":
			out.Values[i] = ec._ObservabilityTenantLimits_mimir(ctx, field, obj)
		case "loki":
			out.Values[i] = ec._ObservabilityTenantLimits_loki(ctx, field, obj)
		case "tempo":
			out.Values[i] = ec._ObservabilityTenantLimits_tempo(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var observabilityTenantPermissionBindingsImplementors = []string{"ObservabilityTenantPermissionBindings"}

func (ec *executionContext) _ObservabilityTenantPermissionBindings(ctx context.Context, sel ast.SelectionSet, obj *model.ObservabilityTenantPermissionBindings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, observabilityTenantPermissionBindingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ObservabilityTenantPermissionBindings")
		case "users":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenantPermissionBindings_users(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "groups":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenantPermissionBindings_groups(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "oauth2Clients":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenantPermissionBindings_oauth2Clients(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var oidcContextImplementors = []string{"OidcContext"}

func (ec *executionContext) _OidcContext(ctx context.Context, sel ast.SelectionSet, obj *model.OidcContext) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oidcContextImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OidcContext")
		case "acrValues":
			out.Values[i] = ec._OidcContext_acrValues(ctx, field, obj)
		case "display":
			out.Values[i] = ec._OidcContext_display(ctx, field, obj)
		case "idTokenHintClaims":
			out.Values[i] = ec._OidcContext_idTokenHintClaims(ctx, field, obj)
		case "loginHint":
			out.Values[i] = ec._OidcContext_loginHint(ctx, field, obj)
		case "uiLocales":
			out.Values[i] = ec._OidcContext_uiLocales(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var organizationImplementors = []string{"Organization"}

func (ec *executionContext) _Organization(ctx context.Context, sel ast.SelectionSet, obj *model.Organization) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, organizationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Organization")
		case "admins":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Organization_admins(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var policyMatchImplementors = []string{"PolicyMatch"}

func (ec *executionContext) _PolicyMatch(ctx context.Context, sel ast.SelectionSet, obj *v1alpha1.PolicyMatch) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, policyMatchImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PolicyMatch")
		case "matchType":
			out.Values[i] = ec._PolicyMatch_matchType(ctx, field, obj)
		case "attributes":
			out.Values[i] = ec._PolicyMatch_attributes(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "listUsers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listUsers(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getUser":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getUser(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "listGroups":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listGroups(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "listOAuth2Clients":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listOAuth2Clients(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getOAuth2Client":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getOAuth2Client(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "oauth2ConsentRequest":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_oauth2ConsentRequest(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "oauth2LoginRequest":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_oauth2LoginRequest(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "listObservabilityTenants":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listObservabilityTenants(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getObservabilityTenant":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getObservabilityTenant(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "organization":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_organization(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var relabelConfigImplementors = []string{"RelabelConfig"}

func (ec *executionContext) _RelabelConfig(ctx context.Context, sel ast.SelectionSet, obj *v1alpha1.RelabelConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, relabelConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RelabelConfig")
		case "sourceLabels":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RelabelConfig_sourceLabels(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "separator":
			out.Values[i] = ec._RelabelConfig_separator(ctx, field, obj)
		case "regex":
			out.Values[i] = ec._RelabelConfig_regex(ctx, field, obj)
		case "modulus":
			out.Values[i] = ec._RelabelConfig_modulus(ctx, field, obj)
		case "targetLabel":
			out.Values[i] = ec._RelabelConfig_targetLabel(ctx, field, obj)
		case "replacement":
			out.Values[i] = ec._RelabelConfig_replacement(ctx, field, obj)
		case "action":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RelabelConfig_action(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var rulerAlertManagerConfigImplementors = []string{"RulerAlertManagerConfig"}

func (ec *executionContext) _RulerAlertManagerConfig(ctx context.Context, sel ast.SelectionSet, obj *v1alpha1.RulerAlertManagerConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, rulerAlertManagerConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RulerAlertManagerConfig")
		case "alertmanagerURL":
			out.Values[i] = ec._RulerAlertManagerConfig_alertmanagerURL(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "alertmanagerDiscovery":
			out.Values[i] = ec._RulerAlertManagerConfig_alertmanagerDiscovery(ctx, field, obj)
		case "alertmanagerRefreshInterval":
			out.Values[i] = ec._RulerAlertManagerConfig_alertmanagerRefreshInterval(ctx, field, obj)
		case "alertmanangerEnableV2API":
			out.Values[i] = ec._RulerAlertManagerConfig_alertmanangerEnableV2API(ctx, field, obj)
		case "alertRelabelConfigs":
			out.Values[i] = ec._RulerAlertManagerConfig_alertRelabelConfigs(ctx, field, obj)
		case "notificationQueueCapacity":
			out.Values[i] = ec._RulerAlertManagerConfig_notificationQueueCapacity(ctx, field, obj)
		case "notificationTimeout":
			out.Values[i] = ec._RulerAlertManagerConfig_notificationTimeout(ctx, field, obj)
		case "notifier":
			out.Values[i] = ec._RulerAlertManagerConfig_notifier(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var shardstreamsConfigImplementors = []string{"ShardstreamsConfig"}

func (ec *executionContext) _ShardstreamsConfig(ctx context.Context, sel ast.SelectionSet, obj *v1alpha1.ShardstreamsConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, shardstreamsConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ShardstreamsConfig")
		case "enabled":
			out.Values[i] = ec._ShardstreamsConfig_enabled(ctx, field, obj)
		case "loggingEnabled":
			out.Values[i] = ec._ShardstreamsConfig_loggingEnabled(ctx, field, obj)
		case "desiredRate":
			out.Values[i] = ec._ShardstreamsConfig_desiredRate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var streamRetentionImplementors = []string{"StreamRetention"}

func (ec *executionContext) _StreamRetention(ctx context.Context, sel ast.SelectionSet, obj *v1alpha1.StreamRetention) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, streamRetentionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StreamRetention")
		case "period":
			out.Values[i] = ec._StreamRetention_period(ctx, field, obj)
		case "priority":
			out.Values[i] = ec._StreamRetention_priority(ctx, field, obj)
		case "selector":
			out.Values[i] = ec._StreamRetention_selector(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var tempoLimitsImplementors = []string{"TempoLimits"}

func (ec *executionContext) _TempoLimits(ctx context.Context, sel ast.SelectionSet, obj *v1alpha1.TempoLimits) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tempoLimitsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TempoLimits")
		case "ingestionRateStrategy":
			out.Values[i] = ec._TempoLimits_ingestionRateStrategy(ctx, field, obj)
		case "ingestionRateLimitBytes":
			out.Values[i] = ec._TempoLimits_ingestionRateLimitBytes(ctx, field, obj)
		case "ingestionBurstSizeBytes":
			out.Values[i] = ec._TempoLimits_ingestionBurstSizeBytes(ctx, field, obj)
		case "maxLocalTracesPerUser":
			out.Values[i] = ec._TempoLimits_maxLocalTracesPerUser(ctx, field, obj)
		case "maxGlobalTracesPerUser":
			out.Values[i] = ec._TempoLimits_maxGlobalTracesPerUser(ctx, field, obj)
		case "forwarders":
			out.Values[i] = ec._TempoLimits_forwarders(ctx, field, obj)
		case "metricsGeneratorRingSize":
			out.Values[i] = ec._TempoLimits_metricsGeneratorRingSize(ctx, field, obj)
		case "metricsGeneratorProcessors":
			out.Values[i] = ec._TempoLimits_metricsGeneratorProcessors(ctx, field, obj)
		case "metricsGeneratorMaxActiveSeries":
			out.Values[i] = ec._TempoLimits_metricsGeneratorMaxActiveSeries(ctx, field, obj)
		case "metricsGeneratorCollectionInterval":
			out.Values[i] = ec._TempoLimits_metricsGeneratorCollectionInterval(ctx, field, obj)
		case "metricsGeneratorDisableCollection":
			out.Values[i] = ec._TempoLimits_metricsGeneratorDisableCollection(ctx, field, obj)
		case "metricsGeneratorForwarderQueueSize":
			out.Values[i] = ec._TempoLimits_metricsGeneratorForwarderQueueSize(ctx, field, obj)
		case "metricsGeneratorForwarderWorkers":
			out.Values[i] = ec._TempoLimits_metricsGeneratorForwarderWorkers(ctx, field, obj)
		case "metricsGeneratorProcessorServiceGraphsHistogramBuckets":
			out.Values[i] = ec._TempoLimits_metricsGeneratorProcessorServiceGraphsHistogramBuckets(ctx, field, obj)
		case "metricsGeneratorProcessorServiceGraphsDimensions":
			out.Values[i] = ec._TempoLimits_metricsGeneratorProcessorServiceGraphsDimensions(ctx, field, obj)
		case "metricsGeneratorProcessorServiceGraphsPeerAttributes":
			out.Values[i] = ec._TempoLimits_metricsGeneratorProcessorServiceGraphsPeerAttributes(ctx, field, obj)
		case "metricsGeneratorProcessorServiceGraphsEnableClientServerPrefix":
			out.Values[i] = ec._TempoLimits_metricsGeneratorProcessorServiceGraphsEnableClientServerPrefix(ctx, field, obj)
		case "metricsGeneratorProcessorSpanMetricsHistogramBuckets":
			out.Values[i] = ec._TempoLimits_metricsGeneratorProcessorSpanMetricsHistogramBuckets(ctx, field, obj)
		case "metricsGeneratorProcessorSpanMetricsDimensions":
			out.Values[i] = ec._TempoLimits_metricsGeneratorProcessorSpanMetricsDimensions(ctx, field, obj)
		case "metricsGeneratorProcessorSpanMetricsIntrinsicDimensions":
			out.Values[i] = ec._TempoLimits_metricsGeneratorProcessorSpanMetricsIntrinsicDimensions(ctx, field, obj)
		case "metricsGeneratorProcessorSpanMetricsFilterPolicies":
			out.Values[i] = ec._TempoLimits_metricsGeneratorProcessorSpanMetricsFilterPolicies(ctx, field, obj)
		case "metricsGeneratorProcessorSpanMetricsDimensionMappings":
			out.Values[i] = ec._TempoLimits_metricsGeneratorProcessorSpanMetricsDimensionMappings(ctx, field, obj)
		case "metricsGeneratorProcessorSpanMetricsEnableTargetInfo":
			out.Values[i] = ec._TempoLimits_metricsGeneratorProcessorSpanMetricsEnableTargetInfo(ctx, field, obj)
		case "metricsGeneratorProcessorLocalBlocksMaxLiveTraces":
			out.Values[i] = ec._TempoLimits_metricsGeneratorProcessorLocalBlocksMaxLiveTraces(ctx, field, obj)
		case "metricsGeneratorProcessorLocalBlocksMaxBlockDuration":
			out.Values[i] = ec._TempoLimits_metricsGeneratorProcessorLocalBlocksMaxBlockDuration(ctx, field, obj)
		case "metricsGeneratorProcessorLocalBlocksMaxBlockBytes":
			out.Values[i] = ec._TempoLimits_metricsGeneratorProcessorLocalBlocksMaxBlockBytes(ctx, field, obj)
		case "metricsGeneratorProcessorLocalBlocksFlushCheckPeriod":
			out.Values[i] = ec._TempoLimits_metricsGeneratorProcessorLocalBlocksFlushCheckPeriod(ctx, field, obj)
		case "metricsGeneratorProcessorLocalBlocksTraceIdlePeriod":
			out.Values[i] = ec._TempoLimits_metricsGeneratorProcessorLocalBlocksTraceIdlePeriod(ctx, field, obj)
		case "metricsGeneratorProcessorLocalBlocksCompleteBlockTimeout":
			out.Values[i] = ec._TempoLimits_metricsGeneratorProcessorLocalBlocksCompleteBlockTimeout(ctx, field, obj)
		case "blockRetention":
			out.Values[i] = ec._TempoLimits_blockRetention(ctx, field, obj)
		case "maxBytesPerTagValuesQuery":
			out.Values[i] = ec._TempoLimits_maxBytesPerTagValuesQuery(ctx, field, obj)
		case "maxBlocksPerTagValuesQuery":
			out.Values[i] = ec._TempoLimits_maxBlocksPerTagValuesQuery(ctx, field, obj)
		case "maxSearchDuration":
			out.Values[i] = ec._TempoLimits_maxSearchDuration(ctx, field, obj)
		case "maxBytesPerTrace":
			out.Values[i] = ec._TempoLimits_maxBytesPerTrace(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userImplementors = []string{"User"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *model.User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":
			out.Values[i] = ec._User_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._User_name(ctx, field, obj)
		case "email":
			out.Values[i] = ec._User_email(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "groups":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_groups(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "recoveryLink":
			out.Values[i] = ec._User_recoveryLink(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNBlockedQuery2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐBlockedQuery(ctx context.Context, sel ast.SelectionSet, v *v1alpha1.BlockedQuery) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BlockedQuery(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBlockedQueryInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐBlockedQueryInput(ctx context.Context, v interface{}) (*model.BlockedQueryInput, error) {
	res, err := ec.unmarshalInputBlockedQueryInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBlockedQueryType2githubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐBlockedQueryType(ctx context.Context, v interface{}) (model.BlockedQueryType, error) {
	var res model.BlockedQueryType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBlockedQueryType2githubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐBlockedQueryType(ctx context.Context, sel ast.SelectionSet, v model.BlockedQueryType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNDimensionMappings2githubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐDimensionMappings(ctx context.Context, sel ast.SelectionSet, v v1alpha1.DimensionMappings) graphql.Marshaler {
	return ec._DimensionMappings(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNDimensionMappingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐDimensionMappingsInput(ctx context.Context, v interface{}) (*model.DimensionMappingsInput, error) {
	res, err := ec.unmarshalInputDimensionMappingsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFilterPolicy2githubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐFilterPolicy(ctx context.Context, sel ast.SelectionSet, v v1alpha1.FilterPolicy) graphql.Marshaler {
	return ec._FilterPolicy(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNFilterPolicyInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐFilterPolicyInput(ctx context.Context, v interface{}) (*model.FilterPolicyInput, error) {
	res, err := ec.unmarshalInputFilterPolicyInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGroup2githubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐGroup(ctx context.Context, sel ast.SelectionSet, v model.Group) graphql.Marshaler {
	return ec._Group(ctx, sel, &v)
}

func (ec *executionContext) marshalNGroup2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐGroup(ctx context.Context, sel ast.SelectionSet, v *model.Group) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Group(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGroupInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐGroupInput(ctx context.Context, v interface{}) (*model.GroupInput, error) {
	res, err := ec.unmarshalInputGroupInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNMatchPolicyAttribute2githubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐMatchPolicyAttribute(ctx context.Context, sel ast.SelectionSet, v v1alpha1.MatchPolicyAttribute) graphql.Marshaler {
	return ec._MatchPolicyAttribute(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNMatchPolicyAttributeInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐMatchPolicyAttributeInput(ctx context.Context, v interface{}) (*model.MatchPolicyAttributeInput, error) {
	res, err := ec.unmarshalInputMatchPolicyAttributeInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOAuth2Client2githubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2Client(ctx context.Context, sel ast.SelectionSet, v model.OAuth2Client) graphql.Marshaler {
	return ec._OAuth2Client(ctx, sel, &v)
}

func (ec *executionContext) marshalNOAuth2Client2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2Clientᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.OAuth2Client) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOAuth2Client2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2Client(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNOAuth2Client2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2Client(ctx context.Context, sel ast.SelectionSet, v *model.OAuth2Client) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OAuth2Client(ctx, sel, v)
}

func (ec *executionContext) unmarshalNOAuth2ClientInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2ClientInput(ctx context.Context, v interface{}) (*model.OAuth2ClientInput, error) {
	res, err := ec.unmarshalInputOAuth2ClientInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOAuth2RedirectTo2githubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2RedirectTo(ctx context.Context, sel ast.SelectionSet, v model.OAuth2RedirectTo) graphql.Marshaler {
	return ec._OAuth2RedirectTo(ctx, sel, &v)
}

func (ec *executionContext) marshalNOAuth2RedirectTo2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2RedirectTo(ctx context.Context, sel ast.SelectionSet, v *model.OAuth2RedirectTo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OAuth2RedirectTo(ctx, sel, v)
}

func (ec *executionContext) marshalNObservabilityTenant2githubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenant(ctx context.Context, sel ast.SelectionSet, v model.ObservabilityTenant) graphql.Marshaler {
	return ec._ObservabilityTenant(ctx, sel, &v)
}

func (ec *executionContext) marshalNObservabilityTenant2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.ObservabilityTenant) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNObservabilityTenant2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenant(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNObservabilityTenant2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenant(ctx context.Context, sel ast.SelectionSet, v *model.ObservabilityTenant) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ObservabilityTenant(ctx, sel, v)
}

func (ec *executionContext) marshalNOrganization2githubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOrganization(ctx context.Context, sel ast.SelectionSet, v model.Organization) graphql.Marshaler {
	return ec._Organization(ctx, sel, &v)
}

func (ec *executionContext) marshalNOrganization2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOrganization(ctx context.Context, sel ast.SelectionSet, v *model.Organization) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Organization(ctx, sel, v)
}

func (ec *executionContext) marshalNRelabelConfig2githubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐRelabelConfig(ctx context.Context, sel ast.SelectionSet, v v1alpha1.RelabelConfig) graphql.Marshaler {
	return ec._RelabelConfig(ctx, sel, &v)
}

func (ec *executionContext) marshalNRelabelConfig2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐRelabelConfig(ctx context.Context, sel ast.SelectionSet, v *v1alpha1.RelabelConfig) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RelabelConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRelabelConfigInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐRelabelConfigInput(ctx context.Context, v interface{}) (*model.RelabelConfigInput, error) {
	res, err := ec.unmarshalInputRelabelConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNStreamRetention2githubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐStreamRetention(ctx context.Context, sel ast.SelectionSet, v v1alpha1.StreamRetention) graphql.Marshaler {
	return ec._StreamRetention(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNStreamRetentionInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐStreamRetentionInput(ctx context.Context, v interface{}) (*model.StreamRetentionInput, error) {
	res, err := ec.unmarshalInputStreamRetentionInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNUser2githubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐUser(ctx context.Context, sel ast.SelectionSet, v model.User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalNUser2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐUserᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.User) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUser2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUser2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐUser(ctx context.Context, sel ast.SelectionSet, v *model.User) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐUserInput(ctx context.Context, v interface{}) (*model.UserInput, error) {
	res, err := ec.unmarshalInputUserInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalOBlockedQuery2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐBlockedQueryᚄ(ctx context.Context, sel ast.SelectionSet, v []*v1alpha1.BlockedQuery) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBlockedQuery2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐBlockedQuery(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOBlockedQueryInput2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐBlockedQueryInputᚄ(ctx context.Context, v interface{}) ([]*model.BlockedQueryInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.BlockedQueryInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNBlockedQueryInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐBlockedQueryInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOBlockedQueryType2ᚕgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐBlockedQueryTypeᚄ(ctx context.Context, v interface{}) ([]model.BlockedQueryType, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.BlockedQueryType, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNBlockedQueryType2githubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐBlockedQueryType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOBlockedQueryType2ᚕgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐBlockedQueryTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []model.BlockedQueryType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBlockedQueryType2githubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐBlockedQueryType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOBoolMap2map(ctx context.Context, v interface{}) (map[string]bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := custom.UnmarshalBoolMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := custom.MarshalBoolMap(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) marshalODimensionMappings2ᚕgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐDimensionMappingsᚄ(ctx context.Context, sel ast.SelectionSet, v []v1alpha1.DimensionMappings) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDimensionMappings2githubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐDimensionMappings(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalODimensionMappingsInput2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐDimensionMappingsInputᚄ(ctx context.Context, v interface{}) ([]*model.DimensionMappingsInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.DimensionMappingsInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNDimensionMappingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐDimensionMappingsInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalODuration2k8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx context.Context, v interface{}) (v1.Duration, error) {
	res, err := custom.UnmarshalDuration(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODuration2k8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx context.Context, sel ast.SelectionSet, v v1.Duration) graphql.Marshaler {
	res := custom.MarshalDuration(v)
	return res
}

func (ec *executionContext) unmarshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx context.Context, v interface{}) (*v1.Duration, error) {
	if v == nil {
		return nil, nil
	}
	res, err := custom.UnmarshalDuration(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODuration2ᚖk8sᚗioᚋapimachineryᚋpkgᚋapisᚋmetaᚋv1ᚐDuration(ctx context.Context, sel ast.SelectionSet, v *v1.Duration) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := custom.MarshalDuration(*v)
	return res
}

func (ec *executionContext) marshalOFilterPolicy2ᚕgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐFilterPolicyᚄ(ctx context.Context, sel ast.SelectionSet, v []v1alpha1.FilterPolicy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFilterPolicy2githubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐFilterPolicy(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOFilterPolicyInput2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐFilterPolicyInputᚄ(ctx context.Context, v interface{}) ([]*model.FilterPolicyInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.FilterPolicyInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNFilterPolicyInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐFilterPolicyInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	res, err := graphql.UnmarshalFloat(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloat(v)
	return res
}

func (ec *executionContext) unmarshalOFloat2ᚕfloat64(ctx context.Context, v interface{}) ([]float64, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]float64, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOFloat2float64(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOFloat2ᚕfloat64(ctx context.Context, sel ast.SelectionSet, v []float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOFloat2float64(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOFloat2ᚖfloat64(ctx context.Context, v interface{}) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalFloat(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2ᚖfloat64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalFloat(*v)
	return res
}

func (ec *executionContext) unmarshalOFloatMap2map(ctx context.Context, v interface{}) (map[string]float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := custom.UnmarshalFloatMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloatMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := custom.MarshalFloatMap(v)
	return res
}

func (ec *executionContext) marshalOGroup2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐGroupᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Group) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGroup2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐGroup(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOGroupInput2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐGroupInputᚄ(ctx context.Context, v interface{}) ([]*model.GroupInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.GroupInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNGroupInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐGroupInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOID2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalID(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalID(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	return res
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2ᚖint64(ctx context.Context, v interface{}) (*int64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt64(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint64(ctx context.Context, sel ast.SelectionSet, v *int64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt64(*v)
	return res
}

func (ec *executionContext) marshalOLoginBindings2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐLoginBindings(ctx context.Context, sel ast.SelectionSet, v *model.LoginBindings) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LoginBindings(ctx, sel, v)
}

func (ec *executionContext) unmarshalOLoginBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐLoginBindingsInput(ctx context.Context, v interface{}) (*model.LoginBindingsInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLoginBindingsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLokiLimits2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐLokiLimits(ctx context.Context, sel ast.SelectionSet, v *v1alpha1.LokiLimits) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LokiLimits(ctx, sel, v)
}

func (ec *executionContext) unmarshalOLokiLimitsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐLokiLimitsInput(ctx context.Context, v interface{}) (*v1alpha1.LokiLimitsInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLokiLimitsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOMap2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]interface{}) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalMap(v)
	return res
}

func (ec *executionContext) marshalOMatchPolicyAttribute2ᚕgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐMatchPolicyAttributeᚄ(ctx context.Context, sel ast.SelectionSet, v []v1alpha1.MatchPolicyAttribute) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMatchPolicyAttribute2githubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐMatchPolicyAttribute(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOMatchPolicyAttributeInput2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐMatchPolicyAttributeInputᚄ(ctx context.Context, v interface{}) ([]*model.MatchPolicyAttributeInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MatchPolicyAttributeInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMatchPolicyAttributeInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐMatchPolicyAttributeInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOMatchType2githubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐMatchType(ctx context.Context, v interface{}) (v1alpha1.MatchType, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := v1alpha1.MatchType(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMatchType2githubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐMatchType(ctx context.Context, sel ast.SelectionSet, v v1alpha1.MatchType) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	return res
}

func (ec *executionContext) unmarshalOMatchType2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐMatchType(ctx context.Context, v interface{}) (*v1alpha1.MatchType, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := v1alpha1.MatchType(tmp)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMatchType2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐMatchType(ctx context.Context, sel ast.SelectionSet, v *v1alpha1.MatchType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(string(*v))
	return res
}

func (ec *executionContext) marshalOMimirLimits2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐMimirLimits(ctx context.Context, sel ast.SelectionSet, v *v1alpha1.MimirLimits) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MimirLimits(ctx, sel, v)
}

func (ec *executionContext) unmarshalOMimirLimitsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐMimirLimitsInput(ctx context.Context, v interface{}) (*v1alpha1.MimirLimitsInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputMimirLimitsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOName2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐName(ctx context.Context, sel ast.SelectionSet, v *model.Name) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Name(ctx, sel, v)
}

func (ec *executionContext) unmarshalONameInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐNameInput(ctx context.Context, v interface{}) (*model.NameInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNameInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONotifierBasicAuth2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐNotifierBasicAuth(ctx context.Context, sel ast.SelectionSet, v *v1alpha1.NotifierBasicAuth) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._NotifierBasicAuth(ctx, sel, v)
}

func (ec *executionContext) unmarshalONotifierBasicAuthInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐNotifierBasicAuthInput(ctx context.Context, v interface{}) (*model.NotifierBasicAuthInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNotifierBasicAuthInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONotifierConfig2githubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐNotifierConfig(ctx context.Context, sel ast.SelectionSet, v v1alpha1.NotifierConfig) graphql.Marshaler {
	return ec._NotifierConfig(ctx, sel, &v)
}

func (ec *executionContext) unmarshalONotifierConfigInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐNotifierConfigInput(ctx context.Context, v interface{}) (*model.NotifierConfigInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNotifierConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONotifierHeaderAuth2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐNotifierHeaderAuth(ctx context.Context, sel ast.SelectionSet, v *v1alpha1.NotifierHeaderAuth) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._NotifierHeaderAuth(ctx, sel, v)
}

func (ec *executionContext) unmarshalONotifierHeaderAuthInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐNotifierHeaderAuthInput(ctx context.Context, v interface{}) (*model.NotifierHeaderAuthInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNotifierHeaderAuthInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONotifierTLSClientConfig2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐNotifierTLSClientConfig(ctx context.Context, sel ast.SelectionSet, v *v1alpha1.NotifierTLSClientConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._NotifierTLSClientConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalONotifierTLSClientConfigInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐNotifierTLSClientConfigInput(ctx context.Context, v interface{}) (*model.NotifierTLSClientConfigInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNotifierTLSClientConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOAuth2Client2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2Clientᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.OAuth2Client) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOAuth2Client2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2Client(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOOAuth2Client2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2Client(ctx context.Context, sel ast.SelectionSet, v *model.OAuth2Client) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._OAuth2Client(ctx, sel, v)
}

func (ec *executionContext) unmarshalOOAuth2ClientInput2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2ClientInputᚄ(ctx context.Context, v interface{}) ([]*model.OAuth2ClientInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.OAuth2ClientInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNOAuth2ClientInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2ClientInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOOAuth2ConsentRequest2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2ConsentRequest(ctx context.Context, sel ast.SelectionSet, v *model.OAuth2ConsentRequest) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._OAuth2ConsentRequest(ctx, sel, v)
}

func (ec *executionContext) marshalOOAuth2LoginRequest2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOAuth2LoginRequest(ctx context.Context, sel ast.SelectionSet, v *model.OAuth2LoginRequest) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._OAuth2LoginRequest(ctx, sel, v)
}

func (ec *executionContext) marshalOObservabilityTenantLimits2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantLimits(ctx context.Context, sel ast.SelectionSet, v *model.ObservabilityTenantLimits) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ObservabilityTenantLimits(ctx, sel, v)
}

func (ec *executionContext) unmarshalOObservabilityTenantLimitsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantLimitsInput(ctx context.Context, v interface{}) (*model.ObservabilityTenantLimitsInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputObservabilityTenantLimitsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOObservabilityTenantPermissionBindings2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindings(ctx context.Context, sel ast.SelectionSet, v *model.ObservabilityTenantPermissionBindings) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ObservabilityTenantPermissionBindings(ctx, sel, v)
}

func (ec *executionContext) unmarshalOObservabilityTenantPermissionBindingsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐObservabilityTenantPermissionBindingsInput(ctx context.Context, v interface{}) (*model.ObservabilityTenantPermissionBindingsInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputObservabilityTenantPermissionBindingsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOidcContext2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐOidcContext(ctx context.Context, sel ast.SelectionSet, v *model.OidcContext) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._OidcContext(ctx, sel, v)
}

func (ec *executionContext) marshalOPolicyMatch2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐPolicyMatch(ctx context.Context, sel ast.SelectionSet, v *v1alpha1.PolicyMatch) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PolicyMatch(ctx, sel, v)
}

func (ec *executionContext) unmarshalOPolicyMatchInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐPolicyMatchInput(ctx context.Context, v interface{}) (*model.PolicyMatchInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPolicyMatchInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalORelabelAction2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐRelabelAction(ctx context.Context, v interface{}) (*model.RelabelAction, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.RelabelAction)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORelabelAction2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐRelabelAction(ctx context.Context, sel ast.SelectionSet, v *model.RelabelAction) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalORelabelConfig2ᚕgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐRelabelConfigᚄ(ctx context.Context, sel ast.SelectionSet, v []v1alpha1.RelabelConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRelabelConfig2githubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐRelabelConfig(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalORelabelConfig2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐRelabelConfigᚄ(ctx context.Context, sel ast.SelectionSet, v []*v1alpha1.RelabelConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRelabelConfig2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐRelabelConfig(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalORelabelConfigInput2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐRelabelConfigInputᚄ(ctx context.Context, v interface{}) ([]*model.RelabelConfigInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.RelabelConfigInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNRelabelConfigInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐRelabelConfigInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalORulerAlertManagerConfig2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐRulerAlertManagerConfig(ctx context.Context, sel ast.SelectionSet, v *v1alpha1.RulerAlertManagerConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RulerAlertManagerConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalORulerAlertManagerConfigInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐRulerAlertManagerConfigInput(ctx context.Context, v interface{}) (*model.RulerAlertManagerConfigInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputRulerAlertManagerConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOShardstreamsConfig2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐShardstreamsConfig(ctx context.Context, sel ast.SelectionSet, v *v1alpha1.ShardstreamsConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ShardstreamsConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOShardstreamsConfigInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐShardstreamsConfigInput(ctx context.Context, v interface{}) (*model.ShardstreamsConfigInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputShardstreamsConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOStreamRetention2ᚕgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐStreamRetentionᚄ(ctx context.Context, sel ast.SelectionSet, v []v1alpha1.StreamRetention) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNStreamRetention2githubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐStreamRetention(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOStreamRetentionInput2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐStreamRetentionInputᚄ(ctx context.Context, v interface{}) ([]*model.StreamRetentionInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.StreamRetentionInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNStreamRetentionInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐStreamRetentionInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	return res
}

func (ec *executionContext) unmarshalOString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚕᚖstring(ctx context.Context, v interface{}) ([]*string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOString2ᚖstring(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕᚖstring(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOString2ᚖstring(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚕᚖstringᚄ(ctx context.Context, v interface{}) ([]*string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2ᚖstring(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕᚖstringᚄ(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2ᚖstring(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOStringMap2map(ctx context.Context, v interface{}) (map[string]string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := custom.UnmarshalStringMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOStringMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := custom.MarshalStringMap(v)
	return res
}

func (ec *executionContext) marshalOTempoLimits2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐTempoLimits(ctx context.Context, sel ast.SelectionSet, v *v1alpha1.TempoLimits) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TempoLimits(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTempoLimitsInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚑcontrollerᚋapiᚋobservabilityᚋv1alpha1ᚐTempoLimitsInput(ctx context.Context, v interface{}) (*v1alpha1.TempoLimitsInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTempoLimitsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTime2ᚖtimeᚐTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2ᚖtimeᚐTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) unmarshalOUInt2ᚖuint32(ctx context.Context, v interface{}) (*uint32, error) {
	if v == nil {
		return nil, nil
	}
	res, err := custom.UnmarshalUInt32(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUInt2ᚖuint32(ctx context.Context, sel ast.SelectionSet, v *uint32) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := custom.MarshalUInt32(*v)
	return res
}

func (ec *executionContext) unmarshalOUInt2ᚖuint64(ctx context.Context, v interface{}) (*uint64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := custom.UnmarshalUInt64(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUInt2ᚖuint64(ctx context.Context, sel ast.SelectionSet, v *uint64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := custom.MarshalUInt64(*v)
	return res
}

func (ec *executionContext) marshalOUser2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐUserᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUser2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOUserInput2ᚕᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐUserInputᚄ(ctx context.Context, v interface{}) ([]*model.UserInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.UserInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUserInput2ᚖgithubᚗcomᚋpluralshᚋtraceᚑshieldᚋgraphᚋmodelᚐUserInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
